import * as D3 from 'd3';
export class ChartHelper {
    static percentageToRadius(percentage: number): number {
        return percentage * 360 * Math.PI / 180;
    }

    static createGaugeMeasurements(diameter: number): GaugeMeasurements {
        const radius = diameter / 2;
        const outerRadius = Math.floor(radius);
        return {
            diameter: diameter,
            radius: radius,
            innerRadius: Math.floor(radius) - 5,
            outerRadius,
        };
    }

    static cropBarChartLabel(svg: SVGGElement,
        rotatedLabels: boolean, columns: number, height: number): D3.Selection<SVGGElement, {}, null, undefined> {
        const svgElement = D3.select(svg);
        const axisBars = svgElement.selectAll('.axis--bars')
        .node() as SVGGElement;
        const axisY = svgElement.selectAll('.axis--y')
        .node() as SVGGElement;
        D3.select(svg).selectAll('.axis--x')
            .selectAll('.tick')
            .each(function() {
                const node: SVGTextElement = D3.select(this)
                    .select('text')
                    .node() as SVGTextElement;
                const boxNode: SVGGElement = D3.select(this)
                    .node() as SVGGElement;
                if (rotatedLabels) {
                    const nodeHeight = node.getBoundingClientRect().height;
                    if ( nodeHeight > height)  {
                        const textSize = ( Math.ceil(node.getComputedTextLength() / node.textContent.length)) + 1;
                        const cropLength = Math.floor(height / textSize);
                        D3.select(boxNode)
                        .selectAll('title')
                        .remove();
                        D3.select(boxNode)
                            .append('title')
                            .text( node.textContent);
                        D3.select(this)
                            .select('text')
                            .text(node.textContent.substr(0, cropLength ) + '...');
                    }
                } else {
                    let barWidth;
                    if ( axisBars) {
                        barWidth = axisBars.getBoundingClientRect().width / columns;
                    } else {
                        barWidth = axisY.getBoundingClientRect().width / columns;
                    }

                    const textWidth = node.getComputedTextLength();
                    if ( textWidth > barWidth ) {

                        const pixelsPerChar = textWidth / node.textContent.length;
                        const cropLength = barWidth / pixelsPerChar;
                        D3.select(boxNode)
                            .append('title')
                            .text( node.textContent);
                        D3.select(this)
                            .select('text')
                            .text(node.textContent.substr(0, cropLength ) + '...');
                    }
                }

            });
        return D3.select(svg);
    }
    static isLabelWiderThanContainer(svg: SVGElement, columns: number): boolean {
        let shouldRotate: boolean = false;
        if ( svg) {
            const svgNode = D3.select(svg);
            if ( svgNode  && !svgNode.empty()) {
                const container = svgNode.selectAll('.axis--x');
                if ( !container.empty() ) {
                    const containerNode = container.node() as SVGGElement;
                    if ( containerNode) {
                        const width = Math.floor(containerNode.getBoundingClientRect().width / columns);
                        D3.select(containerNode)
                            .selectAll('.tick')
                            .each(function() {
                                const node = D3.select(this)
                                .select('text')
                                .node() as SVGTextElement;
                                const length = Math.ceil( node.getComputedTextLength() ) + 20;
                                if ( length > width) {
                                    shouldRotate = true;
                                }
                            });
                    }
                }
            }
        }

        return shouldRotate;
    }
}

export type GaugeMeasurements = {
    diameter: number,
    radius: number,
    innerRadius: number,
    outerRadius: number,
};
