import { ElementRef } from '@angular/core';
import { ICoordinate } from '../interfaces/coordinate.interface';

export class DOMHelper {
    static getElementPageOffset(el: HTMLElement): ICoordinate {
        const sOff = DOMHelper.dw_getScrollOffsets();
        let left = 0;
        let top = 0;
        let props;

        if (el.getBoundingClientRect) {
            props = el.getBoundingClientRect();
            left = props.left + sOff.x;
            top = props.top + sOff.y;
        } else { // for older browsers
            do {
                left += el.offsetLeft;
                top += el.offsetTop;
            } while ((el = <HTMLElement>el.offsetParent));
        }
        return { x: Math.round(left), y: Math.round(top) };
    }

    static dw_getScrollOffsets() {
        const doc = document, w = window;
        let x, y, docEl;

        if (typeof w.pageYOffset === 'number') {
            x = w.pageXOffset;
            y = w.pageYOffset;
        } else {
            docEl = (doc.compatMode && doc.compatMode === 'CSS1Compat') ?
                doc.documentElement : doc.body;
            x = docEl.scrollLeft;
            y = docEl.scrollTop;
        }
        return { x: x, y: y };
    }

    /**
     * Smooth scroll an element to a vertical position during a given number of milliseconds.
     *
     * @param element
     * @param yPosition
     * @param duration
     * @returns Promise{any}
     */
    static scrollTo(element: Element, yPosition: number, duration: number): Promise<any> {
        yPosition = Math.round(yPosition);
        duration = Math.round(duration);
        if (duration < 0) {
            return Promise.reject('Bad duration');
        }
        if (duration === 0 || element.scrollTop === yPosition) {
            element.scrollTop = yPosition;
            return Promise.resolve();
        }
        const start_time = Date.now();
        const end_time = start_time + duration;
        const start_top = element.scrollTop;
        const distance = yPosition - start_top;

        // based on http://en.wikipedia.org/wiki/Smoothstep
        const smooth_step = function (start: number, end: number, point: number) {
            if (point <= start) {
                return 0;
            }
            if (point >= end) {
                return 1;
            }
            const x = (point - start) / (end - start); // interpolation
            return x * x * (3 - 2 * x);
        };
        let previous_top = element.scrollTop;

        return new Promise(function (resolve, reject) {
            // This is to keep track of where the element's scrollTop is
            // supposed to be, based on what we're doing

            const scroll_frame = function () {
                if (element.scrollTop !== previous_top) {
                    reject('Interrupted');
                    return;
                }

                // set the scrollTop for this frame
                const now = Date.now();
                const point = smooth_step(start_time, end_time, now);
                const frameTop = Math.round(start_top + (distance * point));
                element.scrollTop = frameTop;

                // check if we're done!
                if (now >= end_time) {
                    resolve();
                    return;
                }

                // If we were supposed to scroll but didn't, then we
                // probably hit the limit, so consider it done; not
                // interrupted.
                if (element.scrollTop === previous_top
                    && element.scrollTop !== frameTop) {
                    resolve();
                    return;
                }
                previous_top = element.scrollTop;

                // schedule next frame for execution
                setTimeout(() => scroll_frame(), 0);
            };

            // bootstrap the animation process
            setTimeout(() => scroll_frame(), 0);
        });
    }

    /**
     * Get which index a node has in relation to it's siblings
     * @param element
     * @returns {number}
     */
    static getNodeIndex(element: HTMLElement): number {
        if (!element || !element.parentElement) {
            return -1;
        }
        const childrens = Array.prototype.slice.call(element.parentElement.children);
        return childrens.indexOf(element);
    }

    /**
     * Converts \n to <br />
     * @param string
     * @returns {string}
     */
    static nl2br(string: string): string {
        return (string + '').replace(/([^>\r\n]?)(\r\n|\n\r|\r|\n)/g, '$1' + '<br />' + '$2');
    }

    static getCuiApplicationContainer(): HTMLElement {
        const element = document.getElementById('cui-application');
        if (!element) {
            throw new Error(`
                An element with ID cui-application is missing, please make sure you have one in the DOM.
            `);
        }
        return element;
    }
    /**
     * Uses canvas.measureText to compute and return the width of the given text of given font in pixels.
     *
     * @param {String} text The text to be rendered.
     * @param {String} font The css font descriptor that text is to be rendered with (e.g. "bold 14px verdana").
     */
    static getTextWidth(canvas: HTMLCanvasElement, text: string, font = '13px arial'): number {
        const context = canvas.getContext('2d');
        context.font = font;
        const metrics = context.measureText(text);
        return metrics.width;
    }

    /**
     * Test if date is valid, passing date as a dd/mm/yy string
     * @param string
     * @returns {DateConstructor|boolean}
     */
    static isValidDate(string: string): boolean {
        const bits = string.split('/');
        const d = new Date(parseInt(bits[2], 10), parseInt(bits[1], 10) - 1, parseInt(bits[0], 10));
        return d && (d.getMonth() + 1) === parseInt(bits[1], 10);
    }

    /**
     * Returns whether or not an element is visible in its container
     * @param {HTMLElement} container
     * @param {HTMLElement} element
     * @param {boolean} partial
     * @returns {boolean | undefined}
     */
    static checkInView(container: HTMLElement, element: HTMLElement, partial: boolean = true) {
        const contHeight = container.offsetHeight,
            elemTop = DOMHelper.offset(element).top - DOMHelper.offset(container).top,
            elemBottom = elemTop + element.offsetHeight;
        return (elemTop >= 0 && elemBottom <= contHeight) ||
            (partial && ((elemTop < 0 && elemBottom > 0) || (elemTop > 0 && elemTop <= contHeight)));
    }
    static isWindow(obj) {
        return obj != null && obj === obj.window;
    }
    static getWindow(elem) {
        return DOMHelper.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }
    static offset(elem) {
        let docElem, win,
            box = { top: 0, left: 0 };
        const doc = elem && elem.ownerDocument;
        docElem = doc.documentElement;
        if (typeof elem.getBoundingClientRect !== typeof undefined) {
            box = elem.getBoundingClientRect();
        }
        win = DOMHelper.getWindow(doc);
        return {
            top: box.top + win.pageYOffset - docElem.clientTop,
            left: box.left + win.pageXOffset - docElem.clientLeft
        };
    }

    /**
     * Returns true if element is overflowed (its content is bigger than its size)
     * @param element
     * @returns {boolean}
     */
    static isOverflowed(element: HTMLElement): boolean {
        return element.scrollHeight > element.clientHeight || element.scrollWidth > element.clientWidth;
    }


    /**
     * Insert a char-counter element if maxLength attribute is present and we haven't already inserted a char-counter
     * @param element{ElementRef} element - The element input the character counter depend on.
     */
    static insertCharCounter(element: ElementRef): void {
        if (element.nativeElement.hasAttribute('maxLength') &&
            element.nativeElement.getAttribute('type') !== 'number' &&
            !element.nativeElement.parentNode.querySelector('.char-counter')) {
            const _id: string = element.nativeElement.id;
            let lastElement: Element;
            let _label: Element;
            if (_id) {
                _label = document.querySelector(`label[for='${_id}']`);
            }
            if (!_label) {
                _label = element.nativeElement.parentNode.querySelector('label');
            }
            if (_label) {
                lastElement = _label;
            } else {
                lastElement = element.nativeElement;
            }

            const _newLines = element.nativeElement.value.match(/(\r\n|\n|\r)/g);
            let _addition = 0;
            if (_newLines != null) {
                _addition = _newLines.length;
            }
            lastElement.insertAdjacentHTML('afterend', '<div class="char-counter"><span>' +
                (element.nativeElement.value.length + _addition) + '</span>/' +
                element.nativeElement.maxLength + '</div>');

        }
    }

    /**
     * Updates input counter in character counter element
     * @param {ElementRef} element - The element input the character counter depend on.
     */
    static updateChartCounterValue(element: ElementRef): void {
        if (element.nativeElement.maxLength !== -1) {
            // manual max length slicer because some browsers doesn't support max length on input[type=number]
            // checking keyboard event key length to only trigger on actual character keys (not arrows, tab etc)
            if (element.nativeElement.type === 'number') {
                element.nativeElement.value = element.nativeElement.value.slice(0, element.nativeElement.maxLength);
            }

            // Char counter element not created for input
            if (element.nativeElement.parentNode && !element.nativeElement.parentNode.querySelector('.char-counter')) {
                DOMHelper.insertCharCounter(element);
                return;
            }
            element.nativeElement.parentNode.querySelector('.char-counter')
                .querySelector('span').innerHTML = element.nativeElement.value.length;
        }
    }

    /**
     * Get closest parent that matches a classname, going backwards from @element
     * @param element
     * @param lookForClass
     * @param stopAtClass
     * @returns {any} (null or Element)
     */
    static closestParent(element, lookForClass, stopAtClass: string | boolean = false): any {
        let retval = null;
        while (element) {
            if (element.classList.contains(lookForClass)) {
                retval = element;
                break;
            } else if (stopAtClass && element.classList.contains(stopAtClass)) {
                break;
            }
            element = element.parentElement;
        }
        return retval;
    }

    /**
     * Get farthest parent that matches a classname, going backwards from @element
     * @param element
     * @param lookForClass
     * @param stopAtClass
     * @returns {any} (null or Element)
     */
    static farthestParent(element, lookForClass, stopAtClass: string | boolean = false): any {
        let retval = null;
        while (element) {
            if (element.classList.contains(lookForClass)) {
                retval = element;
            } else if (stopAtClass && element.classList.contains(stopAtClass)) {
                break;
            }
            element = element.parentElement;
        }
        return retval;
    }

    /**
     * Get closest parent that matches a tagname, going backwards from @element
     * @param element
     * @param {string} lookForTag
     * @param {string} stopAtTag
     * @returns {any}
     */
    static closestParentTag(element: HTMLElement, lookForTag: string, stopAtTag?: string): any {
        let retval = null;
        while (element) {
            if (element && element.nodeName === lookForTag.toUpperCase()) {
                retval = element;
                break;
            } else if (stopAtTag && element.nodeName === stopAtTag.toUpperCase()) {
                break;
            }
            element = element.parentElement;
        }
        return retval;
    }

    /**
     * Get the css value of an element's property, ie 'absolute' if you ask for position.
     * @param element: An html element, typically "this._element.nativeElement"
     * @param property: Ie display, position, width etc
     * @returns value of element
     */
    /** @deprecated window.getComputedStyle is supported in all modern browsers,
     * use window.getComputedStyle(element).getPropertyValue(property) instead */
    static getCssValue(element: Element, property: string): string {
        const style = window.getComputedStyle(element);
        if (typeof style[property] !== 'undefined') {
            return style[property];
        } else {
            return style.getPropertyValue(property);
        }
    }

    /**
     * Converts "rgb(255, 255, 255)" to "#FFF"
     * @param rgb
     * @returns {string}
     */
    static rgb2hex(rgb: string): string {
        const _rgb = rgb.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
        return (_rgb && _rgb.length === 4) ? '#' +
            ('0' + parseInt(_rgb[1], 10).toString(16)).slice(-2) +
            ('0' + parseInt(_rgb[2], 10).toString(16)).slice(-2) +
            ('0' + parseInt(_rgb[3], 10).toString(16)).slice(-2) : '';
    }

    /**
     * Takes a color hex string and returns true if it's light and false if it's dark
     * @param bgColor
     * @returns {boolean}
     */
    static colorIsLight(bgColor: string): boolean {
        // strip #
        if (bgColor.charAt(0) === '#') {
            bgColor = bgColor.substr(1, bgColor.length);
        }
        const r = parseInt(bgColor.substr(0, 2), 16);
        const g = parseInt(bgColor.substr(2, 2), 16);
        const b = parseInt(bgColor.substr(4, 2), 16);
        const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
        return yiq >= 160;
    }


    /**
     * Calculate the heighest child within an element.
     * This is useful when you get 0px as outerHeight from an element
     * because it's content have position absolute.
     * @param element
     * @returns {number}
     */
    static getHeighestChild(element: HTMLElement): number {
        let biggestHeight = 0;
        // Loop through elements children to find & set the biggest height
        [].map.call(element.querySelectorAll('*'), function (el) {
            // If this elements height is bigger than the biggestHeight
            const elemHeight = el.offsetHeight;
            if (elemHeight > biggestHeight) {
                // Set the biggestHeight to this Height
                biggestHeight = elemHeight;
            }
        });
        return biggestHeight;
    }

    /**
     * Calculate the lowest child from an querySelectorAll of elements.
     * @param elements
     * @returns {number}
     */
    static getLowestElement(elements: HTMLCollection): number {
        let lowestHeight = 0;
        if (elements.length) {
            lowestHeight = (<HTMLElement>elements[0]).offsetHeight;
            // Loop through elements to find & set the lowest height
            [].map.call(elements, function (el) {
                // If this elements height is smaller than the lowestHeight
                const elemHeight = el.offsetHeight;
                if (elemHeight < lowestHeight) {
                    // Set the lowestHeight to this Height
                    lowestHeight = elemHeight;
                }
            });
        }
        return lowestHeight;
    }

    static rippleEffect(element: HTMLElement, event: MouseEvent): void {
        const time = 2000,
            rect = element.getBoundingClientRect(),
            x = event.clientX - rect.left,
            y = event.clientY - rect.top,
            circle = document.createElement('div');

        circle.style.top = y + 'px';
        circle.style.left = x + 'px';
        circle.className = 'ripple-effect';
        element.appendChild(circle);

        setTimeout(function () {
            element.removeChild(circle);
        }, time);
    }

    /**
     * Returns the css value as a number (10px becomes 10)
     * @param element
     * @param property
     * @returns {number}
     */
    /** @deprecated Use parseInt(window.getComputedStyle(element).getPropertyValue(property), 10) instead */
    static getCssNumber(element: HTMLElement, property: string): number {
        return parseInt(DOMHelper.getCssValue(element, property), 10) || 0;
    }

    static getOuterWidth(element: any) {
        return element ? element.offsetWidth : 0;
    }

    static getLeftPosition(element: HTMLElement) {
        return element ? element.offsetLeft : 0;
    }

    static getOuterHeight(element: any) {
        return element ? element.offsetHeight : 0;
    }

    /**
     * Multiplies css size with a factor independent size type.
     * @param size - CSS size ie. 600px or 50%
     * @param factor
     * @return {string}
     */
    static multiplyCssSize(size: string, factor: number): string {
        const regex: RegExp = /(\d+)(\D+)?/g;
        const match: Array<any> = regex.exec(size);
        return (match[1] * factor) + (match[2] || 'px');
    }

    /**
     *
     * @param event
     * @param target
     * @return ICoordinate
     */
    static getMousePointerOffset(event: MouseEvent, target: HTMLElement): ICoordinate {
        return {
            x: event.clientX - target.getBoundingClientRect().left,
            y: event.clientY - target.getBoundingClientRect().top
        };
    }

    /**
     * Adds a <span> with highlight class in your source where searchValue is a match
     * @param {string} searchValue
     * @param {string} source
     * @param {string} extraClass
     * @param {RegExp} regex
     * @returns {string}
     */
    static highlightString(searchValue: string, source: string, extraClass: string = '',
        regex: RegExp = new RegExp(searchValue.trim(), 'gi')): string {
        let _class = 'highlighted';
        if (extraClass !== '') {
            _class += ' ' + extraClass;
        }
        return source.replace(regex, (match) => {
            return match.length > 0 ? '<span class="' + _class + '">' + match + '</span>' : match;
        });
    }

    /**
     * Returns true if target element is child or grand child of element
     * @param {string} containerSelector
     * @param {Node} target
     * @return {boolean}
     */
    static isChildOfElement(containerSelector: string, target: Node) {
        const containerNodes = [].slice.call(document.querySelectorAll(containerSelector));
        return containerNodes.filter(dz => dz.contains(target)).length !== 0;
    }

    static removeElement(element: HTMLElement): void {
        if (element.remove) {
            element.remove();
        } else {
            element.parentNode.removeChild(element);
        }
    }
}

