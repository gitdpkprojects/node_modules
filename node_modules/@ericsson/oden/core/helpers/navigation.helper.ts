import { Router } from '@angular/router';
import { UniversalService } from '../../components/universal/universal.service';

export type Route = {
    path: string,
    externalApp: string
};

export class NavigationHelper {

    /**
     * Returns true or false if the regex matches
     * @param path
     */
    static isInternalURL(path: string) {
        return !(path.match(/^https?:\/\//i) || path.match(/^SELFHOST:\/\//i));
    }

    /**
     * Returns true if the route should be used for navigation to an external application
     * @param route
     */
    static isExternalApp(route: Route): boolean {
        return Boolean(route.externalApp);
    }

    /**
     * Returns path string as regex replaced string
     * @param path
     */
    static getVaildRoutePath(path: string): string {
        return path.match(/^SELFHOST:\/\//i) ? path.replace(/SELFHOST:\//i, '') : path;
    }

    /**
     * Navigates by using the window.location (or window.parent if we're in an iframe)
     * @param {string} path
     */
    static navigateWithWindowLocation(path: string): void {
        if (window.location !== window.parent.location) {
            window.parent.location.href = path;
        } else {
            window.location.href = path;
        }
    }
    /**
     * when an externalApp is active already and if try to open
     * another externalApp from universal layer (ex: table, charts) make sure that
     * it closes universal overlay
     * @param us
     */
    static checkAndCloseUniversalOverlay(us: UniversalService): void {
        if (us && us.isOpen) {
            us.hideUniversalOverlay();
        }
    }

    /**
     * check the route param and navigate
     * @param route
     * @param router
     */
    static navigateToRoute(route: string | Route, router: Router, universalService?: UniversalService): void {
        if (typeof route === 'string') {
            // string support for backwards compatibility reasons
            NavigationHelper.navigateToPath(route, router, universalService);
        } else {
            const isExternalApp = NavigationHelper.isExternalApp(route);
            NavigationHelper.switchView(route);
            if (isExternalApp) {
                const routePath = NavigationHelper.getVaildRoutePath(route.path);
                NavigationHelper.getActiveIFrame().src = routePath;
                NavigationHelper.checkAndCloseUniversalOverlay(universalService);
            } else {
                NavigationHelper.navigateToPath(route.path, router, universalService);
            }
        }
    }

    /**
     * check the path param and navigate
     * @param path
     * @param router
     */
    static navigateToPath(path: string, router: Router, universalService?: UniversalService): void {
        const isInternalUrl = NavigationHelper.isInternalURL(path);
        const routePath = NavigationHelper.getVaildRoutePath(path);
        if (!isInternalUrl) {
            // Treat as external URL and navigate!
            NavigationHelper.navigateWithWindowLocation(routePath);
        } else {
            if (!NavigationHelper.getActiveIFrame()) { // just to prevent if any iframe is still active
                // do navigate!
                router.navigateByUrl(routePath);
            } else {
                const route: Route = {
                    path: routePath,
                    externalApp: null
                };
                NavigationHelper.switchView(route);
                router.navigateByUrl(routePath);
                NavigationHelper.checkAndCloseUniversalOverlay(universalService);
            }
        }
    }

    /**
     * Switch view between CUI application and an external application. If the ext app iframe doesn't exist, it's created.
     * @param route
     */
    static switchView(route: Route): void {
        const cuiApp = document.querySelector('#cui-application');
        const extApps = NavigationHelper.getOrCreateExtAppsContainer('#ext-applications', cuiApp);
        NavigationHelper.removeCssClass(NavigationHelper.getActiveIFrame(), 'active');
        NavigationHelper.removeCssClass(document.body, 'cui-external-task-visible');
        if (route.externalApp) {
            let extApp = <HTMLIFrameElement>document.querySelector('#' + route.externalApp);
            if (!extApp) {
                extApp = <HTMLIFrameElement>document.createElement('iframe');
                extApp.id = route.externalApp;
                extApp.name = route.externalApp;
                extApp.frameBorder = '0';
                extApps.appendChild(extApp);
            }
            NavigationHelper.addCssClass(cuiApp, 'hidden');
            NavigationHelper.removeCssClass(extApps, 'hidden');
            NavigationHelper.addCssClass(extApp, 'active');
            NavigationHelper.addCssClass(document.body, 'cui-external-task-visible');
        } else {
            NavigationHelper.removeCssClass(cuiApp, 'hidden');
            NavigationHelper.addCssClass(extApps, 'hidden');
        }
    }

    /**
     * Get the currently active iFrame (the iframe which is visible right now) or undefined when all external applications are closed.
     */
    static getActiveIFrame(): HTMLIFrameElement {
        return <HTMLIFrameElement>document.querySelector('#ext-applications > iframe.active');
    }

    /**
     * Get or create the container (DIV element) for external applications.
     * @private
     * @param {string} selector - The DOM element selector. Supports id (e.g. '#abc') and class (e.g. '.abc') based selection.
     * @param {Element} cuiApp - The cui application element.
     * @return {Element} - The external applications container.
     */
    static getOrCreateExtAppsContainer(selector: string, cuiApp: Element): HTMLDivElement {
        let container = <HTMLDivElement>document.querySelector(selector);
        if (!container) {
            const parent = cuiApp.parentElement;
            const overlay = cuiApp.nextSibling;
            container = <HTMLDivElement>document.createElement('div');
            container.setAttribute(selector.slice(0, 1) === '#' ? 'id' : 'class', selector.slice(1));
            if (overlay) {
                parent.insertBefore(container, overlay);
            } else {
                parent.appendChild(container);
            }
        }
        return container;
    }

    /**
     * Secure way to add a CSS class for a DOM element.
     */
    static addCssClass(el: Element | NodeListOf<Element>, cls: string): void {
        NavigationHelper.toggleCssClass(el, cls, true);
    }

    /**
     * Secure way to remove a CSS class for a DOM element.
     */
    static removeCssClass(el: Element | NodeListOf<Element>, cls: string): void {
        NavigationHelper.toggleCssClass(el, cls, false);
    }

    /**
     * Add or remove CSS class.
     */
    static toggleCssClass(el: Element | NodeListOf<Element>, cls: string, add: boolean): void {
        if (el) {
            if (el instanceof Element) {
                if (add && !el.classList.contains(cls)) {
                    el.classList.add(cls);
                } else if (!add && el.classList.contains(cls)) {
                    el.classList.remove(cls);
                }
            } else {
                for (let i = 0; i < el.length; ++i) {
                    NavigationHelper.toggleCssClass(el.item(i), cls, add);
                }
            }
        }
    }
}
