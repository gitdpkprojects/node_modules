import { saveAs } from 'file-saver';
import { UUID } from './uuid.class';
import { Table2Component, Row2Component } from '../../components/table2';

const UTF8_BOM = '\ufeff';

/**
 * CSV configuration
 */
export interface CSVConfig {
    writeHeader: boolean;
    delimiter: string;
    newline: string;
    quoteChar: string;
}

/**
 * CSV Header Item
 */
export class CSVHeaderItem {
    label: string;
    field?: string;
    hidden?: boolean;

    constructor(headerInfo: Partial<CSVHeaderItem> = {}) {
        Object.assign(this, headerInfo);
    }
}

/**
 * CSV Export Request
 */
export interface CSVRequest {
    headers: Array<CSVHeaderItem>;
    data: Array<any>;
}

/**
 * Default CSV configuration
 */
const DEFAULT_CONFIG: CSVConfig = {
    writeHeader: true,
    delimiter: ',',
    newline: '\r\n',
    quoteChar: '"'
};

const QUOTE_REG_EXP = /"/g;
const IGNORE_COL_CSS = ['select', 'single-action', 'expand', 'ignore-export'];
const IGNORE_ROW_CSS = ['ignore-export'];

export class CSVHelper {
    /**
     * Convert the given JSON to CSV
     * @param {CSVRequest} request
     * @param {CSVConfig} config
     * @returns {string}
     */
    static jsonToCSV(request: CSVRequest, config: CSVConfig = DEFAULT_CONFIG): string {
        const csvConfig = Object.assign({}, DEFAULT_CONFIG, config);
        return this._getCSV(request, csvConfig);
    }

    /**
     * Get the CSV String
     * @param {CSVRequest} request
     * @param {CSVConfig} config
     * @returns {string}
     */
    private static _getCSV(request: CSVRequest, config: CSVConfig): string {
        const headerString = CSVHelper._writeHeaders(request, config);
        const dataString = CSVHelper._writeData(request, config);
        return `${headerString}${dataString}`;
    }

    /**
     * Write headers
     * @param {CSVRequest} request
     * @param {CSVConfig} config
     * @returns {string}
     */
    private static _writeHeaders(request: CSVRequest, config: CSVConfig): string {
        let headerString = '';
        const hasHeader = Array.isArray(request.headers) && request.headers.length > 0;
        if (hasHeader && config.writeHeader) {
            request.headers.filter(t => !t.hidden).forEach((item, index) => {
                if (index > 0) {
                    headerString += config.delimiter;
                }
                headerString += CSVHelper._safeValue(item.label || '', config);
            });

            if (request.data && request.data.length > 0) {
                headerString += config.newline;
            }
        }
        return headerString;
    }

    /**
     * Write data
     * @param {CSVRequest} request
     * @param {CSVConfig} config
     */
    private static _writeData(request: CSVRequest, config: CSVConfig): string {
        let dataString = '';
        const hasHeader = Array.isArray(request.headers) && request.headers.length > 0;
        const hasData = Array.isArray(request.data) && request.data.length > 0;
        if (hasData) {
            const maxColumns = hasHeader ? request.headers.length : request.data[0].length;
            const dataKeyedByField = !(Array.isArray(request.data[0]));
            let firstColIndex = 0;
            firstColIndex = request.headers.indexOf(request.headers.find(t => !t.hidden));
            request.data.forEach((item, rowIndex) => {
                for (let colIndex = 0; colIndex < maxColumns; colIndex++) {

                    if (request.headers[colIndex].hidden) {
                        continue;
                    }

                    if (colIndex > firstColIndex) {
                        dataString += config.delimiter;
                    }
                    let value = null;
                    if (dataKeyedByField) {
                        // Lookup field data by key
                        value = item[request.headers[colIndex].field];
                    } else {
                        // Or by index
                        value = item[colIndex];
                    }
                    dataString += CSVHelper._safeValue(value || '', config);
                }

                // Adds new line
                if (rowIndex < request.data.length) {
                    dataString += config.newline;
                }
            });
        }
        return dataString;
    }

    /**
     * Write safe CSV value
     * @param {string} value
     * @param {CSVConfig} config
     */
    private static _safeValue(value: string, config: CSVConfig): string {
        let str = value.toString().replace(QUOTE_REG_EXP, `${config.quoteChar}${config.quoteChar}`);
        str = str.replace(/(\r\n|\n|\r)/gm, '').trim();
        return `${config.quoteChar}${str}${config.quoteChar}`;
    }

    /**
     * Download the file and show saveAs dialog
     * @param {string} csv
     * @param {string} filename
     */
    static download(csv: string, filename: string = '') {
        filename = filename || `export-${UUID.create()}`;
        const blob = new Blob([UTF8_BOM + csv], { type: 'text/csv; charset=utf-8' });
        saveAs(blob, `${filename}.csv`);
    }

    /**
     * Extract table data
     * @param {HTMLTableElement} tableElement
     * @param {Array<string>} ignoreCssrows
     * @param {Array<string>} ignoreCssCols
     */
    static _getTableData(tableElement: HTMLTableElement, ignoreCssrows?: Array<string>, ignoreCssCols?: Array<string>): {
        headers: Array<CSVHeaderItem>,
        data: Array<Array<string>>
    } {
        const tableData: Array<Array<string>> = [];
        const headers: Array<CSVHeaderItem> = [];

        ignoreCssCols = ignoreCssCols ? ignoreCssCols.concat(IGNORE_COL_CSS) : IGNORE_COL_CSS;
        ignoreCssrows = ignoreCssrows ? ignoreCssrows.concat(IGNORE_ROW_CSS) : IGNORE_ROW_CSS;

        if (tableElement && tableElement.rows.length > 0) {
            // populate header
            const headerRow = tableElement.rows.item(0);
            const headerCells = Array.from(headerRow.cells);
            headerCells.forEach((cell) => {
                let hidden = false;
                if (ignoreCssCols && ignoreCssCols.length > 0) {
                    ignoreCssCols.forEach((cssClass) => {
                        if (cell.classList.contains(cssClass)) {
                            hidden = true;
                        }
                    });
                }

                headers.push({
                    label: cell.textContent,
                    hidden: hidden
                });
            });

            // populate rows
            const dataRows = Array.from(tableElement.rows);
            dataRows.forEach((row, rowIndex) => {
                // ignore rows
                let ignoreRow = false;
                if (ignoreCssrows && ignoreCssrows.length > 0) {
                    for (let index = 0; index < ignoreCssrows.length; index++) {
                        if (row.classList.contains(ignoreCssrows[index])) {
                            ignoreRow = true;
                            break;
                        }
                    }
                }
                if (row.parentElement.tagName.toLocaleUpperCase() === 'TFOOT') {
                    ignoreRow = true;
                }
                if (rowIndex > 0 && !ignoreRow) {
                    const dataCells = Array.from(row.cells);
                    const rowData = [];
                    let rowDataIndex = 0;
                    dataCells.forEach((cell, colIndex) => {
                        const headerItem = headers[colIndex];
                        if (headerItem && !headerItem.hidden) {
                            rowData[rowDataIndex] = cell.textContent;
                            rowDataIndex++;
                        }
                    });
                    tableData.push(rowData);
                }
            });
        }
        return {
            headers: headers.filter((t) => !t.hidden),
            data: tableData
        };
    }

    /**
     * Extract table2 data
     * @param {Table2Component} tableComponent
     *
     */
    static _getTable2Data(tableComponent: Table2Component, indexHeaders): {
        headers: Array<CSVHeaderItem>,
        data: Array<Array<string>>
    } {
        let tableData: Array<Array<string>> = [];
        const headers: Array<CSVHeaderItem> = [];

        if (tableComponent._isNestedTable) {
            headers.push({ label: indexHeaders['ODEN.COMPONENTS.EXPORT.INDEX_LABEL'] });
            headers.push({ label: indexHeaders['ODEN.COMPONENTS.EXPORT.INDEX_PARENT_LABEL'] });
        }

        if (tableComponent && tableComponent._headers) {
            tableComponent._headers.forEach(({labelComponent}) => {
                const headerLabel = labelComponent ? labelComponent.label : '';
                headers.push({
                    label: headerLabel
                });
            });
        }

        const rowDataExtractorFn = (row: Row2Component): Array<string[]> => {
            const rowsData: Array<string[]> = [];
            if (row) {
                const rowData = [];
                if (row.cells && row.cells.length > 0) {
                    let rowIndexOffset = 0;
                    if (tableComponent._isNestedTable) {
                        rowIndexOffset = 2;
                        rowData[0] = row.rowId;
                        rowData[1] = row.parentId;
                    }
                    row.cells.forEach((t) => {
                        const rowIndex = t._index + rowIndexOffset;
                        const rowColSpan = t.colspan ? (t.colspan) as number : 1;
                        rowData[rowIndex] = t._getExportText();
                        // push empty strings to remaining rows in colSpan
                        if (rowColSpan > 1) {
                            for (let spanCount = 1; spanCount < rowColSpan; spanCount++) {
                                rowData[rowIndex + spanCount] = '';
                            }
                        }
                    });
                    rowsData.push(rowData);
                }
            }
            return rowsData;
        };

        if (tableComponent && tableComponent.rowComponentsQueryList) {
            tableComponent.rowComponentsQueryList.forEach((t) => {
                tableData = tableData.concat(rowDataExtractorFn(t));
            });
        }

        return {
            headers: headers.filter((t) => !t.hidden),
            data: tableData
        };
    }
}

