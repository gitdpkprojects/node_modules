import { COLOR } from '../constants/color.constants';

export class ColorHelper {
    /**
     * Utility function to tint a hex color
     * takes percent between -1 an 1, negative numbers will darken, positive lighten
     *
     * Beware, here be dragons, tread lightly...
     *
     * Source can be found here: https://stackoverflow.com/a/13542669
     *
     * (Moved from bar-chart.component.ts)
     *
     * @param color: string
     * @param percent: number
     * @param blendColor: number
     */
    static tintColor(color: string, percent: number, blendColor: string = '#FFFFFF'): string {
        if (document.body.getAttribute('theme')) {
            blendColor = '#F2F2F2';
        }
        const f = parseInt(color.slice(1), 16),
            t = parseInt(blendColor.slice(1), 16),
            // tslint:disable-next-line:no-bitwise
            R1 = f >> 16, G1 = f >> 8 & 0x00FF, B1 = f & 0x0000FF,
            // tslint:disable-next-line:no-bitwise
            R2 = t >> 16, G2 = t >> 8 & 0x00FF, B2 = t & 0x0000FF;
        return '#' + (0x1000000 + (Math.round((R2 - R1) * percent) + R1)
            * 0x10000 + (Math.round((G2 - G1) * percent) + G1)
            * 0x100 + (Math.round((B2 - B1) * percent) + B1)).toString(16).slice(1);
    }

    // Returns all brand colors in an array. Is used by ie. CUS Dashboard.
    static getBrandColors = () => COLOR.BRAND_COLORS;

    /**
     * Returns a tuple with the tinted color and base color
     * @param {number} index The current index of the loop
     * @param {Array<string>} array of color code
     * @returns {[TintedColor, BaseColor]}
     */
    static graphColorByIndex = (index: number, color: Array<string>): [TintedColor, BaseColor] => {
        let step = Math.floor(index / color.length);
        step = step === 0 ? 1 : 3;
        const tint = step === 1 ? 0.17 : 0.5;
        const baseColor = color[index % color.length];
        return [ColorHelper.tintColor(baseColor, tint), baseColor];
    }

    /**
     * Returns a tuple with the tinted color and base color
     * @param {number} index The current index of the loop
     * @param {Array<string>} array of color code
     * @returns {[TintedColor, BaseColor]}
     */
    static stackedGraphColorByIndex = (index: number, isTint: Boolean, color: Array<string>): [TintedColor, BaseColor] => {
        let step = Math.floor(index / color.length);
        step = isTint ? 1 : 3;
        const tint = step === 1 ? 0.17 : 0.5;
        const baseColor = color[index % color.length];
        return [ColorHelper.tintColor(baseColor, tint), baseColor];
    }

    /**
     * Returns colors for donut chart data items
     * @param data
     * @param colors
     */
    static donutChartColors(data: Array<any>, colors: Array<string>) {
        const allColors = [];
        let count = 0;
        const tints = Math.ceil(data.length / colors.length);
        let colorCount = 0;
        data.forEach(() => {
            let basecolor;
            if (count >= tints) {
                count = 0;
                ++colorCount;
            }
            ++count;
            basecolor = colors[colorCount];
            let color;
            if (count === 1) {
                color = basecolor;
            } else {
                color = ColorHelper.tintColor(basecolor, (count * (data.length - tints)) / 100);
            }
            allColors.push(color);
        });
        return allColors;
    }

    /**
     * Returns a tuple with the tinted color and base color
     * @param {number} index The current index of the loop
     * @returns {[TintedColor, BaseColor]}
     */
    static graphBrandColorByIndex = (index: number): [TintedColor, BaseColor] => {
        let step = Math.floor(index / COLOR.BRAND_COLORS.length);
        step = step === 0 ? 1 : 3;
        const tint = step === 1 ? 0.17 : 0.5;
        const baseColor = COLOR.BRAND_COLORS[index % COLOR.BRAND_COLORS.length];
        return [ColorHelper.tintColor(baseColor, tint), baseColor];
    }

    static rgbToHex(r: number, g: number, b: number) {
        // tslint:disable-next-line:no-bitwise
        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
    /*
    * Takes a 3 or 6-digit hex color code, and an optional 0-255 numeric alpha value
    */
    static hexToRGB(hex, alpha?) {
        if (typeof hex !== 'string' || hex[0] !== '#')  {
            return null; // or return 'transparent'
        }
        const stringValues = (hex.length === 4)
            ? [hex.slice(1, 2), hex.slice(2, 3), hex.slice(3, 4)].map(n => `${n}${n}`)
            : [hex.slice(1, 3), hex.slice(3, 5), hex.slice(5, 7)];
        const intValues = stringValues.map(n => parseInt(n, 16));

        return (typeof alpha === 'number')
        ? `rgba(${intValues.join(', ')}, ${alpha})`
        : `rgb(${intValues.join(', ')})`;
  }
    static rgb2hex(rgb) {
        rgb = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
        function hex(x) {
            // tslint:disable-next-line:radix
            return ('0' + parseInt(x).toString(16)).slice(-2);
        }
        return '#' + hex(rgb[1]) + hex(rgb[2]) + hex(rgb[3]);
    }
    static rgbString2Number(rgb: string): {r: number, g: number, b: number, a: number} {
        const rgbObject = rgb.match(/[0-9.]{1,3}/g).map(x => parseFloat(x.trim()));
        return { 'r': rgbObject[0], 'g': rgbObject[1], 'b': rgbObject[2], a: rgbObject[3] };
    }
    static setRgba(rgb: string, opacity: number) {
        const rgbObject = this._rgbToObject(rgb);
        return `rgba(${rgbObject[0]},${rgbObject[1]},${rgbObject[2]},${ opacity})`;
    }
    private static _rgbToObject(rgb: string) {
        return rgb.match(/[0-9.]{1,3}/g).map(x => parseFloat(x.trim()));
    }
}

type TintedColor = string;
type BaseColor = string;
