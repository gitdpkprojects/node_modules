import {
    ElementRef, Renderer2, HostBinding, AfterViewInit, OnDestroy, Input, OnChanges,
    SimpleChanges
} from '@angular/core';
import { KEYBOARD } from '../constants/keyboard.constants';

export class KeyboardAccessibility implements AfterViewInit, OnDestroy, OnChanges {
    disabledHtmlClass: string = 'disabled';
    selectedHtmlClass: string = 'selected';
    selectableQuerySelector: string;

    private _selectedElementIndex: number = -1;
    private _isFirstKeyboardChange: boolean = true;
    private _cachedElements: Array<HTMLElement>;
    private _elementHoverListeners: Array<Function> = [];
    private _keydownListener: Function;
    @Input() @HostBinding('tabindex') tabIndex: number = 0;
    @Input() listenForKeyDown: boolean = true;

    constructor(public renderer: Renderer2, public elementRef: ElementRef) {
    }

    /**
     * Override this method with your method to check if the user can navigate
     * @returns {boolean}
     */
    canNavigate(): boolean {
        return true;
    }

    /**
     * Override this method with your method to return the ElementRef which holds the elements
     * @returns {ElementRef}
     */
    getSelectableItemContainer(): ElementRef {
        return this.elementRef;
    }

    /**
     * Override this method to have control on which element that receives key down events
     * @returns {ElementRef}
     */
    keyDownElement(): ElementRef {
        return this.elementRef;
    }

    /**
     * Override this method to open your menu
     * @param event
     */
    openContextMenu(event) {
        console.log(event);
        throw(`You need to override the openContextMenu to open a context menu!`);
    }

    /**
     * Override this method to close your menu
     * @param event
     */
    closeContextMenu(event) {
        console.log(event);
        throw(`You need to override the closeContextMenu to close a context menu!`);
    }

    /**
     * Override this method to make a custom event for what happens when the user tabs
     * @param event
     */
    triggerTab(event): void {
        this.closeContextMenu(event);
    }

    /**
     * Override this method to make a custom event for what happens when the user presses space/enter
     * @param event
     */
    triggerSpaceAndEnter(event): void {
        if (this.canNavigate()) {
            this.clickOnSelectedItem(event);
        } else {
            this.openContextMenu(event);
        }
        event.stopPropagation();
        event.preventDefault();
    }

    /**
     * This method should be ran immediately after your menu is opened.
     */
    contextMenuOpened(): void {
        this.selectableElements();
    }

    /**
     * This method should be ran immediately after your menu is closed.
     */
    contextMenuClosed(): void {
        this.setElementIndex(-1);
        Array.from(this.selectableElements()).forEach((_element) => {
            this.renderer.removeClass(_element, this.selectedHtmlClass);
        });
        this.unregisterHoverListeners();
    }

    ngAfterViewInit(): void {
        this.registerKeyListener();
    }

    ngOnChanges(changes: SimpleChanges): void {
        if (changes['listenForKeyDown'] && !changes['listenForKeyDown'].firstChange) {
            if (this.listenForKeyDown) {
                this.registerKeyListener();
            } else if (typeof(this._keydownListener) !== 'undefined') {
                this._keydownListener();
            }
        }
    }

    /**
     * Listen to key presses
     */
    registerKeyListener(): void {
        if (this.listenForKeyDown) {
            this._keydownListener = this.renderer.listen(this.keyDownElement().nativeElement, 'keydown', (event: KeyboardEvent) => {
                this.onKeyDown(event);
            });
        }
    }

    /**
     * When a key is pressed
     * @param event
     */
    onKeyDown(event: KeyboardEvent): void {
        switch (event.keyCode) {
            case KEYBOARD.DOWN_ARROW:
            case KEYBOARD.UP_ARROW:
                this.changeIndex(event);
                break;
            case KEYBOARD.ENTER:
            case KEYBOARD.SPACE:
                this.triggerSpaceAndEnter(event);
                break;
            case KEYBOARD.TAB:
                this.triggerTab(event);
                break;
            case KEYBOARD.ESCAPE:
                this.closeContextMenu(event);
        }
    }

    /**
     * Fake a click on the current selected item.
     * If no element is selected, close the menu.
     * @param event
     */
    clickOnSelectedItem(event: KeyboardEvent): void {
        if (this._selectedElementIndex > -1) {
            const element = this.getSelectedElement();
            element.click();
        } else {
            this.closeContextMenu(event);
        }
    }

    /**
     * Gets a collection of the current selectable elements, as well as registers and unregisters hover listeners
     * @returns {Array<HTMLElement>}
     */
    selectableElements(): Array<HTMLElement> {
        if (!this.selectableQuerySelector) {
            throw('You need to define a Query Selector - selectableQuerySelector');
        }
        const selectableElements = this.getSelectableItemContainer().nativeElement.querySelectorAll(
            `${this.selectableQuerySelector}:not(.${this.disabledHtmlClass})`
        );

        if (selectableElements !== this._cachedElements) {
            this.unregisterHoverListeners();
            this.registerHoverListeners(selectableElements);
        }

        return selectableElements;
    }

    /**
     * Registers a hover listeners for every selectable element
     * @param elements
     */
    registerHoverListeners(elements: Array<HTMLElement>): void {
        Array.from(elements).forEach((element) => {
            this._elementHoverListeners.push(this.renderer.listen(element, 'mouseover', (event) => {
                for (let index = 0; index < elements.length; index++) {
                    if (elements[index] === event.target || elements[index].contains(event.target)) {
                        this.setElementIndex(index);
                    }
                }
                this.setSelectedElementClass();
            }));
        });
    }

    /**
     * Unregisters all hover listeners
     */
    unregisterHoverListeners(): void {
        this._elementHoverListeners.forEach((listener: Function) => {
            listener();
        });
        this._cachedElements = [];
        this._elementHoverListeners = [];
    }

    /**
     * Changes current select element.
     * @param event
     * @param goDown
     */
    changeIndex(event: KeyboardEvent, goDown: boolean = event.keyCode === KEYBOARD.DOWN_ARROW): void {
        const selectableElements = this.selectableElements();
        if (this.canNavigate() && selectableElements.length > 0) {
            if (goDown) {
                if ((this._isFirstKeyboardChange === true) ||
                    (this._selectedElementIndex + 1) > selectableElements.length - 1) {
                    this.setElementIndex(0);
                    this._isFirstKeyboardChange = false;
                } else {
                    this._selectedElementIndex++;
                }
            } else {
                if ((this._isFirstKeyboardChange === true) ||
                    (this._selectedElementIndex - 1) < 0) {
                    this.setElementIndex(selectableElements.length - 1);
                    this._isFirstKeyboardChange = false;
                } else {
                    this._selectedElementIndex--;
                }
            }
        }
        event.stopPropagation();
        event.preventDefault();
        this.setSelectedElementClass();
    }

    /**
     * Returns the current selected element among the selectableElements()
     * @returns {HTMLElement}
     */
    getSelectedElement(): HTMLElement {
        return this.selectableElements()[this._selectedElementIndex];
    }

    setElementIndex(index: number): void {
        this._selectedElementIndex = index;
    }

    /**
     * Sets the selected class to the current selected element.
     */
    setSelectedElementClass(): void {
        Array.from(this.selectableElements()).forEach((_element) => {
            this.renderer.removeClass(_element, this.selectedHtmlClass);
        });
        const element = this.getSelectedElement();

        if (element) {
            this.renderer.addClass(element, this.selectedHtmlClass);
        }
    }

    ngOnDestroy(): void {
        // unlisten the keydownListener
        if (typeof(this._keydownListener) !== 'undefined') {
            this._keydownListener();
        }
    }
}
