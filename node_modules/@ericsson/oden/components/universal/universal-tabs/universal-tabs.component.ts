import {
    AfterViewInit,
    ChangeDetectorRef,
    Component,
    ComponentFactoryResolver,
    ComponentRef,
    HostBinding,
    OnDestroy, Renderer2,
    ViewChild,
    ViewContainerRef,
    ViewEncapsulation,
    ElementRef,
    OnInit,
    Inject
} from '@angular/core';
import { UniversalTab } from '../../../core/models/universal-tab.model';
import { UniversalService } from '../universal.service';
import { Subscription } from 'rxjs/Subscription';
import { DOMHelper } from '../../../core/helpers/dom.helper';
import { InkBarComponent } from '../../tabs/ink-bar/inkbar.component';
import { trigger, transition, style, animate } from '@angular/animations';
import { SIZING } from '../../../core/constants/sizing.constants';
import { DOCUMENT } from '@angular/common';

@Component({
    selector: 'cui-universal-tabs',
    templateUrl: 'universal-tabs.component.html',
    styleUrls: ['universal-tabs.component.scss'],
    encapsulation: ViewEncapsulation.None,
    animations: [
        trigger('listAnimation', [
            transition('closed => open', [
                style({ opacity: 0, marginTop: '-24px' }),
                animate('500ms ease-in', style({ opacity: 1, marginTop: 0 }))
            ]),
            transition('open => closed', [
                style({ opacity: 1, marginTop: 0 }),
                animate('250ms ease-out', style({ opacity: 0, marginTop: '-24px' }))
            ])
        ])
    ]
})
export class UniversalTabsComponent implements OnInit, AfterViewInit, OnDestroy {
    @HostBinding('class.cui-universal-tabs') addClass: boolean = true;
    @ViewChild('target', { read: ViewContainerRef }) target;
    @ViewChild('inkBar') inkBar: InkBarComponent;
    @ViewChild('tabElementRef') tabElementRef: ElementRef;
    tabs: Array<UniversalTab> = [];
    windowWidth: number;
    stickyStart: number;
    iconOpacity: number = 1;
    current: number = 0;
    open: string;
    private _overlayElement: HTMLElement;
    private _subscriptions: Array<Subscription> = [];
    private _currentComponent: ComponentRef<any>;
    private _timeout;
    private onResizeBind: EventListener = this.onResize.bind(this);
    private onScrollBind: EventListener = this.onScroll.bind(this);
    set subscriptions(sub) { this._subscriptions.push(sub); }

    constructor(
        private _universalService: UniversalService,
        private _renderer: Renderer2,
        private componentFactoryResolver: ComponentFactoryResolver,
        private changeDetector: ChangeDetectorRef,
        @Inject(DOCUMENT) private _document: HTMLDocument
    ) {}

    ngOnInit(): void {
        this.setWindowWidth();
    }

    ngAfterViewInit() {
        this.subscriptions = this._universalService.onTabsChange.subscribe(tabs => {
            this.tabs = tabs;
            this.renderTab(this.current);
            setTimeout(() => {
                this.updateInkBar();
            }, 10);
        });
        setTimeout(() => {
            this.updateInkBar();
        }, 10);
        this.subscriptions = this._universalService.onShowUniversalOverlay.subscribe((obj) => {
            this.open = 'open';
            if (obj.identifier) {
                const tabIndex = this.tabs.findIndex((_tab: UniversalTab) => _tab.identifier === obj.identifier);
                this.renderTab(tabIndex);
            }
            setTimeout(() => {
                this.updateInkBar();
            }, 10);
        });
        this.subscriptions = this._universalService.onHideUniversalOverlay.subscribe(() => {
            this.open = 'closed';
            this.updateInkBar(true);
        });
        this.changeDetector.detectChanges();

        this._overlayElement = this._document.getElementById(this._universalService.rootID);
        this._overlayElement.addEventListener('scroll', this.onScrollBind);
        window.addEventListener('resize', this.onResizeBind);
        window.addEventListener('keydown', e => this.bindKeybordShortcuts(e));
    }

    bindKeybordShortcuts(e: KeyboardEvent) {
        if (e.altKey) {
            if (e.key) {
                const matchingTab = this.tabs.filter(tab => tab.hotkey === e.key);
                if (matchingTab.length > 0) {
                    if (matchingTab[0].order === this._universalService.tabCurrentlyOpen.order && this._universalService.isOpen) {
                        this._universalService.hideUniversalOverlay();
                    } else if (matchingTab[0]) {
                        this._universalService.showUniversalOverlay();
                        this._document.getElementById(matchingTab[0].id).click();
                    }
                }
            }
        }
    }

    onResize(): void {
        setTimeout(() => {
            this.setWindowWidth();
            this.setIconOpacity();
            this.updateInkBar();
        }, 10);
    }

    onScroll(): void {
        this.setIconOpacity();
    }

    /**
     * setStickyStart
     * Set stickyStart based on window width.
     */
    setStickyStart(): void {
        if (this.windowWidth >= SIZING.LARGE_SCREEN) {
            this.stickyStart = 118;
        } else if (this.windowWidth >= SIZING.MEDIUM_SCREEN) {
            this.stickyStart = 91;
        } else {
            this.stickyStart = 86;
        }
    }

    /**
     * setWindowWidth
     * Set windowWidth to the width of users window.
     */
    setWindowWidth(): void {
        this.windowWidth = window.innerWidth
            || this._document.documentElement.clientWidth
            || this._document.body.clientWidth;
        this.setStickyStart();
    }

    /**
     * setIconOpacity
     * Set opacity for icons based on scroll position.
     */
    setIconOpacity(): void {
        if (this.windowWidth >= SIZING.LARGE_SCREEN && this._overlayElement) {
            this.iconOpacity = (1 - this._overlayElement.scrollTop / 100);
        } else {
            this.iconOpacity = 1;
        }
    }

    renderTab(index: number) {
        if (this._currentComponent && index === this.current) {
            return;
        }
        const root = this._document.querySelector('#' + this._universalService.rootID);
        clearTimeout(this._timeout);
        DOMHelper.scrollTo(root, 0, 200).then(() => {
            this._renderer.addClass(root, 'overflow-x-hidden');

            let direction;
            if (this._currentComponent) {
                direction = this._currentComponent.instance.tabIndex > index ? 'moveRight' : 'moveLeft';
                this._currentComponent.instance.animationDirection = direction;
                setTimeout(() => {
                    this._currentComponent.destroy();
                });
            }

            setTimeout(() => {
                if (this.tabs[index] && !(this._currentComponent && index === this.current)) {
                    this.current = index;
                    const tab = this.tabs[index];
                    const componentFactory = this.componentFactoryResolver.resolveComponentFactory(tab.component);
                    this._currentComponent = this.target.createComponent(componentFactory);
                    this._currentComponent.instance.tabIndex = index;
                    this._currentComponent.instance.animationDirection =
                        direction === 'moveRight' ? 'moveLeft' : (!direction ? 'moveDown' : 'moveRight');
                    if (tab.inputs) {
                        Object.keys(tab.inputs).forEach((key) => {
                            this._currentComponent.instance[key] = tab.inputs[key];
                        });
                    }
                    // make sure the current component gets visible
                    if (direction) {
                        this._currentComponent.instance.visible = true;
                    }
                    tab.componentRef = this._currentComponent;
                    setTimeout(() => {
                        this.updateInkBar();
                    }, 10);
                }
                this._timeout = setTimeout(() => {
                    this._renderer.removeClass(root, 'overflow-x-hidden');
                }, 800);
                this._universalService.tabCurrentlyOpen = this.tabs[index];
            });
        });
    }

    /**
     * Tells the ink-bar to align itself to the current selected tab
     */
    updateInkBar(hide?: boolean): void {
        if (hide) {
            this._renderer.addClass(this.inkBar.elementRef.nativeElement, 'fade');
        } else {
            let shrinkPx = 0;
            if (this.windowWidth >= SIZING.LARGE_SCREEN) {
                shrinkPx = 20;
            } else if (this.windowWidth >= SIZING.MEDIUM_SCREEN) {
                shrinkPx = 10;
            } else {
                shrinkPx = 0;
            }
            setTimeout(() => {
                this._renderer.removeClass(this.inkBar.elementRef.nativeElement, 'fade');
            }, 100);
            const activeTabElement = this._document.querySelector('li.universal-tab-link.active');
            if (activeTabElement) {
                this.inkBar.alignToElement(<HTMLElement>activeTabElement, shrinkPx);
            } else {
                this.inkBar.alignToElement(<HTMLElement>this._document.querySelector('li.universal-tab-link'), shrinkPx);
            }
        }
    }

    ngOnDestroy(): void {
        window.removeEventListener('resize', this.onResizeBind);
        this._overlayElement.removeEventListener('scroll', this.onScrollBind);
        window.removeEventListener('keydown', e => this.bindKeybordShortcuts(<KeyboardEvent>e));
    }
}
