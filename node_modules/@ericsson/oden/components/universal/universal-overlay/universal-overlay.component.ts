import {
    Component,
    ComponentRef,
    HostBinding, HostListener,
    Input,
    Renderer2,
    ViewEncapsulation,
    AfterViewInit,
    OnDestroy,
    ViewChild,
    ElementRef,
    NgZone
} from '@angular/core';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../../core/classes/subscription.decorator';
import { BackdropComponent } from '../../backdrop/backdrop.component';
import { BackdropService } from '../../backdrop/backdrop.service';
import { OverlayService } from '../../overlay/overlay.service';
import { UniversalService } from '../universal.service';
import { ParentRoute } from '../../main-menu/main-menu-route.model';
import { MainMenuService } from '../../main-menu';
import { AppHeaderService } from '../../app-header';
import { ProfileModel } from '../../../core/models';
import { NavigationEnd, Router } from '@angular/router';
import AnimationHelper from '../../../core/helpers/animation.helper';
import { ApplicationStorageHelper } from '../../../core/helpers/application-storage.helper';
import { KEYBOARD } from '../../../core/constants/keyboard.constants';
import { TranslateService } from '@ngx-translate/core';

@Component({
    selector: 'cui-universal-overlay',
    templateUrl: 'universal-overlay.component.html',
    styleUrls: ['universal-overlay.component.scss'],
    encapsulation: ViewEncapsulation.None
})
@UnSub()
export class UniversalOverlayComponent implements AfterViewInit, OnDestroy {
    @HostBinding('attr.id') id: string;
    @HostBinding('attr.theme') theme: string = 'dark';
    @HostBinding('class.cui-universal-overlay') @HostBinding('class.scroll-area')
    @HostBinding('class.tabview-wrapper') addClass: boolean = true;
    @HostBinding('class.open') visible: boolean = false;
    @HostBinding('class.no-close') noClose: boolean = false;
    @HostBinding('style.z-index') zIndex: number;
    @Input() profile: ProfileModel;
    @Input() appTitle: string;
    @ViewChild('closeElementRef') closeElementRef: ElementRef;
    @ViewChild('logoutElementRef') logoutElementRef: ElementRef;
    @ViewChild('headerElementRef') headerElementRef: ElementRef;
    private _overlayElement: HTMLElement;
    private onScrollBind: EventListener = this.onScroll.bind(this);
    private onResizeBind: EventListener = this.onResize.bind(this);
    closeLabelVisibility = { opacity: 1, visibility: 'visible' };
    logoutLabelVisibility = { opacity: 1, visibility: 'visible' };

    get currentApp(): string {
        return this._appHeaderService.title;
    }

    get hasLogoutListener(): boolean {
        return this._universalService.onLogout.observers.length > 0;
    }

    get profileName(): string {
        return this.profile ? this.profile.name : '';
    }

    get isLicensed(): boolean {
        return this._universalService.isLicensed;
    }

    private _backdrop: ComponentRef<BackdropComponent>;
    private _closeTriggerClasses: Array<string> =
        ['cui-universal-overlay', 'cui-container', 'row', 'cui-column', 'col-xs', 'col-sm', 'col-md', 'col-lg', 'tabs'];
    private _subscriptions: Array<Subscription> = [];
    set subscriptions(sub) { this._subscriptions.push(sub); }

    constructor(private _backDropService: BackdropService,
                private _overlayService: OverlayService,
                private _universalService: UniversalService,
                private _appHeaderService: AppHeaderService,
                private _mainMenuService: MainMenuService,
                private _renderer: Renderer2,
                private _router: Router,
                private _translate: TranslateService,
                private _ngZone: NgZone) {
        this.id = this._universalService.rootID;
        this.subscriptions = this._universalService.onShowUniversalOverlay.subscribe((obj) => {
            this.noClose = obj.noClose;
            this.openUniversalOverlay();
        });
        this._subscriptions.push(this._universalService.onHideUniversalOverlay.subscribe(() => {
            this.closeUniversalOverlay();
        }));
        this._subscriptions.push(this._mainMenuService.onChange.subscribe((routes: Array<ParentRoute>) => {
            this.setLegacyRoutes(routes);
        }));
        this.setLegacyRoutes(this._mainMenuService.getRoutes());
        this._subscriptions.push(this._router.events.subscribe(event => {
            if (this.visible) {
                setTimeout(() => {
                    if (event instanceof NavigationEnd) {
                        this._universalService.hideUniversalOverlay();
                    }
                }, this._universalService.minLoadDisplay);
            }
        }));

        // Set label visibility after translation service has loaded or language changes
        this._translate.stream(['ODEN.COMMON.CLOSE']).subscribe(() => {
            this.setLabelVisibility();
        });
        this._subscriptions.push(this._translate.onTranslationChange.subscribe(() => {
            this._ngZone.onStable.first().subscribe(() => {
                this.setLabelVisibility();
            });
        }));
        this._subscriptions.push(this._translate.onLangChange.subscribe(() => {
            this._ngZone.onStable.first().subscribe(() => {
                this.setLabelVisibility();
            });
        }));
    }

    ngAfterViewInit() {
        this._overlayElement = document.getElementById(this._universalService.rootID);
        this._overlayElement.addEventListener('scroll', this.onScrollBind);
        window.addEventListener('resize', this.onResizeBind);
    }

    ngOnDestroy(): void {
        this._overlayElement.removeEventListener('scroll', this.onScrollBind);
        window.removeEventListener('resize', this.onResizeBind);
    }

    /**
     * Listening if the user hits Esc key to close the Universal layer
     * or Enter/Space key to "click" focused element
     * or Tab key (will add glow style to focused elements)
     */
    @HostListener('document:keydown', ['$event'])
    bindKeyboardShortcuts(e: KeyboardEvent) {
        setTimeout(() => {
            const universalOverlayElement = document.querySelector('.cui-universal-overlay');
            if (universalOverlayElement) {
                if (e.keyCode === KEYBOARD.ESCAPE && this.currentApp) {
                    this._universalService.hideUniversalOverlay();
                } else if (e.keyCode === KEYBOARD.ENTER || e.keyCode === KEYBOARD.SPACE) {
                    const focusedElement = <HTMLElement>universalOverlayElement.querySelector(':focus');
                    if (focusedElement) {
                        focusedElement.click();
                    }
                } else if (e.keyCode === KEYBOARD.TAB) {
                    const focusedElement = <HTMLElement>universalOverlayElement.querySelector(':focus');
                    Array.from(universalOverlayElement.querySelectorAll('.tabbed')).forEach((tabbedElement) => {
                        this._renderer.removeClass(tabbedElement, 'tabbed');
                    });
                    if (focusedElement) {
                        this._renderer.addClass(focusedElement, 'tabbed');
                    }
                }
            }
        });
    }

    @HostListener('document:click', ['$event'])
    bindClick(event: Event): void {
        const universalOverlayElement = document.querySelector('.cui-universal-overlay');
        if (universalOverlayElement) {
            Array.from(universalOverlayElement.querySelectorAll('.tabbed')).forEach((tabbedElement) => {
                if (tabbedElement !== event.target) {
                    this._renderer.removeClass(tabbedElement, 'tabbed');
                }
            });
        }
    }

    /**
     * When clicking the close link in the upper left corner
     */
    onClose(): void {
        this._universalService.hideUniversalOverlay();
    }

    onLogout(): void {
        this._universalService.logout();
    }

    /**
     * Closes the menu, triggers on _universalService.onHideUniversalOverlay
     */
    closeUniversalOverlay() {
        this.visible = false;
        this._universalService.closeOverlay(this._renderer);
        this.closeBackDrop();
    }

    /**
     * Opens the menu
     */
    openUniversalOverlay() {
        this.visible = true;
        this.zIndex = this._overlayService.highestZindex + 1;
        this.setLabelVisibility();
        this.displayBackDrop();
    }

    clickToClose(evt: MouseEvent): void {
        const universalOverlayElement = document.querySelector('.cui-universal-overlay');
        if (universalOverlayElement) {
            const htmlTarget = <HTMLElement>evt.target;
            const hasCloseTriggerClass: boolean = this._closeTriggerClasses.some((closeTriggerClass: string) => {
                return htmlTarget.classList.contains(closeTriggerClass);
            });

            const isAnyOverlayComponentOpen: boolean = !!universalOverlayElement.querySelector('.overlay-component');
            if (hasCloseTriggerClass && !isAnyOverlayComponentOpen) {
                this._universalService.hideUniversalOverlay();
            }
        }
    }

    displayBackDrop(): void {
        const rootOverlay = this._overlayService.containerRef.element.nativeElement;
        // Set blur class on all siblings of Universal Overlay
        const universalOverlay = document.querySelector('#' + this._universalService.rootID);
        if (universalOverlay) {
            Array.from(universalOverlay.parentElement.children).forEach((child) => {
                // add blur class to non-empty children of the universalOverlays parent (#wrapper)
                if (child.children.length && child.id !== this._universalService.rootID && child !== rootOverlay) {
                    this._renderer.addClass(child, 'universal-overlay-blur');
                }
            });

            const universalTabs = <Array<HTMLElement>>Array.from(document.querySelectorAll('.cui-universal-tabs .button-content'));
            AnimationHelper.animateItemsStepped(this._renderer, universalTabs);

            // animate things
            setTimeout(() => {
                if (this._universalService.tabCurrentlyOpen && this._universalService.tabCurrentlyOpen.componentRef) {
                    this._universalService.tabCurrentlyOpen.componentRef.instance.visible = true;
                }
                const top = document.querySelector('.cui-universal-overlay .top');
                if (top) {
                    this._renderer.removeClass(top, 'before-visible');
                }
            }, 40);
        }

        if (!this._backdrop) {
            this._backdrop = this._backDropService.create();
        }
        this._backdrop.instance.onClose.subscribe(() => this._universalService.hideUniversalOverlay());
    }

    /**
     * Removes the backdrop instance
     */
    closeBackDrop(): void {
        if (this._backdrop) {
            this._backdrop.instance.onClose.unsubscribe();
            this._backDropService.remove(this._backdrop);
            this._backdrop = null;
        }
    }

    setLegacyRoutes(routes: Array<ParentRoute>) {
        if (!routes) {
            return;
        }
        this._universalService.clearApps();
        let category = '';
        const categoryList = [];
        routes.forEach((route) => {
            if (route) {
                category = route.label;
                categoryList.push(category); // save category(area) in the same order as per IA
                if (route.children instanceof Array && route.children.length) {
                    route.children.forEach((child) => {
                        this._universalService.addApp({
                            id: child.label,
                            name: child.label,
                            category: category,
                            favorite: false,
                            order: child.priority,
                            path: child.path,
                            newWindow: child.newWindow,
                            routes: child.children.map(grandchild => ({
                                label: grandchild.label,
                                path: grandchild.path,
                                order: grandchild.priority,
                                newWindow: grandchild.newWindow,
                                externalApp: grandchild.externalApp,
                                favorite: ApplicationStorageHelper
                                    .getLocalStorage('ODEN.UNIVERSAL_LAYER.APPS.ITEMS.FAVORITES.' + grandchild.path) === 'true'
                            }))
                        });
                    });
                }
            }
        });
        this._universalService.categoryList = categoryList;
    }

    /**
     * Set label visibility
     * @returns void
     */
    setLabelVisibility(): void {
        if (this._overlayElement) {
            const closeCurrentSize = this.closeElementRef.nativeElement.getBoundingClientRect();
            const logoutCurrentSize = this.logoutElementRef.nativeElement.getBoundingClientRect();
            const headerCurrentSize = this.headerElementRef.nativeElement.getBoundingClientRect();

            // Collision handling
            const headerOverlapClose = !(closeCurrentSize.right < headerCurrentSize.left ||
                closeCurrentSize.left > headerCurrentSize.right ||
                closeCurrentSize.bottom < headerCurrentSize.top ||
                closeCurrentSize.top > headerCurrentSize.bottom);

            const headerOverlapLogout = !(logoutCurrentSize.right < headerCurrentSize.left ||
                logoutCurrentSize.left > headerCurrentSize.right ||
                logoutCurrentSize.bottom < headerCurrentSize.top ||
                logoutCurrentSize.top > headerCurrentSize.bottom);

            // Set opacity based on scroll position
            const opacity  = (1 - this._overlayElement.scrollTop / 40);
            this.closeLabelVisibility.opacity = this.logoutLabelVisibility.opacity = (opacity >= 0 ) ? opacity : 0;

            // Set visibility based on overlapping and opacity
            this.closeLabelVisibility.visibility =
                (headerOverlapClose || this.closeLabelVisibility.opacity <= 0 ) ? 'hidden' : 'visible';
            this.logoutLabelVisibility.visibility =
                (headerOverlapLogout || this.logoutLabelVisibility.opacity <= 0 ) ? 'hidden' : 'visible';
        }
    }

    onScroll(): void {
        this.setLabelVisibility();
    }

    onResize(): void {
        this.setLabelVisibility();
    }
}
