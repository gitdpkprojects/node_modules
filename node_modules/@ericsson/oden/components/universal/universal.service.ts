import { EventEmitter, Injectable, Renderer2 } from '@angular/core';
import { IUniversalApp } from '../../core/interfaces/universal-app.interface';
import { UniversalTab } from '../../core/models/universal-tab.model';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import { Observable } from 'rxjs/Observable';
import {ApplicationStorageHelper} from '../../core/helpers/application-storage.helper';
import { map } from 'rxjs/operators';

export type Tabs = Array<UniversalTab>;
export type Apps = Array<IUniversalApp>;
export type Strings = Array<string>;

export const sortByOrder = (a: {order: number}, b: {order: number}) => a.order - b.order;
export const mergeAndSort = (subject: BehaviorSubject<Array<any>>, item: { order: number }) => {
    return subject.getValue().concat([item]).sort(sortByOrder);
};
export const merge = (subject: BehaviorSubject<Array<any>>, item: any) => {
    return subject.getValue().concat([item]);
};

@Injectable()
export class UniversalService {
    private _rootID: string = 'universal-overlay';
    public appFilterString: string = '';
    public showOnlyFavorites: boolean = false;
    public favoritesEnabled: BehaviorSubject<boolean> = new BehaviorSubject(false);
    private _tabCurrentlyOpen: UniversalTab;

    private _tabs: BehaviorSubject<Tabs> = new BehaviorSubject([]);
    public onTabsChange: Observable<Tabs> = this._tabs.asObservable();

    private _favorites: BehaviorSubject<Strings> = new BehaviorSubject([]);
    public onFavoritesChange: Observable<Strings> = this._favorites.asObservable();

    private _apps: BehaviorSubject<Apps> = new BehaviorSubject([]);

    public onAppsChange: Observable<Apps> = Observable
        .combineLatest(this._apps,  this._favorites)
        .pipe(map(([apps, favorites]: [Apps, Strings]) => {
            return apps.map((app: IUniversalApp) => {
                app.routes = app.routes.map(route => {
                    route.favorite = favorites.indexOf(route.path) > -1;
                    return route;
                });
                if (app.routes && app.routes.length > 0) {
                    app.favorite = app.routes.filter((item) => item.favorite).length === app.routes.length;
                } else {
                    app.favorite = favorites.indexOf(app.name) > -1;
                }
                return app;
            });
        }));

    private _categories: BehaviorSubject<Strings> = new BehaviorSubject([]);
    public onCategoriesChange: Observable<Strings> = this._categories.asObservable();

    public onFilterApps: EventEmitter<any> = new EventEmitter<any>();
    public onShowUniversalOverlay: EventEmitter<any> = new EventEmitter<any>();
    public onHideUniversalOverlay: EventEmitter<null> = new EventEmitter<null>();

    public onLogout: EventEmitter<null> = new EventEmitter<null>();
    public onCloseUniversalOverlay: EventEmitter<null> = new EventEmitter<null>();
    public minLoadDisplay: number = 300;
    public isOpen: boolean = false;

    public showSitemap: boolean
        = ApplicationStorageHelper.getLocalStorage('ODEN.UNIVERSAL_LAYER.APPS.SHOW_SITEMAP') === 'true';

    public isLicensed: boolean = false;
    /**
     * @returns {Tabs}
     */
    public get tabs() {
        return this._tabs.getValue();
    }

    get tabCurrentlyOpen(): UniversalTab {
        return this._tabCurrentlyOpen;
    }

    set tabCurrentlyOpen(tab: UniversalTab) {
        this._tabCurrentlyOpen = tab;
    }

    /**
     * Adds a tab to our tab collection, sorted
     * Emits onTabsChange
     * @param {UniversalTab} tab
     */
    addTab(tab: UniversalTab) {
        const next = mergeAndSort(this._tabs, tab);
        this._tabs.next(next);
    }

    /**
     * Replaces tab collection, sorted
     * Emits onTabsChange
     * @param {UniversalTab} tab
     */
    setTabs(tabs: Array<UniversalTab>) {
        const newTabs = tabs.concat().sort(sortByOrder);
        this._tabs.next(newTabs);
    }

    /**
     * Adds an app to our app collection, sorted
     * Emits onAppsChange
     * @param {IUniversalApp} app
     */
    addApp(app: IUniversalApp) {
        app.routes.sort(sortByOrder);
        const next = merge(this._apps, app);
        this._apps.next(next);
    }

    /**
     * Removes all apps and routes from our collection
     */
    clearApps(): void {
        this._apps.next([]);
    }
    /**
     * Sets favorite collection to the supplied array
     * Use on application init or user login
     * @param {Array<string>} favorites
     */
    setFavorites(favorites: Array<string>) {
        this._favorites.next(favorites);
    }
    /**
     * Sets the license status
     * @param {boolean} status
     */
    setLicensed(status: boolean) {
        this.isLicensed = status;
    }

    /**
     * Removes or adds the specified favorite to our collection
     * Emits onFavoritesChange
     * @param {string} favorite
     */
    toggleFavorite(favorite: string) {
        const next = this._favorites.getValue();
        const index = next.indexOf(favorite);
        if (index > -1) {
            next.splice(index, 1);
        } else {
            next.push(favorite);
        }
        this._favorites.next(next);
    }

    /**
     * Removes or adds all the sub applications under the application.
     * @param appId
     * @param isFavorite
     */
    toggleAppFavorites(appId: string, isFavorite: boolean) {
        const currentApp = this._apps.getValue().find((item) => item.id === appId);
        const appRoutes = currentApp ? currentApp.routes.map((item) => item.path) : [];
        let currentFavs = this.getFavorites();

        if (appRoutes && appRoutes.length > 0) {
            if (isFavorite) {
                currentFavs = Array.from(new Set(currentFavs.concat(appRoutes)));
            } else {
                currentFavs = currentFavs.filter((item) => appRoutes.indexOf(item) < 0);
            }
            this._favorites.next(currentFavs);
        } else {
            this.toggleFavorite(appId);
        }
    }

    /**
     * Returns the current favorite items
     */
    getFavorites() {
        return this._favorites.getValue();
    }

    /**
     * Shows the universal overlay
     */
    showUniversalOverlay(identifier?: any, canBeClosed: boolean = true): void {
        if (!this.isOpen) {
            this.isOpen = true;
            Promise.resolve().then(() => this.onShowUniversalOverlay.emit({identifier: identifier, noClose: !canBeClosed}));
        }
    }

    triggerFilterApps(): void {
        this.onFilterApps.emit();
    }

    /**
     * Hides the universal overlay
     */
    hideUniversalOverlay(): void {
        this.isOpen = false;
        this.onHideUniversalOverlay.emit();
    }

    logout(): void {
        this.onLogout.emit();
    }

    /**
     * Happens when closing the Universal Overlay - reset styles and classes to initial state etc
     * @param {Renderer2} renderer
     */
    closeOverlay(renderer: Renderer2): void {
        this.onCloseUniversalOverlay.emit();
        this.isOpen = false;

        // Unset blur class on all siblings
        Array.from(document.querySelectorAll('.universal-overlay-blur')).forEach((child) => {
            renderer.removeClass(child, 'universal-overlay-blur');
        });

        // hide current tab
        if (this._tabCurrentlyOpen && this._tabCurrentlyOpen.componentRef) {
            this._tabCurrentlyOpen.componentRef.instance.visible = false;
        }

        // Re-add class 'before-visible' on universal overlay top
        const top = document.querySelector('.cui-universal-overlay .top');
        if (top) {
            renderer.addClass(top, 'before-visible');
        }
    }

    /**
     * Get the id of the root HTML element for Universal layer
     *
     * @returns {string}
     */
    get rootID(): string {
        return this._rootID;
    }

    /**
     * Set category list (area)
     */
    set categoryList(category: Array<any>) {
        this._categories.next(category);
    }
}
