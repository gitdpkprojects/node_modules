import {
    Component, Input, Output, HostBinding, ViewEncapsulation, EventEmitter, Renderer2, ElementRef,
    ViewChild, ComponentRef, OnDestroy, ChangeDetectorRef, ViewRef, OnChanges, SimpleChanges
} from '@angular/core';
import { ActionItem } from '../../core/models/action-item.model';
import { Divider } from '../../core/models/divider.model';
import { OverlayHelperService } from '../overlay/overlay-helper.service';
import { KeyboardAccessibility } from '../../core/classes/keyboard-accessibility';
import { BackdropComponent } from '../backdrop/backdrop.component';
import { IOverlayable } from '../overlay/overlayable.interface';
import { OVERLAY_CONTEXT } from '../overlay/overlay.constants';
import { BackdropService } from '../backdrop/backdrop.service';
import { UnSub } from '../../core/classes';
import { Subscription } from 'rxjs/Subscription';

@Component({
    selector: 'cui-action-menu',
    templateUrl: 'action-menu.component.html',
    styleUrls: ['action-menu.component.scss'],
    encapsulation: ViewEncapsulation.None
})
@UnSub()
export class ActionMenuComponent extends KeyboardAccessibility implements OnDestroy, IOverlayable, OnChanges {
    @Input() actions: Array<ActionItem | Divider> = [];
    @Input() open: boolean = false;
    @Input() useOverlay: boolean = true;
    @Input() icon: string = 'more';
    @Input() tabIndex: number = -1;
    @Output() onActionClick: EventEmitter<ActionItem> = new EventEmitter<ActionItem>();
    @Output() onDisplay: EventEmitter<null> = new EventEmitter<null>();
    @HostBinding('class.cui-action-menu') addClass: boolean = true;

    selectableQuerySelector = '.cui-action-menu-item';
    @ViewChild('actionMenuList') overlayElement: ElementRef;
    @ViewChild('moreOptions') moreOptionsElement: ElementRef;

    globalListener: Function;

    openedInOverlay: boolean = false;
    backdrop: ComponentRef<BackdropComponent>;
    _right: string = '-30px';
    _focusedAction: ActionItem;
    _focused: boolean = false;
    _mousedown: boolean = false;
    _hasBelowTheLineActions: boolean = false;
    private _subscriptions: Array<Subscription> = [];

    constructor(renderer: Renderer2,
        elementRef: ElementRef,
        private _backdropService: BackdropService,
        public overlayHelperService: OverlayHelperService,
        private _changeDetector: ChangeDetectorRef) {
        super(renderer, elementRef);
    }

    ngOnDestroy(): void {
        this.removeFromOverlay();
        this.closeMenu();
    }

    ngOnChanges(changes: SimpleChanges): void {
        if (changes.actions) {
            this._hasBelowTheLineActions = this.hasBelowTheLineActions();
        }
    }

    /**
     * Call this when ever you want to remove the overlayElement.
     */
    removeFromOverlay(): void {
        if (this.overlayElement && this.openedInOverlay) {
            this.overlayHelperService.removeFromOverlay(this);
        }
        this.deleteBackdrop();
    }

    isAboveTheLineAction(item: ActionItem | Divider): boolean {
        return item instanceof ActionItem && !!item.aboveTheLine;
    }

    isBelowTheLineAction(item: ActionItem | Divider): boolean {
        return !this.isAboveTheLineAction(item);
    }

    hasBelowTheLineActions(): boolean {
        return (this.actions || []).some(action => this.isBelowTheLineAction(action));
    }

    /**
     * Call this function after you have set the elementRef and overlayElement
     */
    openInOverlay(): void {
        this.overlayHelperService.appendToOverlay(this, OVERLAY_CONTEXT.ROOT);
    }
    /**
     * Dispatches the clicked action
     * @param action
     */
    actionClick(action: ActionItem): void {
        event.stopPropagation();
        this._focused = false;
        this._mousedown = false;
        if (action.disabled) {
            return;
        }
        this.onActionClick.emit(action);
        this.closeMenu();
    }

    /**
     * Overrides KeyboardAccessibility
     * @returns {boolean}
     */
    canNavigate(): boolean {
        return this.open;
    }

    /**
    * Overrides KeyboardAccessibility
     * @returns {ElementRef}
     */
    getSelectableItemContainer(): ElementRef {
        return this.overlayElement;
    }

    /**
    * Overrides KeyboardAccessibility
     */
    openContextMenu() {
        if (this._focused && this._focusedAction) {
            this.actionClick(this._focusedAction);
        } else {
            this.openMenu();
        }
    }

    /**
     * Overrides KeyboardAccessibility
     */
    closeContextMenu() {
        this.closeMenu();
    }

    /**
     * Toggles the open state of the menu
     */
    toggleMenu(): void {
        event.stopPropagation();
        this._mousedown = false;
        if (this.open) {
            this.closeMenu();
        } else {
            this.openMenu();
        }
    }

    /**
     * Opens the menu
     */
    openMenu(): void {
        const actions: Array<ActionItem | Divider> = this.actions || [];
        const aboveTheLineActions = actions.reduce((acc, action) => this.isAboveTheLineAction(action) ? acc + 1 : acc, 0);
        // Used to be hard-coded to -30px in scss but now needs to be calculated as -30px - 32px * number of actions above the line.
        // This is to adjust the menu to thr right side of the action menu component.
        this._right = aboveTheLineActions ? `${-30 - 32 * aboveTheLineActions}px` : '-30px';

        if (this.useOverlay) {
            this.createBackdrop();
        }
        if (this.useOverlay && !this.openedInOverlay) {
            this.openInOverlay();
        } else if (this.openedInOverlay) {
            this.overlayHelperService.setNewZIndex(this, OVERLAY_CONTEXT.ROOT);
        }

        if (!this.useOverlay) {
            this._setClickListener();
        }

        this.onDisplay.emit();
        this.open = true;
        this.overlayHelperService.setPosition(this);
        this._detectChanges();
        this.contextMenuOpened();
    }

    /**
     * Closes the menu
     */
    closeMenu(): void {
        if (this.open) {
            this.open = false;
            if (typeof (this.globalListener) === 'function') {
                this.globalListener(); // Unbinds to any events
            }
            this.contextMenuClosed();
            this.deleteBackdrop();
            this._detectChanges();
        }
    }

    /**
     * Creates a backdrop unless there is one already
     */
    createBackdrop(): void {
        if (!this.backdrop) {
            this.backdrop = this._backdropService.create(false);
            this._subscriptions.push(this.backdrop.instance.onClose.subscribe(() => this.closeMenu()));
        }
    }

    /**
     * Deletes the backdrop if there is one
     */
    deleteBackdrop(): void {
        if (this.backdrop) {
            this._backdropService.remove(this.backdrop);
            this._subscriptions = [];
            this.backdrop = null;
        }
    }

    /**
     * Focused action
     */
    onFocus(action: ActionItem): void {
        this._focusedAction = action;
        this._focused = !this._mousedown;
    }

    /**
     * Blur
     */
    onBlur(): void {
        this._focusedAction = undefined;
        this._focused = false;
    }

    /**
     * Mouse down
     */
    onMousedown(): void {
        this._focused = false;
        // Set _isMouseDown to true when a user puts the mouse down ("clicks") a button.
        // Set it to false after 100 milliseconds.
        // We only *show* the focus style when focus has come to the button via the keyboard.
        // Without doing this, the button continues to look :active after clicking.
        // @see http://marcysutton.com/button-focus-hell/
        this._mousedown = true;
        setTimeout(() => { this._mousedown = false; }, 100);
    }

    /**
     * Sets a global listener for clicks events that closes the menu if triggered. Only used if useOverlay = false
     * @private
     */
    private _setClickListener(): void {
        this.globalListener = this.renderer.listen('document', 'click', (event) => {
            if (!this.elementRef.nativeElement.contains(event.target)) {
                this.closeMenu();
            }
        });
    }

    private _detectChanges() {
        if (!(<ViewRef>this._changeDetector).destroyed) {
            this._changeDetector.detectChanges();
        }
    }
}
