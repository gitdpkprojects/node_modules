import { ArrayHelper } from '../../core/helpers/array.helper';
import { DOMHelper } from '../../core/helpers/dom.helper';
import {
    Component,
    ElementRef,
    EventEmitter,
    HostBinding,
    HostListener,
    Input,
    OnChanges,
    Output,
    Renderer2,
    SimpleChanges,
    TemplateRef,
    ViewChild,
    ViewEncapsulation,
    OnInit,
    OnDestroy
} from '@angular/core';
import { DROP_STATE } from '../../core/constants/drop-state.constant';
import { TactileBlockItem } from '../../core/models/tactile-block-item.model';
import { DropzonePayload } from '../../core/interfaces/dropzone.payload.interface';
import { ActionItem } from '../../core/models/action-item.model';
import { LibraryAction } from '../../core/models/library-action.model';
import { DropzoneService } from './dropzone.service';
import * as _ from 'lodash';
import { UUID } from '../../core/helpers/uuid.class';
import { MOUSE_BUTTON } from '../../core/constants/mouse-button.constant';
import { LAYOUT } from '../../core/constants/layouts.constants';
import { ButtonActionItem } from '../../core/models/button-action-item.model';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../core/classes';
import { ILibraryItemReceiver } from '../../core/interfaces/library-item-receiver.interface';
import { LibraryItemReceiverService } from '../library/library-item-receiver.service';

const PLACEHOLDER_WIDTH = 80;
@Component({
    selector: 'cui-dropzone',
    templateUrl: 'dropzone.component.html',
    styleUrls: ['dropzone.component.scss'],
    encapsulation: ViewEncapsulation.None
})
@UnSub()
export class DropzoneComponent implements OnInit, OnChanges, OnDestroy, ILibraryItemReceiver {
    @HostBinding('class.cui-dropzone') addClass: boolean = true;
    @HostBinding('class.just-dropped') just_dropped: boolean = false;
    @HostBinding('class.dropzone-is-empty') get isEmpty(): boolean {
        return this.items.length === 0;
    }
    @HostBinding('class.fully-populated') get isFullyPopulated(): boolean {
        return this.state === DROP_STATE.FULLY_POPULATED;
    }
    @HostBinding('class.available') get isAvilable(): boolean {
        return this.state === DROP_STATE.AVAILABLE;
    }
    @HostBinding('class.engaged') get isEngaged(): boolean {
        return this.state === DROP_STATE.ENGAGED;
    }
    @HostBinding('class.vertical') get hasVerticalLayout(): boolean {
        return this.layout === LAYOUT.VERTICAL;
    }
    @HostBinding('class.read-only') get isReadOnly(): boolean {
        return this.state === DROP_STATE.READ_ONLY;
    }
    @ViewChild('defaultTemplate', { read: TemplateRef }) defaultTemplate;
    @Input() name: string;
    @Input() acceptingTypes: Array<string> = [];
    @Input() maxItems: number;
    @Input() sortable: boolean = true;
    @Input() placeholderTitle: string;
    @Input() placeholderDescription: string;
    @Input() layout: LAYOUT = LAYOUT.HORIZONTAL;
    @Input() placeholderActions: Array<ButtonActionItem> = [];
    @Input() enablePositionDisplay: boolean = false;
    @Input() readOnly: boolean = false;
    @Output() onPlaceholderActionClick: EventEmitter<ButtonActionItem> = new EventEmitter<ButtonActionItem>();
    @Output() itemsChange = new EventEmitter();
    @Output() onMenuActionClick: EventEmitter<LibraryAction> = new EventEmitter<LibraryAction>();
    @Output() onButtonActionClick: EventEmitter<LibraryAction> = new EventEmitter<LibraryAction>();
    @Output() onItemAdded: EventEmitter<TactileBlockItem> = new EventEmitter<TactileBlockItem>();
    @Output() onChange: EventEmitter<Array<TactileBlockItem>> = new EventEmitter<Array<TactileBlockItem>>();
    @Output() onTactileBlocksSelected: EventEmitter<Array<TactileBlockItem>> = new EventEmitter<Array<TactileBlockItem>>();
    @Output() onItemsOrderChange: EventEmitter<Array<TactileBlockItem>> = new EventEmitter<Array<TactileBlockItem>>();
    private _state: DROP_STATE;
    // Tactile items
    private _items: Array<TactileBlockItem> = [];
    // Cloned tactile items
    private _clones: Array<TactileBlockItem> = [];
    // Temporary array of items which is used before and after drag and drop.
    private _temporaryTactileItems: Array<TactileBlockItem> = [];
    private _draggingTactileBlock: TactileBlockItem;
    private _template: TemplateRef<any>;
    private _subscriptions: Array<Subscription> = [];

    constructor(public dropzoneService: DropzoneService,
        public elementRef: ElementRef,
        public renderer: Renderer2,
        private _libraryItemReceiverService: LibraryItemReceiverService) {
        // Listener for when user start dragging tactile item
        this._subscriptions.push(dropzoneService.onDraggingTactileItem.subscribe((tactileItem: TactileBlockItem) => {

            this.just_dropped = false;
            this._draggingTactileBlock = tactileItem;
            this.dropzoneService.acceptedElement = this._getAcceptedElementRef();
            if (this.items.length === this.maxItems && this._indexOfTactileItem(tactileItem) === -1) {
                this.createClones();
                this.state = DROP_STATE.FULLY_POPULATED;
            } else if (this.readOnly) {
                this.state = DROP_STATE.READ_ONLY;
            } else if (tactileItem && this.isTactileItemAccepted(tactileItem)) {
                // Set fixed height during drag so the blocks don't grow longer when they're changing widths
                if (this._draggingTactileBlock) {
                    [].forEach.call(this.elementRef.nativeElement.querySelectorAll('.drop-area > *'), function (el) {
                        el.style.height = DOMHelper.getOuterHeight(el) + 'px';
                    });
                }
                if (this._indexOfTactileItem(tactileItem) > -1) {
                    this.state = DROP_STATE.ENGAGED;
                } else {
                    this.createClones();
                    this.state = DROP_STATE.AVAILABLE;
                }
            } else {
                this.state = DROP_STATE.IDLE;
            }
        }));
        this._subscriptions.push(this.onChange.subscribe(() => {
            this.createClones();
        }));
        // Listener for when tactile blocks added to dropzone
        this._subscriptions.push(dropzoneService.onAddTactileBlockToDropzone.subscribe((payload: DropzonePayload) => {
            if (!payload.tactileItem || this.readOnly) {
                // Bail if we don't have an item in the payload
                return;
            }
            if (payload.dropzone.nativeElement === this.elementRef.nativeElement &&
                this._indexOfTactileItem(payload.tactileItem) === -1 &&
                this.items.length < this.maxItems) {
                // Adds tactileItem to dropzone if the dropzone is the target
                // dropzone in payload and the item does not exist in dropzone
                this.items.push(payload.tactileItem);
                this._temporaryTactileItems = this.items.concat();
                this.onChange.emit(this.items);
                this.onItemAdded.emit(payload.tactileItem);
                this.state = DROP_STATE.IDLE;
                if (this.items.length === this.maxItems) {
                    this.state = DROP_STATE.FULLY_POPULATED;
                }
            } else if (payload.dropzone.nativeElement !== this.elementRef.nativeElement &&
                this._indexOfTactileItem(payload.tactileItem) !== -1) {
                // Removes tactileItem if the tactileItem exist in dropzone
                // but target dropzone in the payload is another one
                this.items.splice(this._indexOfTactileItem(payload.tactileItem), 1);
                this.onChange.emit(this.items);
                this._temporaryTactileItems = this.items.concat();
            } else if (this._clones.length !== this.items.length) {
                // if something has changed, emit it
                setTimeout(() => {
                    this.onChange.emit(this.items);
                }, 0);
            }
        }));
        // Emits tactile block once selected
        this._subscriptions.push(this.dropzoneService.onTactileBlocksSelected.subscribe(items => {
            this.onTactileBlocksSelected.emit(items);
        }));
        if (this.readOnly) {
            this.state = DROP_STATE.READ_ONLY;
        }
    }
    ngOnInit(): void {
        this._libraryItemReceiverService.registerReceiver(this);
    }
    /**
     * Makes sure that items array don't get larger than maxItems
     * @param changes
     */
    ngOnChanges(changes: SimpleChanges): void {

        // Check if max amount of items reached and remove all items added after maxLength index
        if (this.items.length > this.maxItems) {
            this.items.splice(this.maxItems, this.items.length - 1);
            this.state = DROP_STATE.FULLY_POPULATED;
        } else if (this.state === DROP_STATE.FULLY_POPULATED && this.items.length < this.maxItems) {
            this.state = DROP_STATE.IDLE;
        }
        if (this.items.length === this.maxItems) {
            this.state = DROP_STATE.FULLY_POPULATED;
        }
        if (this.readOnly) {
            this.state = DROP_STATE.READ_ONLY;
        }
        if (changes['items'] && (changes['items'].previousValue &&
            changes['items'].currentValue.length !== changes['items'].previousValue.length)) {
            this.onChange.emit(changes['items'].currentValue);
        }
    }
    ngOnDestroy(): void {
        this._libraryItemReceiverService.deregisterReceiver(this);
    }
    @Input()
    get items() {
        return this._items;
    }
    get clones() {
        return this._clones;
    }
    set items(val) {
        this._items = val;
        this.createClones();
        this.itemsChange.emit(this._items);
    }
    @Input()
    set template(template: TemplateRef<any>) {
        this._template = template;
    }
    get template(): TemplateRef<any> {
        return this._template || this.defaultTemplate;
    }
    /**
     * Sets state of dropzone
     * @param state
     */
    set state(state: DROP_STATE) {
        this._state = state;
        switch (state) {
            case DROP_STATE.AVAILABLE:
                this.dropzoneService.acceptedElement = null;
                break;
            case DROP_STATE.ENGAGED:
                this.createItem(this._draggingTactileBlock);
                break;
        }
    }
    /**
     * Returns current state of dropzone
     * @return {DROP_STATE}
     */
    get state(): DROP_STATE {
        return this._state;
    }

    /**
     * Gets and applies the same width, height, top, left styling to the clone as the original has
     * @param item
     * @returns {any}
     */
    getStyles(item: TactileBlockItem): any {
        if (item) {
            const dropzoneOffset = this.elementRef.nativeElement.getBoundingClientRect();
            const blockItem = this.elementRef.nativeElement.querySelector(`.drop-area #${item.id}`);
            if (!blockItem) {
                return {
                    width: this.getBlockWidth(item)
                };
            }
            const dropArea = blockItem.parentElement;
            const offset = dropArea.getBoundingClientRect();
            return {
                display: dropArea.classList.contains('target') ? 'none' : 'block',
                width: window.getComputedStyle(dropArea).width,
                height: window.getComputedStyle(dropArea).height,
                top: `${offset.top - dropzoneOffset.top}px`,
                left: `${offset.left - dropzoneOffset.left}px`
            };
        }
    }

    /**
     * Returns the index of an item in items array
     * @param item {TacktileBlockItem}
     */
    getIndexOfItem(item: TactileBlockItem) {
        return this.items.map(i => i.id).indexOf(item.id);
    }

    /**
     * Creates the clones and applies new IDs to all tactile items to ensure they get unique IDs (needed for blocks
     * that can be dropped multiple times to the dropzone)
     * @returns {Promise<null>}
     */
    createClones(): Promise<null> {
        return new Promise((resolve) => {
            this._clones = _.cloneDeep(this.items);
            // set unique IDs
            this.items.forEach((item) => {
                const newId = 'tactile-' + UUID.create();
                const clones = this._clones.filter((i) => i.id === item.id);
                if (clones) {
                    clones.forEach((c) => {
                        c.id = newId;
                    });
                }
                item.id = newId;
            });
            resolve();
        });
    }
    /**
     * Rearrange order of TactileBlockItems when user drag new TactileBlockItem above others.
     * @param event
     */
    @HostListener('mousemove', ['$event'])
    mouseMove(event: MouseEvent): void {
        // Do not continue execute code if the used isn't dragging an element.
        if (event.buttons !== 1) {
            return;
        }
        if (this.state === DROP_STATE.AVAILABLE) {
            this.state = DROP_STATE.ENGAGED;
        }
        if (this.state === DROP_STATE.ENGAGED) {
            const tactileItemIndex: number = this._indexOfTactileItem(this._draggingTactileBlock);
            // Checks if current item hasn't yet been rendered in dropzone
            if (tactileItemIndex !== -1) {
                if (this.items.length > 1 && this.elementRef.nativeElement.querySelector(
                    '.drop-area.target:not(.copy) > *')) {
                    // Set temporary fixed height to new tactile-block (same height as the ones already in dropzone)
                    // if it's a horizontal layout and we're not moving inside dropzone (= clone exists)
                    if (this.layout === LAYOUT.HORIZONTAL && !document.querySelector('#clone-' + this._draggingTactileBlock.id)) {
                        const height = DOMHelper.getLowestElement(
                            this.elementRef.nativeElement.querySelectorAll('.drop-area:not(.target):not(.copy) > *')
                        );
                        this.renderer.setStyle(
                            this.elementRef.nativeElement.querySelector('.drop-area.target:not(.copy) > *'),
                            'height', height + 'px');
                    }
                    this.renderer.addClass(
                        this.elementRef.nativeElement.querySelector('.drop-area.target:not(.copy)'), 'visible');
                }
                if (this.layout === LAYOUT.VERTICAL
                    && this.elementRef.nativeElement.querySelector('.drop-area.target:not(.copy) > *')
                    && !document.querySelector('#clone-' + this._draggingTactileBlock.id)) {
                    this.renderer.setStyle(
                        this.elementRef.nativeElement.querySelector('.drop-area.target:not(.copy) > *'),
                        'height', '75px'
                    );
                }
                // are we hovering a drop-area (else it's the <cui-dropzone> itself)
                if ((<HTMLElement>event.target).classList.contains('drop-area')) {
                    const newTactileItemIndex: number = DOMHelper.getNodeIndex(<HTMLElement>event.target);
                    // Makes sure the that the element is removed from the DOM (lag issue)
                    if (newTactileItemIndex < this.items.length) {
                        // Are we dragging over the left or top side of the block
                        if (this.isOverlapping(event)) {
                            // Unless we're hovering the placeholder itself -> rearrange!
                            if (!(<HTMLElement>event.target).classList.contains('target') && tactileItemIndex > newTactileItemIndex) {
                                ArrayHelper.move(this.items, tactileItemIndex, newTactileItemIndex);
                            }
                        } else {
                            // We are dragging over the right or bottom side of the block
                            // Unless we're hovering the placeholder itself -> rearrange!
                            if (!(<HTMLElement>event.target).classList.contains('target') && tactileItemIndex < newTactileItemIndex) {
                                ArrayHelper.move(this.items, tactileItemIndex, newTactileItemIndex);
                            }
                        }
                    }
                } else {
                    let newTactileItemIndex: number = 0;
                    // Move to back of dropzone
                    if (this.isOverlapping(event)) {
                        ArrayHelper.move(this.items, tactileItemIndex, newTactileItemIndex);
                    } else {
                        // Move to front of dropzone
                        newTactileItemIndex = this.items.length - 1;
                        ArrayHelper.move(this.items, tactileItemIndex, newTactileItemIndex);
                    }
                }
                this.dropzoneService.acceptedElement = this._getAcceptedElementRef();
            }
        }
    }
    /**
     * Check if the dragging element overlaps next tactile element in the array.
     * @param {MouseEvent} event
     * @return {boolean}
     */
    isOverlapping(event: MouseEvent) {
        if (this.layout === LAYOUT.HORIZONTAL) {
            return event.layerX <= (DOMHelper.getOuterWidth(event.target) / 2);
        } else {
            return event.layerY <= (DOMHelper.getOuterHeight(event.target) / 2);
        }
    }
    /**
     * Sets state to AVAILABLE when mouse leaves the dropzone and state is ENGAGED
     */
    @HostListener('mouseleave', ['$event'])
    mouseLeave(event: MouseEvent): void {
        // Do not continue execute code if the used isn't dragging an element.
        if (event.buttons !== 1) {
            return;
        }
        if (this.state === DROP_STATE.ENGAGED) {
            // remove the drop-area.target to trigger a smooth animation
            const target = this.elementRef.nativeElement.querySelector('.drop-area.target:not(.copy)');
            if (target && this.getCurrentlyDraggedElement() && this.getCurrentlyDraggedElement().classList.contains('library-block')) {
                target.remove();
            }
            this.state = DROP_STATE.AVAILABLE;
            this.resetItems();
        }
    }
    /**
     * Add draggable to drop zone when user releases (left) mouse button.
     * @param event
     */
    @HostListener('document:mouseup', ['$event'])
    mouseUp(event: MouseEvent): void {
        if (event.button === MOUSE_BUTTON.LEFT && this.state === DROP_STATE.ENGAGED) {
            this.restoreHeights();
            this.just_dropped = true;
            this.acceptItem();
        }
    }
    /**
     * Restore all tactile blocks to their natural height.
     */
    restoreHeights(): void {
        // Restore all tactile blocks to their natural height
        const targets: Array<HTMLElement> = this.elementRef.nativeElement.querySelectorAll('.drop-area > *');
        targets.forEach(item => this.renderer.removeStyle(item, 'height'));
    }
    /**
     * Returns the block width in px depending of how many blocks in dropzone.
     * @return {string}
     */
    getBlockWidth(tactileItem: TactileBlockItem): string {
        if (this.layout === LAYOUT.HORIZONTAL) {
            if (this.items.length > 1 && this.isCurrentlyDragging(tactileItem) && !this.just_dropped
                && this.getCurrentlyDraggedElement() && this.getCurrentlyDraggedElement().classList.contains('library-block')) {
                return `${PLACEHOLDER_WIDTH}px`;
            }
            return (100 / this.items.length) + '%';
        } else {
            return '100%';
        }
    }
    /**
     * Returns the currently dragged tactile block as an Element
     * @returns {any}
     */
    getCurrentlyDraggedElement(): Element {
        const element = document.querySelector('body > .dragging');
        if (element) {
            return element;
        }
        return null;
    }
    /**
     * Returns true if dropzone accepts currently dragging TactileBlockItem
     * @param tactileItem
     * @return {boolean}
     */
    isTactileItemAccepted(tactileItem: TactileBlockItem): boolean {
        return this.acceptingTypes.length === 0 ||
            tactileItem.type
                .filter(type => this.acceptingTypes.indexOf(type) !== -1)
                .length > 0;
    }
    /**
     * Creates a temporary TactileBlockItem in dropzone
     * @param tactileItem
     */
    createItem(tactileItem: TactileBlockItem): void {
        this._temporaryTactileItems = this.items.concat();
        const existInDropzone: boolean = this._indexOfTactileItem(tactileItem) !== -1;
        if (!existInDropzone && tactileItem) {
            this.items.push(tactileItem);
        }
    }

    /**
     * Returns false if dropzone is readonly.
     * @param {*} isDraggable
     * @returns boolean
     */
    checkIsDraggable(isDraggable): boolean {
        if (this.state === DROP_STATE.READ_ONLY) {
            return false;
        } else {
            return isDraggable;
        }

    }
    /**
     * Accepts currently dragging TactileBlockItem
     */
    acceptItem(): void {
        this.dropzoneService.addTactileBlockToDropzone(
            this.elementRef,
            this._draggingTactileBlock
        );
        // Emit event when reorder the items
        if (this.items.length === this._temporaryTactileItems.length && !_.isEqual(this.items, this._temporaryTactileItems)) {
            this.onItemsOrderChange.emit(this.items);
            this.onChange.emit(this.items);
        }
    }
    /**
     * Removes temporary TactileBlockItems.
     */
    resetItems(): void {
        this.items = this._temporaryTactileItems.concat();
    }
    /**
     * Returns true of the TactileBlockItem is the one that user currently dragging
     * @param tactileItem
     * @return {TactileBlockItem|boolean}
     */
    isCurrentlyDragging(tactileItem: TactileBlockItem): boolean {
        return this._draggingTactileBlock && tactileItem === this._draggingTactileBlock;
    }
    /**
     * Returns the index of the TactileBlockItem
     * @param tactileItem
     * @return {number}
     * @private
     */
    private _indexOfTactileItem(tactileItem: TactileBlockItem): number {
        return tactileItem ? this.items.indexOf(tactileItem) : -1;
    }
    /**
     * Returns the Element of the currently dragging TactileBlockItem in dropzone
     * @return {Element}
     * @private
     */
    private _getAcceptedElementRef(): Element {
        const index = this._indexOfTactileItem(this._draggingTactileBlock) + 1;
        return this.elementRef.nativeElement.querySelector(`.drop-area:not(.copy):nth-child(${index}) > *`);
    }
    /**
     * Tells if the place holder text be shown or not.
     * @return {boolean}
     */
    showPlaceholder(): boolean {
        return this.isEmpty && (this.placeholderTitle !== undefined || this.placeholderDescription !== undefined);
    }
    /**
     * Action dispatcher for onMenuActionClick
     * @param item
     * @param action
     */
    menuActionClick(item: TactileBlockItem, action: ActionItem): void {
        const libraryAction = new LibraryAction(action);
        libraryAction.item = item;
        this.onMenuActionClick.emit(libraryAction);
    }
    /**
     * Action dispatcher for onButtonActionClick
     * @param item
     * @param action
     */
    buttonActionClick(item: TactileBlockItem, action: ActionItem): void {
        const libraryAction = new LibraryAction(action);
        libraryAction.item = item;
        this.onButtonActionClick.emit(libraryAction);
    }
    /**
     * Emits the onActionClick EventEmitter
     * @param action
     */
    placeholderActionClicked(action: ButtonActionItem): void {
        this.onPlaceholderActionClick.emit(action);
    }

    showDrawer() {
        this.dropzoneService.showDrawer();
    }

    get hasReachedMaxItems(): boolean {
        return this.maxItems && (this.items || []).length >= this.maxItems;
    }

    canReceiveLibraryItem(tactileItem: TactileBlockItem): boolean {
        return !this.isReadOnly &&
            !this.isFullyPopulated &&
            !this.hasReachedMaxItems &&
            !tactileItem.draggableItem &&
            this.isTactileItemAccepted(tactileItem);
    }

    onReceiveLibraryItem(tactileItem: TactileBlockItem): void {
        this.dropzoneService.onAddTactileBlockToDropzone.emit({
            dropzone: this.elementRef,
            tactileItem: tactileItem
        });
        setTimeout(() => {
            const id = this.items[this.items.length - 1].id;
            const element = this.elementRef.nativeElement.querySelector(`.items #${id}`);
            if (element) {
                element.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }, 300);
    }
}
