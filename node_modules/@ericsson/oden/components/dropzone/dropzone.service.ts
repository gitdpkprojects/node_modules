import { ElementRef, EventEmitter, Injectable } from '@angular/core';
import { TactileBlockItem } from '../../core/models/tactile-block-item.model';
import { DropzonePayload } from '../../core/interfaces/dropzone.payload.interface';
import { DragAndDropService } from '../drag-and-drop/drag-and-drop.service';
import { TactileBlockService } from '../tactile-block/tactile-block.service';
import { LibraryService } from '../../core/services/library.service';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../core/classes';
import { DrawerService } from '../drawer';

@Injectable()
@UnSub()
/* @deprecated Use the new DragAndDropService instead */
export class DropzoneService {
    public onDraggingTactileItem: EventEmitter<TactileBlockItem> = new EventEmitter<TactileBlockItem>();
    // @deprecated Use TactileBlockService instead
    public onTactileBlocksSelected: EventEmitter<Array<TactileBlockItem>> = new EventEmitter<Array<TactileBlockItem>>();
    public onAddTactileBlockToDropzone: EventEmitter<DropzonePayload> = new EventEmitter<DropzonePayload>();
    private _draggingElementRef: ElementRef;
    private _tactileItem: TactileBlockItem;
    private _selectedTactileBlocks: Array<TactileBlockItem> = [];
    private _acceptedElement: Element;
    private _subscription: Subscription;

    constructor(
        private _dragAndDropService: DragAndDropService,
        private _tactileBlockService: TactileBlockService,
        private _libraryService: LibraryService,
        private _drawerService: DrawerService
    ) {
        // Listen to the new TactileBlockService
        this._subscription = this._tactileBlockService.onTactileBlocksSelected
            .subscribe(data => {
                this.onTactileBlocksSelected.emit(data);
            });
    }

    /**
     * Sets currently dragging TactileBlockItem
     * @param element
     * @param tactileItem
     */
    setDraggable(element: ElementRef, tactileItem?: TactileBlockItem): void {
        this._draggingElementRef = element;
        this.acceptedElement = null;
        const item = tactileItem;
        this._tactileItem = item;
        this.onDraggingTactileItem.emit(item);
    }

    /**
     * Return the currently dragging TactileBlockItem.
     * @return {TactileBlockItem}
     */
    getDraggingTactileBlockItem(): TactileBlockItem {
        return this._tactileItem;
    }

    /**
     * Sets the current destination element for TackTileBlockItem
     * @param element
     */
    set acceptedElement(element: Element) {
        this._acceptedElement = element;
    }

    /**
     * Returns the current destination element for TactileBlockItem.
     * @return {ElementRef}
     */
    get acceptedElement(): Element {
        return this._acceptedElement;
    }

    /**
     * Accepts the currently dragging TactileBlockItem
     * @param dropzone
     * @param tactileItem
     */
    addTactileBlockToDropzone(dropzone: ElementRef, tactileItem: TactileBlockItem): void {
        const droppable = this._dragAndDropService.findDroppableByDeprecatedHackDoNotUse(dropzone);
        if (droppable) {
            droppable.onDrop.emit(tactileItem);
        }
        this._libraryService.added$.emit(tactileItem);
        this.onAddTactileBlockToDropzone.emit({
            dropzone: dropzone,
            tactileItem: tactileItem
        });
    }

    /**
     * Sets a tactile block as selected and emits onTactileBlockSelected emitter.
     * @param {TactileBlockItem} items
     * @deprecated Use TactileBlockService instead
     */
    set selectedTactileBlocks(items: Array<TactileBlockItem>) {
        this._selectedTactileBlocks = items;
        this.onTactileBlocksSelected.emit(items);
    }

    /**
     * Returns currently selected tactile block or null
     * @return {TactileBlockItem}
     * @deprecated Use TactileBlockService instead
     */
    get selectedTactileBlocks(): Array<TactileBlockItem> {
        return this._selectedTactileBlocks;
    }

    showDrawer() {
        this._drawerService.toggleDrawer$.next(true);
    }
}
