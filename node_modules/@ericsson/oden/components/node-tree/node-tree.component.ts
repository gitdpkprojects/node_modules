import {
    AfterViewInit,
    Component,
    ElementRef,
    EventEmitter,
    HostBinding,
    Input,
    OnChanges,
    OnInit,
    Output,
    Renderer2,
    SimpleChanges,
    ViewChild,
    ViewEncapsulation
} from '@angular/core';
import { INode, Nodes } from '../../core/interfaces/node.interface';
import { KeyboardAccessibility } from '../../core/classes/keyboard-accessibility';
import { NodeTreeService } from './node-tree.service';
import { KEYBOARD } from '../../core/constants/keyboard.constants';
import { PROMO_NODE_TREE } from './node-tree.constants';

@Component({
    selector: 'cui-node-tree',
    templateUrl: './node-tree.component.html',
    styleUrls: ['./node-tree.component.scss'],
    providers: [NodeTreeService],
    encapsulation: ViewEncapsulation.None
})

export class NodeTreeComponent extends KeyboardAccessibility implements OnInit, OnChanges, AfterViewInit {
    @HostBinding('class.cui-node-tree') addClass: boolean = true;
    @HostBinding('class.open') addOpen: boolean = true;
    @ViewChild('nodesElement') nodesElement: ElementRef;
    @Input() nodes: Nodes = [];
    @Input() showFilter: boolean = true;
    @Input() openLevels: number = 0;
    @Input() promoNodeTree: boolean = false;
    @Input() hideOpener: boolean = false;
    @Input() minWidth: number = PROMO_NODE_TREE.MIN_WIDTH;
    @Output() onNodeSelect: EventEmitter<INode> = new EventEmitter<INode>();
    @Output() onReady: EventEmitter<NodeTreeService> = new EventEmitter<NodeTreeService>();
    // TODO: @Output() onNodeExpand: EventEmitter<INode> = new EventEmitter<INode>();

    selectableQuerySelector = 'ul.open > li';
    disabledHtmlClass = 'is-hidden';
    constructor(private _nodeTreeService: NodeTreeService,
                renderer: Renderer2, elementRef: ElementRef) {
        super(renderer, elementRef);
    }

    /**
     * Override from Keyboardacc.
     * @return {ElementRef}
     */
    getSelectableItemContainer() {
        return this.nodesElement;
    }

    /**
     * Override this method to have control on which element that receives key down events
     * @returns {ElementRef}
     */
    keyDownElement(): ElementRef {
        return this.nodesElement;
    }

    /**
     * Make the first element in list selected if none is selected, then focus on the selected element.
     * Triggers when user focuses on the first <ul> (usually by tab)
     * @param event
     */
    onFocus(event: KeyboardEvent): void {
        if (!this.getSelectedElement()) {
            this.setElementIndex(-1);
            this.changeIndex(event, true);
        }
        const selectedElement = this.getSelectedElement();
        if (selectedElement) {
            selectedElement.focus();
        }
    }

    ngAfterViewInit(): void {
        super.ngAfterViewInit();
        // TODO: Find a way to avoid this.
        setTimeout(() => { this.onReady.emit(this._nodeTreeService); }, 10);

        this.renderer.listen( this.keyDownElement().nativeElement, 'keydown', (event: KeyboardEvent) => {
            if (event.keyCode === KEYBOARD.LEFT_ARROW) {
                this.collapseSelectedNode();
            }
            if (event.keyCode === KEYBOARD.RIGHT_ARROW) {
                this.expandSelectedNode();
            }
        });
    }

    /**
     * Override KeyboardAccessibility
     * @param event
     */
    openContextMenu(): void {
        return;
    }

    /**
     * Override KeyboardAccessibility
     * @param event
     */
    closeContextMenu(): void {
        return;
    }

    /**
     * Arrow left listener. Always collapses node
     */
    collapseSelectedNode(): void {
        const selectedElement = this.getSelectedElement();
        if (typeof(selectedElement) !== 'undefined') {
            this._nodeTreeService.collapseNodeViaElement(selectedElement);
        }
    }

    /**
     * Arrow right listener. Always expands node
     */
    expandSelectedNode(): void {
        const selectedElement = this.getSelectedElement();
        if (typeof(selectedElement) !== 'undefined') {
            this._nodeTreeService.expandNodeViaElement(selectedElement);
        }
    }

    ngOnInit(): void {
        this._nodeTreeService.initializeNodes(this.nodes, this.openLevels);
        this._nodeTreeService.onNodeSelect = this.onNodeSelect;
    }

    ngOnChanges(changes: SimpleChanges): void {
        if (changes['nodes']) {
            this._nodeTreeService.nodes = this.nodes;
        }
    }

    /**
     * Override from KeyboardAccessibility.
     * Gets element
     * @param event
     */
    clickOnSelectedItem(): void {
        const selectedElement = this.getSelectedElement();
        if (typeof(selectedElement) !== 'undefined') {
            this._nodeTreeService.toggleActivateNodeViaElement(selectedElement);
        }
    }

    /**
     * Listens for filter input changes and asks nodeTreeService to filter
     * @param str
     */
    onFilterInput(str: string): void {
        this.setElementIndex(-1);
        this.setSelectedElementClass();
        this._nodeTreeService.filterNodes(str);
    }
}
