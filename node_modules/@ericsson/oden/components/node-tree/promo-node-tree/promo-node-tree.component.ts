import {
    Input,
    OnChanges,
    OnInit,
    Component,
    SimpleChanges,
    HostBinding,
    ViewEncapsulation,
    ElementRef,
    NgZone,
    AfterViewInit,
    ChangeDetectorRef,
    ViewChild
} from '@angular/core';
import { INode, Nodes } from '../../../core/interfaces/node.interface';
import { UnSub } from '../../../core/classes/subscription.decorator';
import { PromoNodeTreeService } from './promo-node-tree.service';
import { Subscription } from 'rxjs';
import { PROMO_NODE_TREE } from '../node-tree.constants';

@Component({
    selector: 'cui-promo-node-tree',
    templateUrl: './promo-node-tree.component.html',
    styleUrls: ['./promo-node-tree.component.scss'],
    providers: [PromoNodeTreeService],
    encapsulation: ViewEncapsulation.None
})
@UnSub()
export class PromoNodeTreeComponent implements OnInit, OnChanges, AfterViewInit {
    @Input() nodes: Nodes = [];
    @Input() hideOpener: boolean = false;
    @Input() minWidth: number = PROMO_NODE_TREE.MIN_WIDTH;
    @HostBinding('class.promo-node-tree') addClass: boolean = true;
    @ViewChild('parentNodes') parentNodes: ElementRef;
    activePromoNode: INode = null;
    wrapNodes: boolean = false;
    centerAligned: boolean;
    private _subscription: Subscription;

    constructor(private _promoNodeTreeService: PromoNodeTreeService,
        private _zone: NgZone,
        private _changeDetector: ChangeDetectorRef) { }

    ngOnInit() {
        this._subscription = this._promoNodeTreeService.onPromoNodeSelect.subscribe((node: INode) => {
            if (node && node.active && node.children) {
                this.activePromoNode = node;
            } else {
                this.activePromoNode = null;
            }
        });
    }

    ngOnChanges(changes: SimpleChanges): void {
        if (changes['nodes'] && changes['nodes'].previousValue !== changes['nodes'].currentValue) {
            this._promoNodeTreeService.nodes = this.nodes;
            this.wrapNodes = !this.hasCustomComponentOrTemplate();
            this.setActiveNode();
        }
        if (changes['minWidth'] && changes['minWidth'].previousValue !== changes['minWidth'].currentValue) {
            this.minWidth = changes['minWidth'].currentValue < PROMO_NODE_TREE.MIN_WIDTH
                ? PROMO_NODE_TREE.MIN_WIDTH : changes['minWidth'].currentValue;
            setTimeout(() => {
                this.centerAligned = this.isCenterAligned();
            });
        }
    }
    /**
     * returns true if it has custom component/template
     */
    hasCustomComponentOrTemplate(): boolean {
        const templates = this.nodes.filter((node) => node.template);
        return templates.length > 0;
    }
    /**
     * sets active node and build child node tree
     */
    setActiveNode() {
        this._zone.onStable.first().subscribe(() => {
            this.activePromoNode = this._promoNodeTreeService.getActiveNode();
        });
    }
    /**
     * return true if node width is less than 100px
     */
    isCenterAligned(): boolean {
        const el: HTMLElement = this.parentNodes.nativeElement.querySelector('.parent-node-tree .cui-promo-node-view');
        if (!el || !this.wrapNodes) {
            return false;
        }
        return el.clientWidth <= PROMO_NODE_TREE.MAX_WIDTH ? true : false;
    }

    ngAfterViewInit() {
        this.centerAligned = this.isCenterAligned();
        this._changeDetector.detectChanges();
    }
}
