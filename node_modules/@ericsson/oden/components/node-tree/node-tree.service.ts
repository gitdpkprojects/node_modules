import { EventEmitter, Injectable } from '@angular/core';
import { NodeViewComponent } from './node-view/node-view.component';
import { INode, Nodes } from '../../core/interfaces/node.interface';
import { DOMHelper } from '../../core/helpers/dom.helper';
import { StringHelper } from '../../core/helpers/string.helper';
import * as _ from 'lodash';

@Injectable()
export class NodeTreeService {

    nodes: Nodes;
    openLevels: number = 0;
    nodeComponents: Map<string, NodeViewComponent> = new Map<string, NodeViewComponent>();
    multipleActiveNodes = false; // Hardcoded value until this supports multiple
    onNodeSelect: EventEmitter<INode>;
    private _nodesOpenedByFilter: Nodes = [];
    private _lastFilter: string;

    /**
     * Sets nodes and openlevel values. Checks all levels of nodes to see if anyone is activated / opened.
     * @param nodes
     * @param openLevels
     */
    initializeNodes(nodes: Nodes, openLevels: number = 0): void {
        this.openLevels = openLevels;
        nodes.forEach((node) => {
            this._initNodeAndChildren(node);
        });
    }

    /**
     * Returns the active INode if any (otherwise null)
     * @returns {any}
     */
    getActiveNode(): INode | null {
        const activeNode = Array.from(this.nodeComponents).map((n: [string, NodeViewComponent]) => {
            return n[1];
        }).filter((n: NodeViewComponent) => {
            return n.node.active || n.node.activeParent;
        }).map((n) => {
            return n.node;
        })[0];
        if (activeNode) {
            return activeNode;
        }
        return null;
    }

    /**
     * Loops through node and it's children to see if it should be opened.
     * @param node
     * @param level
     * @return {boolean}
     * @private
     */
    private _initNodeAndChildren(node: INode, level: number = 1): boolean {
        let open = node.open || node.active;
        if (node.children) {
            node.children.forEach((child) => {
                if (this._initNodeAndChildren(child, level + 1)) {
                    open = true;
                }
            });
        }
        if (open || level <= this.openLevels) {
            node.open = true;
        }
        return open;
    }
    /**
     * Adds a node component. Checks for some default values
     * @param node
     * @param level
     */
    addNodeComponent(node: INode): void {
        this.nodeComponents.set(node.uuid, node.component);
    }

    /**
     * Removes a node component.
     * @param uuid
     */
    removeNodeComponent(uuid: string): void {
        this.nodeComponents.delete(uuid);
    }

    /**
     * Toggles open for node
     * @param node
     */
    toggleOpen(node: INode): void {
        if (node.open) {
            this.collapseNode(node);
        } else {
            this.expandNode(node);
        }
    }

    /**
     * Opens node and parents
     * @param node
     */
    expandNode(node: INode): void {
        if (typeof(node.component.parentComponent) !== 'undefined') {
            this.expandNode(node.component.parentComponent.node);
        }
        _.remove(this._nodesOpenedByFilter, node);
        node.open = true;
    }

    /**
     * Closes node
     * @param node
     */
    collapseNode(node: INode): void {
        if (typeof(node.children) !== 'undefined') {
           node.children.forEach((child) => this.collapseNode(child));
        }
        node.open = false;
    }

    /**
     * Toggles active value for node
     * @param node
     */
    toggleActivate(node: INode): void {
        if (node.active || node.activeParent) {
            this.deactivateNode(node);
        } else {
            this.activateNode(node);
        }
    }

    /**
     * Activates node. Expands parents. Deactivates other nodes which might be active
     * @param node
     */
    activateNode(node: INode): void {
        node.active = true;
        if (typeof(node.component) !== 'undefined' &&
            typeof(node.component.parentComponent) !== 'undefined') {
            this.expandNode(node.component.parentComponent.node);
        }
        if (!this.multipleActiveNodes) {
            this.nodeComponents.forEach((n) => {
                if ((n.node.active || n.node.activeParent) && n.node.uuid !== node.uuid) {
                    this.deactivateNode(n.node, false);
                }
            });
        }
        this.onNodeSelect.emit(node);
    }

    /**
     * Deactives node
     * @param node
     * @param emitEvent
     */
    deactivateNode(node: INode, emitEvent = true): void {
        node.active = false;
        if (emitEvent) {
            this.onNodeSelect.emit(null);
        }
    }

    /**
     * Expands node via it's element
     * @param element
     */
    expandNodeViaElement(element: Element): void {
        const component = this.getNodeFromElement(element);
        if (component) {
            this.expandNode(component.node);
        }
    }

    /**
     * Collapses node via it's element
     * @param element
     */
    collapseNodeViaElement(element: Element): void {
        const component = this.getNodeFromElement(element);
        if (component) {
            this.collapseNode(component.node);
        }
    }

    /**
     * Toggles active state via it's element
     * @param element
     */
    toggleActivateNodeViaElement(element: Element): void {
        const component = this.getNodeFromElement(element);
        if (component) {
            this.toggleActivate(component.node);
        }
    }

    /**
     * Get node component from element.
     * @param element
     * @return {undefined|NodeViewComponent}
     */
    getNodeFromElement(element: Element): NodeViewComponent {
        return this.nodeComponents.get(element.attributes['id'].value);
    }

    /**
     * Forces a refresh of filter. Can be used after adding nodes during runtime
     */
    refreshFilter(): void {
        this.filterNodes(this._lastFilter, true);
    }

    /**
     * Filtering nodes and children
     * @param str
     * @param force
     */
    filterNodes(str: string, force = false): void {
        const newFilter = !force && str.indexOf(this._lastFilter) !== 0;
        this._lastFilter = str;
        const regex: RegExp = new RegExp(StringHelper.escapeRegExpString(str), 'gi');

        this.nodes.forEach((node: INode) => {
            this._checkNodeAndChildren(str, regex, node, newFilter);
        });
    }

    /**
     * Checks if each node recursive if it matches the filter string.
     * Opens parents if a child is shown via filter. Remembers which node was open by filter, and closes again when
     * filter is removed.
     * @param str
     * @param regex
     * @param node
     * @param newFilter
     * @return {boolean}
     * @private
     */
    private _checkNodeAndChildren(str: string, regex: RegExp, node: INode, newFilter: boolean): boolean {
        let hidden = true;
        if (node.hidden && !newFilter) {
            return true;
        }
        if (node.children) {
            node.children.forEach((child: INode) => {
                if (!this._checkNodeAndChildren(str, regex, child, newFilter) && hidden === true) {
                    hidden = false;
                    if (node.open !== true && this._nodesOpenedByFilter.indexOf(node) === -1) {
                        this._nodesOpenedByFilter.push(node);
                    }
                    node.component.noVisibleChildren = false;
                    node.open = true;
                }
            });
            if (hidden) {
                node.component.noVisibleChildren = true;
            }
        }

        if (str.length > 2) {
            if (node.label.match(regex)) {
                node.component.displayLabel = DOMHelper.highlightString(str, node.label);
                hidden = false;
            } else if (node.component.displayLabel !== node.label) {
                node.component.displayLabel = node.label;
            }
        } else {
            if (this._nodesOpenedByFilter.indexOf(node) > -1) {
                node.open = false;
                _.remove(this._nodesOpenedByFilter, node);
            }
            hidden = false;
            node.component.displayLabel = node.label;
        }

        node.hidden = hidden;
        return hidden;
    }
}
