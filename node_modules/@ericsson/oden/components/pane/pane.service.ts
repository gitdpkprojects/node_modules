import { ComponentFactoryResolver, ComponentRef, EventEmitter, Injectable, } from '@angular/core';
import { TaskPaneComponent } from './task-pane/task-pane.component';
import { OVERLAY_CONTEXT } from '../overlay/overlay.constants';
import { OverlayService } from '../overlay/overlay.service';
import { IPaneContent } from '../../core/interfaces/pane-content.interface';
import { ComponentType } from '../../core/interfaces/component-type.interface';
import { BackdropService } from '../backdrop/backdrop.service';
import { BackdropComponent } from '../backdrop/backdrop.component';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../core/classes';

@Injectable()
@UnSub()
export class PaneService {
    onClose: EventEmitter<any> = new EventEmitter();

    componentFactoryResolver: ComponentFactoryResolver;
    private _backdrop: ComponentRef<BackdropComponent>;
    private _taskPane: ComponentRef<any>;
    private _subscription: Subscription;

    constructor(
        private _overlayService: OverlayService,
        private _backdropService: BackdropService,
        componentFactoryResolver: ComponentFactoryResolver) {
        this.componentFactoryResolver = componentFactoryResolver;
    }

    /**
     * Function open Pane with desired content
     * @param {ComponentType<C extends IPaneContent>} componentType
     * @returns {Promise<ComponentRef<C extends IPaneContent>>}
     */
    private open<C extends IPaneContent>(componentType: ComponentType<C>): Promise<ComponentRef<C>> {
        const promise: Promise<ComponentRef<C>> = new Promise(resolve => {
            const factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
            const componentRef = this._overlayService.getOverlay(OVERLAY_CONTEXT.ROOT).createComponent(factory);
            this._taskPane = componentRef;

            this._backdrop = this._backdropService.create(true, OVERLAY_CONTEXT.APP);
            this._subscription = this._backdrop.instance.onClose.subscribe(() => {
                this.close(this._taskPane);
            });

            this._taskPane.instance.componentFactoryResolver = this.componentFactoryResolver;
            this._taskPane.instance.zIndex = this._backdrop.instance.zIndex + 1;
            // timeout enables animation
            setTimeout(() => {
                this._taskPane.instance.open = true;
            });

            resolve(this._taskPane);
        });
        return promise;
    }

    /**
     * Function to open TaskPane
     * @returns {Promise<ComponentRef<TaskPaneComponent>>}
     */
    async openTaskPane(): Promise<ComponentRef<TaskPaneComponent>> {
        return await this.open(TaskPaneComponent);
    }

    // async openNotificationPane(): void {
    //     // TODO: Implement NotificationPaneComponent
    //     return await this.open(NotificationPaneComponent);
    // }

    /**
     * Function to destroy a pane
     * @param {ComponentRef<IPaneContent>} componentRef
     */
    close(componentRef?: ComponentRef<IPaneContent>): void {
        if (!componentRef) {
            if (this._taskPane) {
                componentRef = this._taskPane;
            } else {
                return;
            }
        }
        componentRef.instance.open = false;
        this._backdropService.remove(this._backdrop, OVERLAY_CONTEXT.APP);
        this.onClose.emit();
        // Allow animation to run befor cleaning up
        setTimeout(() => {
            componentRef.destroy();
            componentRef = null;
        }, 335);
    }
}
