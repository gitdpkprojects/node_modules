import { BucketVisualisationConstants as Constants } from '../bucket-visualisation.constants';
import { D3Line, D3Polygon, D3Text, D3Rect, D3Circle } from '../bucket-visualisation.types';
import { Status, EndPoint, ExternalValue, BucketThreshold } from '../bucket-visualisation.model';
import { UUID } from '../../../core/helpers';

/** Container holding data about a threshold related to a status */
export class StatusThreshold {
    uuid: string = UUID.create();

    constructor(
        public id: string,
        public index: number,
        public position: string,
        public error?: string) {
    }
}

/** Wrapper holding SVG objects for a bucket value */
export class BucketValueData {

    constructor(
        public limit: D3Line,
        public arrow: D3Polygon,
        public text: D3Text,
        public area?: D3Polygon) {
    }

    raise(): void {
        this.limit.raise();
        this.arrow.raise();
        this.text.raise();
        if (this.area) {
            this.area.raise();
        }
    }

    remove(): void {
        this.limit.remove();
        this.arrow.remove();
        this.text.remove();
        if (this.area) {
            this.area.remove();
        }
    }
}

/** Wrapper holding SVG objects for a single external value */
export class ExternalValueData {

    constructor(
        public externalValue: ExternalValueMetaInfo,
        public name: D3Text,
        public value: D3Text,
        public highlight?: D3Rect,
        public dot?: D3Circle,
        public chain?: Array<D3Circle>) {
    }

    remove(): void {
        this.name.remove();
        this.value.remove();
        if (this.highlight) {
            this.highlight.remove();
        }
        if (this.dot) {
            this.dot.remove();
        }
        if (this.chain) {
            this.chain.forEach(link => link.remove());
        }
    }

    raise(): void {
        if (this.highlight) {
            this.highlight.raise();
        }
        this.name.raise();
        this.value.raise();
        if (this.dot) {
            this.dot.raise();
        }
        if (this.chain) {
            this.chain.forEach(link => link.raise());
        }
    }
}

/** Wrapper holding SVG objects for an external value block */
export class ExternalValueBlockData {

    constructor(
        public externalValueBlock: ExternalValueBlock,
        public block: D3Polygon,
        public externalValue: Array<ExternalValueData>,
        public minLine?: D3Line,
        public maxLine?: D3Line,
        public area?: D3Rect) {
    }

    remove(): void {
        this.block.remove();
        if (this.area) {
            this.area.remove();
        }
        if (this.minLine) {
            this.minLine.remove();
        }
        if (this.maxLine) {
            this.maxLine.remove();
        }
        this.externalValue.forEach(externalValue => externalValue.remove());
    }

    raise(): void {
        if (this.minLine) {
            this.minLine.raise();
        }
        if (this.maxLine) {
            this.maxLine.raise();
        }
        this.block.raise();
        this.externalValue.forEach(externalValue => externalValue.raise());
        this.externalValue.forEach(externalValue => {
            if (externalValue.chain) {
                externalValue.chain.forEach(link => link.raise());
            }
        });
    }
}

/** Wrapper holding SVG objects for the different statuses */
export class StatusData {

    constructor(
        public statuses: Array<Status>,
        public texts: Array<D3Text>,
        public separators: Array<D3Line>) {
    }

    remove(): void {
        this.separators.forEach(separator => separator.remove());
        this.texts.forEach(text => text.remove());
    }
}

/** Wrapper holding SVG objects for a limit */
export class LimitData {

    constructor(public line: D3Line, public text: D3Text, public area?: D3Rect) {
    }

    raise(): void {
        this.line.raise();
        this.text.raise();
        if (this.area) {
            this.area.raise();
        }
    }

    remove(): void {
        this.line.remove();
        this.text.remove();
        if (this.area) {
            this.area.remove();
        }
    }
}

/** Wrapper holding SVG objects for a bucket interval */
export class BucketIntervalData {

    constructor(public upperBound: D3Line, public lowerBound: D3Line, public area: D3Polygon) {
    }

    raise(): void {
        this.upperBound.raise();
        this.lowerBound.raise();
        this.area.raise();
    }

    remove(): void {
        this.upperBound.remove();
        this.lowerBound.remove();
        this.area.remove();
    }
}


/** Wrapper class for different data to be able to create a tooltip and position it correctly */
export class TooltipData {
    textBox: D3Text;
    top: number;
    left: number;
    text: string;
    visible = false;

    constructor() { }

    get topStyle(): string {
        return `${this.top}px`;
    }

    get leftStyle(): string {
        return `${this.left}px`;
    }

    get textBoxWidth(): string {
        return this.textBox ? `${this.textBox.node().getBBox().width}px` : '0px';
    }

    show(): void {
        this.visible = true;
    }

    hide(): void {
        this.visible = false;
    }
}

/**
 * Holds data about an external value, (Threashold of range value).
 * The data holds the data object and the actual Y position of the value as well as min/max Y values of the arrow.
 */
export class ExternalValueMetaInfo {
    private _minYPos: number;
    private _maxYPos: number;

    static fromThreshold(threshold: BucketThreshold, yPos: number, bucketHeight: number): ExternalValueMetaInfo {
        return new ExternalValueMetaInfo(threshold, yPos, bucketHeight);
    }

    static fromIntervalEndPoint(endPoint: EndPoint, yPos: number, bucketHeight: number): ExternalValueMetaInfo {
        return new ExternalValueMetaInfo(endPoint, yPos, bucketHeight, true);
    }

    private constructor(
        public externalValue: ExternalValue,
        public yPos: number,
        private bucketHeight: number,
        public backgroundHighlight: boolean = false) {
        this._minYPos = this.calculateMinYPos();
        this._maxYPos = this.calculateMaxYPos();
        this.adjustMinMaxYPos();
    }

    equals(other: ExternalValueMetaInfo): boolean {
        return this.externalValue.id === other.externalValue.id;
    }

    get minYPos(): number {
        return this._minYPos;
    }

    get maxYPos(): number {
        return this._maxYPos;
    }

    private calculateMinYPos(): number {
        return this.yPos - Constants.THRESHOLD.HEIGHT * 0.5;
    }

    private calculateMaxYPos(): number {
        return this.yPos + Constants.THRESHOLD.HEIGHT * 0.5;
    }

    /**
     * We need to adjust the Y position so that the arrow and the actual value will not be drawn outside the bucket canvas.
     */
    private adjustMinMaxYPos(): void {
        const height = this.bucketHeight + Constants.BUCKET_MEASURES.EXTRA_HEIGHT;
        const minY = Constants.THRESHOLD.HEIGHT * 0.5;
        const maxY = height - Constants.THRESHOLD.HEIGHT * 0.5;
        const minYPos = this._minYPos;
        const maxYPos = this._maxYPos;
        if (this.yPos < minY) {
            this.yPos = minY;
        }
        if (this.yPos > maxY) {
            this.yPos = maxY;
        }
        if (minYPos < 0) {
            this._maxYPos = Math.abs(maxYPos - minYPos);
            this._minYPos = 0;
        }
        if (this._maxYPos > height) {
            this._minYPos = height - (Math.abs(maxYPos - minYPos));
            this._maxYPos = height;
        }
    }
}

/**
 * The class that will be used to draw either a single value block or a forked block.
 * This class is responsible to determine the Y positions of the whole block. (Y, min, max)
 */
export class ExternalValueBlock {
    private _externalValues: Array<ExternalValueMetaInfo>;
    private _min: ExternalValueMetaInfo;
    private _max: ExternalValueMetaInfo;
    private _minYPos: number;
    private _maxYPos: number;

    static fromThreshold(threshold: BucketThreshold, yPos: number, bucketHeight: number) {
        return new ExternalValueBlock([ExternalValueMetaInfo.fromThreshold(threshold, yPos, bucketHeight)], bucketHeight);
    }

    static fromIntervalEndPoint(endPoint: EndPoint, yPos: number, bucketHeight: number) {
        return new ExternalValueBlock([ExternalValueMetaInfo.fromIntervalEndPoint(endPoint, yPos, bucketHeight)], bucketHeight);
    }

    constructor(externalValues: Array<ExternalValueMetaInfo>, private bucketHeight: number) {
        this._externalValues = this.sort(externalValues);
        this._min = this.findMinValue();
        this._max = this.findMaxValue();
        this._minYPos = this.calculateMinYPos();
        this._maxYPos = this.calculateMaxYPos();
        this.adjustMinMaxYPos();
    }

    /**
     * Merges two blocks, i.e. forks them
     * @param fork other block to merge with this one
     */
    merge(fork: ExternalValueBlock) {
        return new ExternalValueBlock([...this._externalValues, ...fork._externalValues], this.bucketHeight);
    }

    /**
     * Checks if another block will intersect or overlap with this one in Y axis.
     * @param other other block to evaluate
     */
    isIntersectingWith(other: ExternalValueBlock): boolean {
        const thisMinY = this._minYPos - Constants.THRESHOLD.FORK_SPACING;
        const thisMaxY = this._maxYPos + Constants.THRESHOLD.FORK_SPACING;
        const otherMinY = other._minYPos - Constants.THRESHOLD.FORK_SPACING;
        const otherMaxY = other._maxYPos + Constants.THRESHOLD.FORK_SPACING;
        return (otherMinY >= thisMinY && otherMinY <= thisMaxY)
            || (otherMaxY >= thisMinY && otherMaxY <= thisMaxY);
    }

    isForked(): boolean {
        return this.externalValues.length > 1;
    }

    equals(other: ExternalValueBlock): boolean {
        if (this._externalValues.length === other._externalValues.length) {
            return this._externalValues.every((externalValue, index) => externalValue.equals(other._externalValues[index]));
        } else {
            return false;
        }
    }

    get min(): ExternalValueMetaInfo {
        return this._min;
    }

    get max(): ExternalValueMetaInfo {
        return this._max;
    }

    get minY(): number {
        return this._minYPos;
    }

    get maxY(): number {
        return this._maxYPos;
    }

    get centerY(): number {
        return (this.max.yPos + this.min.yPos) / 2;
    }

    get externalValues(): Array<ExternalValueMetaInfo> {
        return this._externalValues;
    }

    private findMinValue(): ExternalValueMetaInfo {
        return this.externalValues.reduce((currentMin: ExternalValueMetaInfo, currentValue: ExternalValueMetaInfo) => {
            if (currentMin.externalValue.value && currentValue.externalValue.value) {
                return currentMin.externalValue.value.value < currentValue.externalValue.value.value
                    ? currentMin
                    : currentValue;
            } else {
                return currentMin;
            }
        });
    }

    private findMaxValue(): ExternalValueMetaInfo {
        return this.externalValues.reduce((currentMax: ExternalValueMetaInfo, currentValue: ExternalValueMetaInfo) => {
            if (currentMax.externalValue.value && currentValue.externalValue.value) {
                return currentMax.externalValue.value.value > currentValue.externalValue.value.value
                    ? currentMax
                    : currentValue;
            } else {
                return currentMax;
            }
        });
    }

    private calculateMinYPos(): number {
        const offset = this.isForked() ? Constants.THRESHOLD.FORK_PADDING : 0;
        return this.centerY - offset - this.externalValues.length * Constants.THRESHOLD.HEIGHT * 0.5;
    }

    private calculateMaxYPos(): number {
        const offset = this.isForked() ? Constants.THRESHOLD.FORK_PADDING : 0;
        return this.centerY + offset + this.externalValues.length * Constants.THRESHOLD.HEIGHT * 0.5;
    }

    /**
     * We need to adjust the Y position so that the arrows and the actual values will not be drawn outside the bucket canvas.
     */
    private adjustMinMaxYPos(): void {
        this._minYPos = Math.trunc(this._minYPos);
        this._maxYPos = Math.trunc(this._maxYPos);
        const height = this.bucketHeight + Constants.BUCKET_MEASURES.EXTRA_HEIGHT;
        if (this._minYPos < 0) {
            this._maxYPos = Math.abs(this._maxYPos - this._minYPos);
            this._minYPos = 0;
        }
        if (this._maxYPos > height) {
            this._minYPos = height - (Math.abs(this._maxYPos - this._minYPos));
            this._maxYPos = height;
        }
    }

    /** Sorts the values according to their values */
    private sort(externalValues: Array<ExternalValueMetaInfo>): Array<ExternalValueMetaInfo> {
        return [...externalValues].sort((left, right) => {
            return right.externalValue.value.value - left.externalValue.value.value;
        });
    }
}
