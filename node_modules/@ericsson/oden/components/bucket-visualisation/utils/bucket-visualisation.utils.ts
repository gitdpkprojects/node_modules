import { NumberHelper } from './../../../core/helpers/number.helper';
import { BucketMeasures } from './bucket-visualisation.utils';
import { BucketThreshold } from './../bucket-visualisation.model';
import * as D3 from 'd3';
import { BucketVisualisationConstants as Constants } from '../bucket-visualisation.constants';
import { D3Polygon, D3Rect, D3Text, D3Line, D3Circle } from '../bucket-visualisation.types';
import { TooltipData, ExternalValueBlock } from './bucket-visualisation.utils.model';

/** Positioning data for basis when drawing rectangles and polygons */
export interface FillCoordinates {
    x?: number;
    y?: number;
    w?: number;
    h?: number;
}

/** Options interface for SVG lines */
export interface LineOptions {
    startX: number;
    startY: number;
    endX: number;
    endY: number;
    color: string;
    dotted?: boolean;
    dashed?: boolean;
    class?: string;
}

/** Options interface for SVG text */
export interface TextOptions {
    x: number;
    y: number;
    text: string;
    createTooltip: (tooltipData: TooltipData) => void;
    removeTooltip: () => void;
    removeOffset?: boolean;
    anchor?: string;
    class?: string;
    maxWidth?: number;
    tooltip?: string;
    alwaysShowTooltip?: boolean;
}

/** Options interface for SVG rect */
export interface RectOptions {
    x: number;
    y: number;
    h: number;
    w: number;
    class?: string;
    fill?: string;
}

/** Options interface for SVG polygon */
export interface PolygonOptions {
    points: Array<number>;
    fill?: string;
    class?: string;
}

/** Options interface for SVG circle */
export interface CircleOptions {
    cx: number;
    cy: number;
    r: number;
    fill?: string;
}

/** Interface for the measures of the bucket visualisation */
export interface BucketMeasures {
    x: number;
    y: number;
    w: number;
    h: number;
    thresholdWidth: number;
}

/** Utils class for bucket visualisation component, helper methods for drawing SVG elements */
export class BucketVisualisationUtils {
    readonly MAX_STATUSES_FOR_STATIC: number = 5;
    readonly MAX_PROCENT: number = 100;

    _svg: any;

    /**
     * Sort threshold objects based on order
     * @param x
     * @param y
     * @returns -1 if x is ordered lower than y, 1 if it is ordered higher and 0 if they are equal
     */
    sortThresholdsOnOrder(x: BucketThreshold, y: BucketThreshold): number {
        return x.order < y.order ? -1 : x.order > y.order ? 1 : 0;
    }

    /**
     * Calculates the measurement of the bucket visualisation
     * @param container             - Main HTML element
     * @param height                - Height of the bucket
     * @param displayExternalValues - Whether of not we need to reserve space To the right side of the bucket for external values.
     * @returns the measures of the bucket
     */
    getBucketMeasures(container: HTMLElement, height: number, displayExternalValues: boolean): BucketMeasures {
        const bucketBaseWidth = container.offsetWidth - Constants.BUCKET_MEASURES.LEFT_OFFSET;
        const bucketWidthPercent = container.getBoundingClientRect().width <= 665 ? 50 : 100 * 8 / 12;
        const bucketWidth = displayExternalValues ? NumberHelper.getProcentValueOf(bucketBaseWidth, bucketWidthPercent) : bucketBaseWidth;
        const thresholdWidth = bucketBaseWidth - bucketWidth;
        return {
            x: Constants.BUCKET_MEASURES.LEFT_OFFSET,
            y: Constants.BUCKET_MEASURES.TOP_BOTTOM_OFFSET,
            w: bucketWidth,
            h: height - Constants.BUCKET_MEASURES.TOP_BOTTOM_OFFSET,
            thresholdWidth: thresholdWidth
        };
    }

    /**
     * Draws a polygon element and append it to the SVG
     * @param options the options to be used when drawing the element
     */
    drawPolygon(options: PolygonOptions): D3Polygon {
        return <D3Polygon>this._svg.append('polygon')
            .attr('fill', options.fill)
            .attr('points', () => options.points.join(' '))
            .attr('class', options.class);
    }

    /**
     * Moves an already created element
     * @param polygon the previous element to move
     * @param options the options to be used when drawing the element
     */
    movePolygon(polygon: D3Polygon, options: PolygonOptions): D3Polygon {
        // We will not do any transitions for the x
        const nonAnimatedPoints = options.points.map((point, index) => {
            return index % 2 === 1 ? polygon.node().points.getItem(Math.floor(index / 2)).y : point;
        });
        polygon
            .attr('points', () => nonAnimatedPoints.join(' '))
            .transition()
            .attr('fill', options.fill)
            .attr('points', () => options.points.join(' '))
            .attr('class', options.class)
            .duration(Constants.TRANSITION_DURATION);
        return polygon;
    }

    /**
     * Draws a rect element and append to SVG
     * @param options the options to be used when drawing the element
     */
    drawRect(options: RectOptions): D3Rect {
        const h = Math.abs(options.h);
        const y = options.h < 0 ? options.y - h : options.y;
        return <D3Rect>this._svg.append('rect')
            .attr('x', options.x)
            .attr('y', y)
            .attr('width', Math.max(options.w, 0))
            .attr('height', Math.max(options.h, 0))
            .attr('fill', options.fill)
            .attr('class', options.class);
    }

    /**
     * Moves an already created element
     * @param area the previous element to move
     * @param options the options to be used when drawing the element
     */
    moveRect(area: D3Rect, options: RectOptions): D3Rect {
        const h = Math.abs(options.h);
        const y = options.h < 0 ? options.y - h : options.y;
        area
            .attr('x', options.x)
            .attr('width', Math.max(options.w, 0))
            .transition()
            .attr('y', y)
            .attr('height', Math.max(options.h, 0))
            .attr('fill', options.fill)
            .attr('class', options.class)
            .duration(Constants.TRANSITION_DURATION);
        return area;
    }

    /**
     * Draws a circle element and append to SVG
     * @param options the options to be used when drawing the element
     */
    drawCircle(options: CircleOptions): D3Circle {
        return <D3Circle>this._svg.append('circle')
            .attr('cx', options.cx)
            .attr('cy', options.cy)
            .attr('r', options.r)
            .attr('fill', options.fill);
    }

    /**
     * Moves an already created element
     * @param circle the previous element to move
     * @param options the options to be used when drawing the element
     */
    moveCircle(circle: D3Circle, options: CircleOptions): D3Circle {
        circle
            .attr('cx', options.cx)
            .transition()
            .attr('cy', options.cy)
            .attr('r', options.r)
            .attr('fill', options.fill)
            .duration(Constants.TRANSITION_DURATION);
        return circle;
    }

    /**
     * Draws text element and append to SVG
     * @param options the options to be used when drawing the element
     */
    drawText(options: TextOptions): D3Text {
        const xPos = options.removeOffset ? options.x : (options.x + Constants.DEFAULT_TEXT_X_OFFSET);
        let text = options.text;

        const textField = <D3Text>this._svg.append('text')
            .attr('x', xPos)
            .attr('y', options.y)
            .attr('dy', '0.30em') // Used to center the text vertically
            .attr('text-anchor', options.anchor || 'middle')
            .attr('class', options.class)
            .text(text);

        if (options.tooltip) {
            this.drawTooltip(textField, options, options.tooltip);
        } else if (options.maxWidth) {
            while (textField.node().getComputedTextLength() > options.maxWidth) {
                text = text.slice(0, -1);
                textField.text(text + ' ...');
            }
            if (options.text !== text) {
                this.drawTooltip(textField, options, options.text);
            }
        }
        return textField;
    }

    /**
     * Moves an already created element
     * @param textBox the previous element to move
     * @param options the options to be used when drawing the element
     */
    moveText(textBox: D3Text, options: TextOptions): D3Text {
        const xPos = options.removeOffset ? options.x : (options.x + Constants.DEFAULT_TEXT_X_OFFSET);
        let text = options.text;

        textBox
            .attr('x', xPos)
            .attr('text-anchor', options.anchor || 'middle')
            .text(text);

        if (options.tooltip) {
            this.drawTooltip(textBox, options, options.tooltip);
        } else if (options.maxWidth) {
            while (textBox.node().getComputedTextLength() > options.maxWidth && text.length) {
                text = text.slice(0, -1);
                textBox.text(text + ' ...');
            }
            if (options.text !== text) {
                this.drawTooltip(textBox, options, options.text);
            }
        }
        textBox
            .transition()
            .attr('y', options.y)
            .attr('class', options.class)
            .duration(Constants.TRANSITION_DURATION);
        return textBox;
    }

    /**
     * Draws line element and append to SVG
     * @param options the options to be used when drawing the element
     */
    drawLine(options: LineOptions): D3Line {
        let clazz = (options.dashed ? 'dashed-line' : options.dotted ? 'dotted-line' : 'solid-line');
        clazz += options.class ? ` ${options.class}` : '';
        return <D3Line>this._svg.append('line')
            .style('stroke', options.color)
            .attr('x1', options.startX)
            .attr('y1', options.startY)
            .attr('x2', options.endX)
            .attr('y2', options.endY)
            .attr('class', clazz);
    }

    /**
     * Moves an already created element
     * @param line the previous element to move
     * @param options the options to be used when drawing the element
     */
    moveLine(line: D3Line, options: LineOptions): D3Line {
        let clazz = (options.dashed ? 'dashed-line' : options.dotted ? 'dotted-line' : 'solid-line');
        clazz += options.class ? ` ${options.class}` : '';
        line
            .attr('x1', options.startX)
            .attr('x2', options.endX)
            .transition()
            .style('stroke', options.color)
            .attr('y1', options.startY)
            .attr('y2', options.endY)
            .attr('class', clazz)
            .duration(Constants.TRANSITION_DURATION);
        return line;
    }

    /**
     * Get the polygon points for the arrow part of inital value
     * @param y                - Line Y position to align with
     * @param bucketMeasures   - The bucket measures
     * @param valueWidth       - Calculated value for width so value can fit inside
     * @returns the array of the points to be used when drawing the polygon
     */
    getPolygonPointsForLeftSideArrow(y: number, bucketMeasures: BucketMeasures, valueWidth: number): Array<number> {
        const basePosition = bucketMeasures.x;
        const minY = y - Constants.VALUES.ARROW_HEIGHT * 0.5;
        const maxY = y + Constants.VALUES.ARROW_HEIGHT * 0.5;
        return [
            basePosition, minY,
            basePosition + valueWidth, minY,
            basePosition + valueWidth + Constants.VALUES.ARROW_SIZE, y,
            basePosition + valueWidth, maxY,
            basePosition, maxY
        ];
    }

    /**
     * Get the polygon points for the arrow part of actual value
     * @param y                - Line Y position to align with
     * @param bucketMeasures   - The bucket measures
     * @param valueWidth       - Calculated value for width so value can fit inside
     * @returns the array of the points to be used when drawing the polygon
     */
    getPolygonPointsForRightSideArrow(y: number, bucketMeasures: BucketMeasures, valueWidth: number): Array<number> {
        const basePosition = bucketMeasures.x + bucketMeasures.w;
        const minY = y - Constants.VALUES.ARROW_HEIGHT * 0.5;
        const maxY = y + Constants.VALUES.ARROW_HEIGHT * 0.5;
        return [
            basePosition, minY,
            basePosition - valueWidth, minY,
            basePosition - valueWidth - Constants.VALUES.ARROW_SIZE, y,
            basePosition - valueWidth, maxY,
            basePosition, maxY
        ];
    }

    /**
     * Get the polygon points for the arrow part of an external value
     * @param externalValueBlock - The block to create the polygon points for
     * @param bucketMeasures     - The bucket measures
     * @returns the array of the points to be used when drawing the polygon
     */
    getPolygonPointsForexternalValueBlock(externalValueBlock: ExternalValueBlock, bucketMeasures: BucketMeasures): Array<number> {
        if (externalValueBlock.externalValues.length > 1) {
            return this.getPolygonPointsForForkedExternalValuelock(externalValueBlock, bucketMeasures);
        } else {
            return this.getPolygonPointsForSinlgeExternalValueBlock(externalValueBlock, bucketMeasures);
        }
    }

    /**
     * Try to see if "wanted" selectbox for selected threshold is free and returns that index
     * @param usedIndexes         - Selectbox indexes matched and used
     * @param amountOfSelectBoxes - Amount selectboxes drawn out
     * @returns the first free index
     */
    findFreeSelectbox(usedIndexes: Array<number>, amountOfSelectBoxes: number): number {
        for (let i = 0; i < amountOfSelectBoxes; i++) {
            if (usedIndexes.indexOf(i) === -1) {
                return i;
            }
        }
        return 0;
    }

    /** Returns the data about the text, i.e. width and height */
    getTextData(text: string): SVGRect {
        const testElement = <D3Text>this._svg.append('text').style('visibility', 'hidden').text(text);
        const width = testElement.node().getBBox();
        testElement.remove();
        return width;
    }

    /** Raise all svg texts so that they will be visible */
    moveAllTextsToFront(): void {
        D3.selectAll('text').raise();
    }

    /**
     * Get the polygon points for the arrow part of an externalValue
     * @param externalValueBlock - The block to create the polygon points for
     * @param bucketMeasures     - The bucket measures
     * @returns the array of the points to be used when drawing the polygon
     */
    private getPolygonPointsForSinlgeExternalValueBlock(
        externalValueBlock: ExternalValueBlock,
        bucketMeasures: BucketMeasures
    ): Array<number> {
        const basePosition = bucketMeasures.x + bucketMeasures.w;
        return [
            // Base block
            basePosition, externalValueBlock.minY,
            basePosition + bucketMeasures.thresholdWidth, externalValueBlock.minY,
            basePosition + bucketMeasures.thresholdWidth, externalValueBlock.maxY,
            basePosition, externalValueBlock.maxY,
            // Arrow
            basePosition, externalValueBlock.centerY + Constants.THRESHOLD.ARROW_SIZE,
            basePosition - Constants.THRESHOLD.ARROW_SIZE, externalValueBlock.centerY,
            basePosition, externalValueBlock.centerY - Constants.THRESHOLD.ARROW_SIZE,
        ];
    }

    /**
     * Get the polygon points for the arrow part of a threshold
     * @param externalValueBlock - The block to create the polygon points for
     * @param bucketMeasures     - The bucket measures
     * @returns the array of the points to be used when drawing the polygon
     */
    private getPolygonPointsForForkedExternalValuelock(
        externalValueBlock: ExternalValueBlock,
        bucketMeasures: BucketMeasures
    ): Array<number> {
        const basePosition = bucketMeasures.x + bucketMeasures.w;
        const minArrowBase = externalValueBlock.min.yPos;
        const maxArrowBase = externalValueBlock.max.yPos;

        return [
            // Base block - top left
            basePosition + bucketMeasures.thresholdWidth, externalValueBlock.minY,
            basePosition + bucketMeasures.thresholdWidth, externalValueBlock.maxY,
            basePosition, externalValueBlock.maxY,
            // Bottom arrow
            basePosition, maxArrowBase - Constants.THRESHOLD.ARROW_SIZE,
            basePosition - Constants.THRESHOLD.ARROW_SIZE, maxArrowBase,
            basePosition, maxArrowBase,
            // Top Arrow
            basePosition, minArrowBase,
            basePosition - Constants.THRESHOLD.ARROW_SIZE, minArrowBase,
            basePosition, minArrowBase + Constants.THRESHOLD.ARROW_SIZE,
            // Top left coordinate of the base block. This position is drawn last because of rendering issues with anti aliasing.
            basePosition, externalValueBlock.minY,
        ];
    }

    /** Responsible to create hover events for the tooltip and for determine the center of the hovered text. */
    private drawTooltip(textBox: D3Text, options: TextOptions, text: string): void {
        textBox
            .on('mouseover', () => {
                const textPositionData = <any>textBox.node().getBBox();
                const centerY = textPositionData.y + textPositionData.height * 0.5;
                const centerX = textPositionData.x + textPositionData.width * 0.5;
                const tooltipData = new TooltipData();
                tooltipData.top = centerY < 0 ? 0 : Math.ceil(centerY);
                tooltipData.left = centerX < 0 ? 0 : Math.ceil(centerX);
                tooltipData.textBox = textBox;
                tooltipData.text = text;
                options.createTooltip(tooltipData);
            })
            .on('mouseleave', () => {
                options.removeTooltip();
            });
    }
}
