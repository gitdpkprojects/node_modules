import { NumberHelper } from './../../core/helpers/number.helper';
import { ArrayHelper } from './../../core/helpers/array.helper';
import {
    Threshold,
    Status,
    BucketInformation,
    VisualisationOptions,
    BucketError,
    ValueWithUnit,
    ThresholdError,
    BucketInterval,
    EndPoint,
    BucketThreshold,
    Bucket,
    BucketValue
} from './bucket-visualisation.model';
import {
    BucketVisualisationUtils,
    BucketMeasures,
    FillCoordinates,
    LineOptions
} from './utils/bucket-visualisation.utils';
import {
    ViewEncapsulation,
    Component,
    AfterViewInit,
    ElementRef,
    ViewChild,
    Input,
    Output,
    EventEmitter,
    HostBinding,
    OnChanges,
    SimpleChanges
} from '@angular/core';
import * as D3 from 'd3';
import { BUCKET_MODE, STATUS_ORDER } from './../../core/constants/bucket-visualisation.constants';
import { BucketVisualisationConstants as Constants } from './bucket-visualisation.constants';
import { D3Rect, D3Line, D3Text, D3Polygon, D3Circle } from './bucket-visualisation.types';
import { WhitelabelService } from '../../core/services/whitelabel.service';
import { TranslateService } from '@ngx-translate/core';
import {
    StatusThreshold,
    TooltipData,
    BucketValueData,
    LimitData,
    StatusData,
    BucketIntervalData,
    ExternalValueBlockData,
    ExternalValueBlock,
    ExternalValueData
} from './utils/bucket-visualisation.utils.model';
import { Subscription } from 'rxjs';
import { UnSub } from '../../core/classes';
import { COLORWHITELABEL } from '../../core/constants/color.whitelabel';
import { ResizeService } from '../../core/services/resize.service';

@Component({
    selector: 'cui-bucket-visualisation',
    templateUrl: 'bucket-visualisation.component.html',
    styleUrls: ['bucket-visualisation.component.scss'],
    encapsulation: ViewEncapsulation.None
})

/**
 * Bucket visualisation component, usage for visulise a bucket with min/initial/max value
 * but also configuration for thresholds.
 */
@UnSub()
export class BucketVisualisationComponent extends BucketVisualisationUtils implements AfterViewInit, OnChanges {
    private static ZERO: BucketValue = new BucketValue({ value: 0, displayValue: '0' });

    @ViewChild('container')
    containerEle: ElementRef;
    @ViewChild('bucketTooltip')
    bucketTooltip: ElementRef;
    @HostBinding('class.cui-bucket-visualisation')
    addClass: boolean = true;
    @Input()
    bucket: Bucket | BucketInformation = null;
    @Input()
    thresholds: Array<BucketThreshold | Threshold> = [];
    @Input()
    interval: BucketInterval = null;
    @Input()
    statuses: Array<Status> = [];
    @Input()
    selectedThresholds: Array<BucketThreshold | Threshold> = [];
    @Input()
    thresholdErrors: Array<ThresholdError> = [];
    @Input()
    options: VisualisationOptions = new VisualisationOptions();
    /** @deprecated use thresholdErrors instead **/
    @Input()
    error: BucketError = null;
    @Output()
    onChange: EventEmitter<Array<Threshold>> = new EventEmitter();
    @Output()
    onSelectedThresholdsChange: EventEmitter<Array<BucketThreshold>> = new EventEmitter();

    _statusThresholds: Array<StatusThreshold>;
    _tooltipData: TooltipData = new TooltipData();
    _thresholds: Array<BucketThreshold> = new Array();

    _disabled: boolean = false;
    _selectableThresholds: boolean = true;
    _requireThresholds: boolean = false;
    _bucketColumnWidth: string = '100%';

    private _native: HTMLElement;
    private _tooltipTimeout: any = null;
    private _subscriptions: Array<Subscription> = [];
    private _bucketMeasures: BucketMeasures;

    private _selectedThresholds: Array<BucketThreshold> = new Array();
    private _statuses: Array<Status> = new Array();
    private _thresholdErrors: Array<ThresholdError> = new Array();

    private _bucket: Bucket;
    private _options: VisualisationOptions = new VisualisationOptions();

    private _initialTooltipText: string = '';
    private _actualTooltipText: string = '';

    // Svg objects
    private _initialBucketValue: BucketValueData = null;
    private _actualBucketValue: BucketValueData = null;
    private _min: LimitData = null;
    private _max: LimitData = null;
    private _zero: LimitData = null;
    private _background: D3Rect = null;
    private _drawnStatuses: StatusData = null;
    private _drawnBucketInterval: BucketIntervalData = null;
    private _drawnExternalValues: Array<ExternalValueBlockData> = [];

    constructor(resizeService: ResizeService, translate: TranslateService, private _whitelabelService: WhitelabelService) {
        super();
        this._subscriptions.push(resizeService.resize$.subscribe(() => this.redraw()));
        this._subscriptions.push(
            translate.stream('ODEN.COMPONENTS.BUCKET.INITIAL_VALUE').subscribe(value => this._initialTooltipText = value)
        );
        this._subscriptions.push(
            translate.stream('ODEN.COMPONENTS.BUCKET.ACTUAL_VALUE').subscribe(value => this._actualTooltipText = value)
        );
        this._subscriptions.push(this._whitelabelService._whitelabelingLoaded.subscribe(() => {
            this.redraw();
        }));
    }

    /** Initial draw call and declaring native variable for further use */
    ngAfterViewInit(): void {
        this._native = this.containerEle.nativeElement;
        this.redraw();
    }

    ngOnChanges(changes: SimpleChanges): void {
        let needsRedraw = false;

        if (changes.thresholds
            && !ArrayHelper.areArraysEqual(changes.thresholds.currentValue, changes.thresholds.previousValue)) {
            const thresholds = changes.thresholds.currentValue;
            let newThresholds = this._thresholds;
            if (Array.isArray(thresholds) && thresholds.every(th => th instanceof Threshold)) {
                newThresholds = thresholds.map(th => (<Threshold>th).toBucketThreshold());
            } else if (Array.isArray(thresholds) && thresholds.every(th => th instanceof BucketThreshold)) {
                newThresholds = thresholds;
            }
            if (!ArrayHelper.areArraysEqual(newThresholds, this._thresholds)) {
                this._thresholds = newThresholds;
                needsRedraw = true;
            }
        }

        if (changes.selectedThresholds
            && !ArrayHelper.areArraysEqual(changes.selectedThresholds.currentValue, changes.selectedThresholds.previousValue)) {
            const thresholds = changes.selectedThresholds.currentValue;
            let selectedThresholds = this._selectedThresholds;
            if (Array.isArray(thresholds) && thresholds.every(th => th instanceof Threshold)) {
                selectedThresholds = thresholds.map(th => (<Threshold>th).toBucketThreshold());
            } else if (Array.isArray(thresholds) && thresholds.every(th => th instanceof BucketThreshold)) {
                selectedThresholds = thresholds;
            }
            if (!ArrayHelper.areArraysEqual(selectedThresholds, this._selectedThresholds)) {
                this._selectedThresholds = selectedThresholds;
                needsRedraw = true;
            }
        }

        if (changes.thresholdErrors
            && !ArrayHelper.areArraysEqual(changes.thresholdErrors.currentValue, changes.thresholdErrors.previousValue)) {
            const thresholdErrors = changes.thresholdErrors.currentValue;
            this._thresholdErrors = Array.isArray(thresholdErrors) ? thresholdErrors : [];
            needsRedraw = true;
        }

        if (changes.statuses && !ArrayHelper.areArraysEqual(changes.statuses.currentValue, changes.statuses.previousValue)) {
            const statuses = changes.statuses.currentValue;
            this._statuses = Array.isArray(statuses) ? statuses : [];
            needsRedraw = true;
        }

        if (changes.bucket && changes.bucket.currentValue !== changes.bucket.previousValue) {
            const bucket = changes.bucket.currentValue;
            this._bucket = bucket instanceof BucketInformation ? bucket.toBucket() : bucket;
            needsRedraw = true;
        }

        if (changes.interval && changes.interval.currentValue !== changes.interval.previousValue) {
            needsRedraw = true;
        }

        if (changes.error && changes.error.currentValue !== changes.error.previousValue) {
            needsRedraw = true;
        }

        if (changes.options && changes.options.currentValue !== changes.options.previousValue) {
            this._options = changes.options.currentValue || new VisualisationOptions();
            needsRedraw = true;
        }

        if (needsRedraw) {
            this.redraw();
        }
    }

    _thresholdIdentifier(_index: number, threshold: StatusThreshold): number {
        return threshold.index;
    }

    /**
     * Will queue a redraw of the bucket.
     * The redraw must be delayed until the elements have received their proper sizes.
     */
    redraw(): Promise<void> {
        this._evaluateVisualisationOptions();
        return new Promise<void>((resolve, reject) => {
            setTimeout(() => {
                try {
                    this._redrawInternal();
                    resolve();
                } catch (e) {
                    reject(e);
                }
            });
        });
    }

    /**
     * When a threshold related to a status has changed we updated which is selected and emit thos through the onChange event.
     *
     * @param thresholdId the id of the treshold that has changed
     * @param statusThreshold the object that is related to the thresholdId
     */
    _thresholdChange(thresholdId: string, statusThreshold: StatusThreshold): void {
        const selectedThreshold = this._statusThresholds.filter(st => st.id && st.index !== statusThreshold.index).map(st => {
            return this._getThresholdWithOrder(st.id, st.index);
        });
        if (thresholdId) {
            const changedThreshold = this._getThresholdWithOrder(thresholdId, statusThreshold.index);
            selectedThreshold.push(changedThreshold);
        }
        this._selectedThresholds = selectedThreshold;
        this.onChange.emit(this._selectedThresholds.map(th => this.mapToThreshold(th)));
        this.onSelectedThresholdsChange.emit(this._selectedThresholds);
    }

    private get _showProportionalThresholds(): boolean {
        return this._options.bucketMode === BUCKET_MODE.SHOW_THRESHOLDS_RELATIVE_WITH_VALUE
            && (this._thresholds.length > 0 || this._hasBucketInterval());
    }

    private _evaluateVisualisationOptions() {
        this._selectableThresholds = this._options.bucketMode === BUCKET_MODE.SHOW_STATUSES_AND_SELECT_THRESHOLDS
            && this._statuses.length > 0;
        this._requireThresholds = !this._options.noneSelection;
        this._disabled = this._options.disabled;
        this._bucketColumnWidth = this._selectableThresholds ? '50%' : '100%';
    }

    private _redrawInternal(): void {
        if (!this._native) {
            return;
        }
        this._bucketMeasures = this.getBucketMeasures(
            this._native,
            this._getSvgHeight(),
            this._showProportionalThresholds
        );

        this._createThresholdStatuses();
        if (this._svg) {
            this._updateSvg();
        } else {
            this._renderSvg();
        }
        this._renderBucket();
        this._displayErrors();
    }

    /**
     * Orders all selected threshold and check if wanted selectbox index is usable
     */
    private _getOrderedThresholdList(): Array<BucketThreshold> {
        const amountOfSelectBoxes = this._statusThresholds.length;
        const usedIndexes = [];

        return this._selectedThresholds.map((threshold: BucketThreshold) => {
            let order = threshold.order && threshold.order > amountOfSelectBoxes ? 0 : threshold.order;
            if (usedIndexes.indexOf(order) > -1) {
                order = this.findFreeSelectbox(usedIndexes, amountOfSelectBoxes);
            }
            usedIndexes.push(order);
            threshold.order = order;
            return threshold;
        });
    }

    private _getThresholdWithOrder(thresholdId: string, order: number): BucketThreshold {
        const foundThreshold = this._thresholds.find(threshold => threshold.id === thresholdId);
        const mappedThreshold = new BucketThreshold(foundThreshold);
        mappedThreshold.order = order;
        return mappedThreshold;
    }

    private _createThresholdStatuses(): void {
        this._statusThresholds = [];
        const statusSectionHeight = this._getStatusSectionHeight();
        for (let i = 0; i < this._amountOfSeperators(); i++) {
            const y = statusSectionHeight + statusSectionHeight * i + this._bucketMeasures.y;
            this._statusThresholds.push(new StatusThreshold(null, i, `${y}px`));
        }
    }

    /** Update the height of the bucket */
    private _updateSvg(): void {
        this._svg.transition().style('height', `${this._bucketMeasures.h + Constants.BUCKET_MEASURES.EXTRA_HEIGHT}px`);
    }


    /** Render the initial SVG container for drawings to be contained inside */
    private _renderSvg(): void {
        this._svg = D3.select(this._native)
            .append('svg')
            .style('width', '100%')
            .style('height', `${this._bucketMeasures.h + Constants.BUCKET_MEASURES.EXTRA_HEIGHT}px`);
    }

    /** Renders the bucket RECT and trigger methods to draw related drawings for bucket */
    private _renderBucket(): void {
        this._drawBucketBackground();
        if (this._options.bucketMode === BUCKET_MODE.SHOW_STATUSES_AND_SELECT_THRESHOLDS) {
            this._removeRelativeExternalValues();
            this._removeBucketInterval();
            if (this._statuses.length === 0) {
                this._drawZero();
                this._drawBucketLimits();
                this._drawBucketValues();
            } else {
                this._removeZero();
                this._removeBucketValues();

                this._setSelectedThresholds();
                this._drawBucketLimits();
                this._drawStatusesAndSeperators();
            }
        } else {
            this._drawRelativeExternalValues();
            this._drawZero();
            this._drawBucketLimits();
            this._drawBucketInterval();
            this._drawBucketValues();
            this._drawnExternalValues.forEach(drawnExternalValue => {
                drawnExternalValue.raise();
            });
        }
        this.moveAllTextsToFront();
    }

    private _drawBucketBackground(): void {
        const options = {
            x: this._bucketMeasures.x,
            y: this._bucketMeasures.y,
            w: this._bucketMeasures.w,
            h: this._bucketMeasures.h,
            fill: this._whitelabelService.getPropertyValue(COLORWHITELABEL.GRAY7)
        };
        if (!this._background) {
            this._background = this.drawRect(options);
        } else {
            this.moveRect(this._background, options);
        }
    }

    /** Draw min, max and zero in the bucket */
    private _drawBucketLimits(): void {
        this._drawMax();
        this._drawMin();
    }

    /** Draw max value of bucket if present */
    private _drawMax(): void {
        const hasMaxValue = this._bucketHasMaxValue();
        const text = hasMaxValue ? this._bucket.maxValue.toString() : 'Undefined';
        const lineOptions = {
            startX: this._bucketMeasures.x,
            startY: this._bucketMeasures.y,
            endX: this._getLineEnding(),
            endY: this._bucketMeasures.y,
            color: this._whitelabelService.getPropertyValue(COLORWHITELABEL.GRAY),
            dashed: !hasMaxValue
        };
        const textOptions = {
            x: this._getBucketCenter(),
            y: this._bucketMeasures.y - Constants.VALUES.MIN_MAX_MARGIN,
            text: text,
            class: hasMaxValue ? 'text' : 'text-undefined',
            createTooltip: (tooltipData: TooltipData) => this._displayTooltip(tooltipData),
            removeTooltip: () => this._hideTooltip()
        };

        if (!this._max) {
            const line = this.drawLine(lineOptions);
            const textBox = this.drawText(textOptions);
            this._max = new LimitData(line, textBox);
        } else {
            this.moveLine(this._max.line, lineOptions);
            this.moveText(this._max.text, textOptions);
            this._max.raise();
        }
    }

    /** Draw min value line and value on bucket */
    private _drawMin(): void {
        const hasMinValue = this._bucketHasMinValue();
        const bucketBottom = this._bucketMeasures.y + this._bucketMeasures.h;
        const text = hasMinValue ? this._bucket.minValue.toString() : 'Undefined';
        const lineOptions = {
            startX: this._bucketMeasures.x,
            startY: bucketBottom,
            endX: this._getLineEnding(),
            endY: bucketBottom,
            color: this._whitelabelService.getPropertyValue(COLORWHITELABEL.GRAY),
            dashed: !hasMinValue
        };
        const textOptions = {
            x: this._getBucketCenter(),
            y: this._bucketMeasures.y + this._bucketMeasures.h + Constants.VALUES.MIN_MAX_MARGIN,
            text: text,
            class: hasMinValue ? 'text' : 'text-undefined',
            createTooltip: (tooltipData: TooltipData) => this._displayTooltip(tooltipData),
            removeTooltip: () => this._hideTooltip()
        };

        if (!this._min) {
            const line = this.drawLine(lineOptions);
            const textBox = this.drawText(textOptions);
            this._min = new LimitData(line, textBox);
        } else {
            this.moveLine(this._min.line, lineOptions);
            this.moveText(this._min.text, textOptions);
            this._min.raise();
        }
    }

    private _drawZero(): void {
        const textData = this.getTextData('0');
        const height = textData.width + Constants.VALUES.ZERO_TEXT_MARGIN;
        const rawY = this._getY(BucketVisualisationComponent.ZERO);
        const y = this._adjustYValue(rawY, height * 0.5);
        const lineColor = this._whitelabelService.getPropertyValue(COLORWHITELABEL.GRAY3);
        const lineOption = {
            startX: this._bucketMeasures.x,
            endX: this._getLineEnding(),
            startY: y,
            endY: y,
            color: lineColor
        };
        const areaOption = {
            x: this._bucketMeasures.x - textData.width - Constants.VALUES.ZERO_TEXT_MARGIN,
            y: y - height * 0.5,
            w: height,
            h: height,
            fill: lineColor
        };
        const textOption = {
            x: this._bucketMeasures.x - (textData.width + Constants.VALUES.ZERO_TEXT_MARGIN) * 0.5,
            y: y,
            text: '0',
            class: 'text-zero',
            anchor: 'middle',
            removeOffset: true,
            createTooltip: (tooltipData: TooltipData) => this._displayTooltip(tooltipData),
            removeTooltip: () => this._hideTooltip()
        };

        if (!this._zero) {
            const line = this.drawLine(lineOption);
            const area = this.drawRect(areaOption);
            const textBox = this.drawText(textOption);
            this._zero = new LimitData(line, textBox, area);
        } else {
            this.moveLine(this._zero.line, lineOption);
            this.moveRect(this._zero.area, areaOption);
            this.moveText(this._zero.text, textOption);
            this._zero.raise();
        }
    }

    private _drawBucketValues(): void {
        this._removeStatuses();
        if (this._bucketHasActualValue()) {
            if (this._initialBucketValue && this._initialBucketValue.area) {
                this._initialBucketValue.area.remove();
                this._initialBucketValue.area = null;
            }
            this._actualBucketValue = this._drawActualValueArea();
        } else if (this._actualBucketValue) {
            this._removeActualValueArea();
        }
        if (this._bucketHasInitialValue()) {
            this._initialBucketValue = this._drawInitialValueArea();
        } else if (this._initialBucketValue) {
            this._removeInitialValueArea();
        }
    }

    private _drawActualValueArea(): BucketValueData {
        const textValue = this._bucket.actualValue.toString();
        const textData = this.getTextData(textValue);
        const textWidth = textData.width + Constants.VALUES.TEXT_MARGIN * 2;
        const x = this._getLineEnding() - textWidth * 0.5;
        const coordinates = this._getCoordinatesToFillValue(this._bucket.actualValue, x);
        const arrowCoordinates = this.getPolygonPointsForRightSideArrow(
            coordinates.y,
            this._bucketMeasures,
            textWidth
        );

        if (!this._actualBucketValue) {
            const area = this._fillArea(coordinates);
            const limit = this._drawLimit(coordinates, true);
            const arrow = this._drawArrow(arrowCoordinates);
            const text = this._drawArrowTextBox(coordinates, textValue, this._actualTooltipText);
            return new BucketValueData(limit, arrow, text, area);
        } else {
            this._animateArea(this._actualBucketValue.area, coordinates);
            this._animateLimit(this._actualBucketValue.limit, coordinates, true);
            this._animateArrow(this._actualBucketValue.arrow, arrowCoordinates);
            this._animateArrowTextBox(this._actualBucketValue.text, coordinates, textValue, this._actualTooltipText);
            this._actualBucketValue.raise();
            return this._actualBucketValue;
        }
    }

    private _drawInitialValueArea(): BucketValueData {
        const textValue = this._bucket.initialValue.toString();
        const textData = this.getTextData(textValue);
        const textWidth = textData.width + Constants.VALUES.TEXT_MARGIN * 2;
        const x = this._bucketMeasures.x + textWidth * 0.5;
        const coordinates = this._getCoordinatesToFillValue(this._bucket.initialValue, x);

        const arrowCoordinates = this.getPolygonPointsForLeftSideArrow(
            coordinates.y,
            this._bucketMeasures,
            textWidth
        );

        if (!this._initialBucketValue) {
            const area = this._actualBucketValue ? null : this._fillArea(coordinates);
            const limit = this._drawLimit(coordinates);
            const arrow = this._drawArrow(arrowCoordinates);
            const text = this._drawArrowTextBox(coordinates, textValue, this._initialTooltipText);
            return new BucketValueData(limit, arrow, text, area);
        } else {
            if (this._initialBucketValue.area) {
                this._animateArea(this._initialBucketValue.area, coordinates);
            }
            if (!this._actualBucketValue && !this._initialBucketValue.area) {
                this._initialBucketValue.area = this._fillArea(coordinates);
            }
            this._animateLimit(this._initialBucketValue.limit, coordinates);
            this._animateArrow(this._initialBucketValue.arrow, arrowCoordinates);
            this._animateArrowTextBox(this._initialBucketValue.text, coordinates, textValue, this._initialTooltipText);
            this._initialBucketValue.raise();
            return this._initialBucketValue;
        }
    }

    /** Draws if applicable either seperators for statuses only or with selectboxes */
    private _drawStatusesAndSeperators(): void {
        if (!this._selectableThresholds) {
            return;
        }
        if (this._drawnStatuses) {
            this._removeStatuses();
        }
        const statuses = this._drawStatuses();
        const separators = this._drawStatusSeperators();
        this._drawnStatuses = new StatusData(this._statuses, statuses, separators);
    }

    private _drawBucketInterval(): void {
        if (this._hasBucketInterval()) {
            const finiteUpper = this.interval.upperBound.isFinite();
            const finiteLower = this.interval.lowerBound.isFinite();
            const upperProcent = finiteUpper ? this._getProcentOfTotal(this.interval.upperBound.value.value) : 100;
            const lowerProcent = finiteLower ? this._getProcentOfTotal(this.interval.lowerBound.value.value) : 0;
            const rawUpperYPos = this._bucketMeasures.y
                + NumberHelper.getProcentValueOf(this._bucketMeasures.h, this.MAX_PROCENT - upperProcent);
            const rawLowerYPos = this._bucketMeasures.y
                + NumberHelper.getProcentValueOf(this._bucketMeasures.h, this.MAX_PROCENT - lowerProcent);

            const upperYPos = this._adjustYValue(rawUpperYPos, Constants.THRESHOLD.HEIGHT * 0.5);
            const lowerYPos = this._adjustYValue(rawLowerYPos, Constants.THRESHOLD.HEIGHT * 0.5);

            const upperBoundOptions: LineOptions = {
                startX: this._bucketMeasures.x,
                endX: this._bucketMeasures.x + this._bucketMeasures.w,
                startY: upperYPos,
                endY: upperYPos,
                dashed: !this.interval.upperBound.inclusive || !finiteUpper,
                color: this._whitelabelService.getPropertyValue(COLORWHITELABEL.BRAND_PRIMARY)
            };
            const lowerBoundOptions: LineOptions = {
                startX: this._bucketMeasures.x,
                endX: this._bucketMeasures.x + this._bucketMeasures.w,
                startY: lowerYPos,
                endY: lowerYPos,
                dashed: !this.interval.lowerBound.inclusive || !finiteLower,
                color: this._whitelabelService.getPropertyValue(COLORWHITELABEL.BRAND_PRIMARY)
            };
            const areaOptions = {
                points: [
                    this._bucketMeasures.x, upperYPos,
                    this._bucketMeasures.x + this._bucketMeasures.w, upperYPos,
                    this._bucketMeasures.x + this._bucketMeasures.w, lowerYPos,
                    this._bucketMeasures.x, lowerYPos
                ],
                class: 'range-area-value'
            };

            if (this._drawnBucketInterval) {
                this.moveLine(this._drawnBucketInterval.upperBound, upperBoundOptions);
                this.moveLine(this._drawnBucketInterval.lowerBound, lowerBoundOptions);
                this.movePolygon(this._drawnBucketInterval.area, areaOptions);
                this._drawnBucketInterval.raise();
            } else {
                const upperBound = this.drawLine(upperBoundOptions);
                const lowerBound = this.drawLine(lowerBoundOptions);
                const area = this.drawPolygon(areaOptions);
                this._drawnBucketInterval = new BucketIntervalData(upperBound, lowerBound, area);
            }
        } else {
            this._removeBucketInterval();
        }
    }

    /** Draws out the relative thresholds in relative position according to bucket values and threshold value */
    private _drawRelativeExternalValues(): void {
        const externalValueBlocks = this._getThresholdValues();

        if (this._hasBucketInterval()) {
            this._getBucketIntervalEndPointValues().forEach(endPointValue => externalValueBlocks.push(endPointValue));
        }

        const blocksToDraw = this._forkBlocks(externalValueBlocks);

        const previousDrawnExternalValues = this._drawnExternalValues;
        this._drawnExternalValues = [];

        previousDrawnExternalValues.forEach(drawnExternalValue => {
            const existingBlock = blocksToDraw.find(block => block.equals(drawnExternalValue.externalValueBlock));
            if (existingBlock) {
                this._drawnExternalValues.push(this._drawExternalValueBlock(existingBlock, drawnExternalValue));
            } else {
                drawnExternalValue.remove();
            }
        });
        blocksToDraw.forEach(block => {
            const existingBlock = previousDrawnExternalValues.find(externalValue => block.equals(externalValue.externalValueBlock));
            if (!existingBlock) {
                this._drawnExternalValues.push(this._drawExternalValueBlock(block));
            }
        });
    }

    private _drawExternalValueBlock(
        externalValueBlock: ExternalValueBlock,
        drawnExternalValueBlock?: ExternalValueBlockData
    ): ExternalValueBlockData {
        const onlyHighlights = externalValueBlock.externalValues.every(externalValue => externalValue.backgroundHighlight);
        const arrowCoordinates = this.getPolygonPointsForexternalValueBlock(externalValueBlock, this._bucketMeasures);
        const lineColor = this._whitelabelService.getPropertyValue(COLORWHITELABEL.GRAY3);
        const minLineOptions = {
            startY: Math.trunc(externalValueBlock.min.yPos),
            endY: Math.trunc(externalValueBlock.min.yPos),
            startX: this._bucketMeasures.x,
            endX: this._getLineEnding(),
            color: lineColor,
            dotted: true
        };
        const maxLineOptions = {
            startY: Math.trunc(externalValueBlock.max.yPos),
            endY: Math.trunc(externalValueBlock.max.yPos),
            startX: this._bucketMeasures.x,
            endX: this._getLineEnding(),
            color: lineColor,
            dotted: true
        };
        const forkAreaOptions = {
            x: this._bucketMeasures.x,
            y: Math.trunc(externalValueBlock.max.yPos),
            w: this._bucketMeasures.w,
            h: Math.trunc(externalValueBlock.min.yPos - externalValueBlock.max.yPos),
            fill: this._whitelabelService.getPropertyValue(COLORWHITELABEL.GRAY2)
        };
        const blockOptions = {
            points: arrowCoordinates,
            fill: onlyHighlights ? this._whitelabelService.getPropertyValue(COLORWHITELABEL.BRAND_PRIMARY) :
                this._whitelabelService.getPropertyValue(COLORWHITELABEL.C333333)
        };
        let minLine = null;
        let maxLine = null;
        let forkArea = null;

        if (!onlyHighlights) {
            minLine = drawnExternalValueBlock
                ? this.moveLine(drawnExternalValueBlock.minLine, minLineOptions)
                : this.drawLine(minLineOptions);
            if (externalValueBlock.isForked()) {
                maxLine = drawnExternalValueBlock
                    ? this.moveLine(drawnExternalValueBlock.maxLine, maxLineOptions)
                    : this.drawLine(maxLineOptions);
                forkArea = drawnExternalValueBlock
                    ? this.moveRect(drawnExternalValueBlock.area, forkAreaOptions)
                    : this.drawRect(forkAreaOptions);
            }
        }
        const block = drawnExternalValueBlock
            ? this.movePolygon(drawnExternalValueBlock.block, blockOptions)
            : this.drawPolygon(blockOptions);

        const externalValueData = this._createExternalValueData(
            externalValueBlock,
            drawnExternalValueBlock,
            onlyHighlights,
            arrowCoordinates);
        return new ExternalValueBlockData(externalValueBlock, block, externalValueData, minLine, maxLine, forkArea);
    }

    private _createExternalValueData(
        externalValueBlock: ExternalValueBlock,
        drawnExternalValueBlock: ExternalValueBlockData,
        onlyHighlights: boolean,
        arrowCoordinates: Array<number>
    ): Array<ExternalValueData> {
        const baseX = this._getLineEnding();
        const startOffset = externalValueBlock.isForked() ? Constants.THRESHOLD.FORK_PADDING : 0;
        const startY = externalValueBlock.minY + startOffset + Constants.THRESHOLD.HEIGHT * 0.5;
        const r = Constants.THRESHOLD.FORK_CIRCLE_RADIUS;
        const leftTextMargin = externalValueBlock.isForked() ? r * 2 + Constants.THRESHOLD.PADDING * 2 : Constants.THRESHOLD.PADDING;
        const textMaxWidth = (this._bucketMeasures.thresholdWidth - leftTextMargin - Constants.THRESHOLD.PADDING * 0.5);
        return externalValueBlock.externalValues.map((externalValue, index) => {
            const cy = Math.trunc(startY + Constants.THRESHOLD.HEIGHT * index);
            const dotColor = this._whitelabelService.getPropertyValue(COLORWHITELABEL.BASE_COLOR_INVERTED,
                {opacity: COLORWHITELABEL.OPAQUE_5});
            const hasName = externalValue.externalValue.name && externalValue.externalValue.name.length > 0;
            const prevExternalValueData = drawnExternalValueBlock
                ? drawnExternalValueBlock.externalValue.find(drawnExternalValue => drawnExternalValue.externalValue.equals(externalValue))
                : undefined;
            const dotOptions = {
                cx: baseX + r + Constants.THRESHOLD.PADDING,
                cy: cy,
                r: r,
                fill: dotColor
            };
            const nameOptions = {
                x: baseX + leftTextMargin,
                y: cy,
                removeOffset: true,
                text: externalValue.externalValue.name,
                class: 'text-external-value',
                anchor: 'start',
                maxWidth: textMaxWidth * 0.5,
                createTooltip: (tooltipData: TooltipData) => this._displayTooltip(tooltipData),
                removeTooltip: () => this._hideTooltip()
            };
            const valueOptions = {
                x: baseX + this._bucketMeasures.thresholdWidth - Constants.THRESHOLD.PADDING / 2,
                y: cy,
                removeOffset: true,
                text: externalValue.externalValue.value.toString(),
                class: 'text-external-value',
                anchor: 'end',
                maxWidth: hasName ? textMaxWidth * 0.5 : textMaxWidth,
                createTooltip: (tooltipData: TooltipData) => this._displayTooltip(tooltipData),
                removeTooltip: () => this._hideTooltip()
            };
            let highlightOptions = null;
            if (!onlyHighlights && externalValue.backgroundHighlight && externalValueBlock.externalValues.length > 1) {
                const highlightY = index === 0
                    ? arrowCoordinates[1]
                    : index === externalValueBlock.externalValues.length - 1
                        ? arrowCoordinates[3] - startOffset - Constants.THRESHOLD.HEIGHT
                        : cy - Constants.THRESHOLD.HEIGHT * 0.5;
                const highlightH = index === 0 || index === externalValueBlock.externalValues.length - 1
                    ? Constants.THRESHOLD.HEIGHT + startOffset
                    : Constants.THRESHOLD.HEIGHT;
                highlightOptions = {
                    x: baseX,
                    y: Math.trunc(highlightY),
                    h: Math.trunc(highlightH),
                    w: this._bucketMeasures.thresholdWidth,
                    fill: this._whitelabelService.getPropertyValue(COLORWHITELABEL.BRAND_PRIMARY)
                };
            }

            let dot = null;
            let forkChain = null;
            let highlight = null;
            if (externalValueBlock.isForked()) {
                dot = prevExternalValueData ? this.moveCircle(prevExternalValueData.dot, dotOptions) : this.drawCircle(dotOptions);
            }
            if (externalValueBlock.isForked() && index < externalValueBlock.externalValues.length - 1) {
                forkChain = this._drawForkChain(baseX + r + Constants.THRESHOLD.PADDING, cy, prevExternalValueData);
            }
            const name = prevExternalValueData ? this.moveText(prevExternalValueData.name, nameOptions) : this.drawText(nameOptions);
            const value = prevExternalValueData ? this.moveText(prevExternalValueData.value, valueOptions) : this.drawText(valueOptions);
            if (highlightOptions) {
                highlight = prevExternalValueData
                    ? this.moveRect(prevExternalValueData.highlight, highlightOptions)
                    : this.drawRect(highlightOptions);
            }
            return new ExternalValueData(externalValue, name, value, highlight, dot, forkChain);
        });
    }

    private _drawForkChain(x: number, y: number, prevValueData?: ExternalValueData): Array<D3Circle> {
        const startY = y + 4;
        const yStep = 3;
        const fillColor = this._whitelabelService.getPropertyValue(COLORWHITELABEL.BASE_COLOR_INVERTED,
            {opacity: COLORWHITELABEL.OPAQUE_5});

        const circle1Option = {
            cx: x,
            cy: startY + yStep * 1,
            r: 1.0,
            fill: fillColor
        };
        const circle2Option = {
            cx: x,
            cy: startY + yStep * 2,
            r: 1.0,
            fill: fillColor
        };
        const circle3Option = {
            cx: x,
            cy: startY + yStep * 3,
            r: 1.0,
            fill: fillColor
        };
        const circle1 = prevValueData ? this.moveCircle(prevValueData.chain[0], circle1Option) : this.drawCircle(circle1Option);
        const circle2 = prevValueData ? this.moveCircle(prevValueData.chain[1], circle2Option) : this.drawCircle(circle2Option);
        const circle3 = prevValueData ? this.moveCircle(prevValueData.chain[2], circle3Option) : this.drawCircle(circle3Option);
        return [circle1, circle2, circle3];
    }

    /**
     * Draws status seperators. Lines will be aligned with selectboxes.
     */
    private _drawStatusSeperators(): Array<D3Line> {
        const statusSectionHeight = this._getStatusSectionHeight();
        const lines: Array<D3Line> = [];
        for (let i = 0; i < this._amountOfSeperators(); i++) {
            const y = statusSectionHeight + statusSectionHeight * i + this._bucketMeasures.y;
            const startXWithThresholds = this._bucketMeasures.x - Constants.BUCKET_MEASURES.THRESHOLD_SPACE;
            const error = this._statusThresholds[i].error;
            lines.push(this.drawLine({
                startX: this._statuses.length > 1
                    ? startXWithThresholds
                    : this._bucketMeasures.x,
                startY: y,
                endX: this._statuses.length > 1
                    ? this._getLineEnding()
                    : this._bucketMeasures.x + this._bucketMeasures.w,
                endY: y,
                color: this._whitelabelService.getPropertyValue(
                    error && !this._disabled ? COLORWHITELABEL.SUCCESS : COLORWHITELABEL.GRAY3),
                dotted: true
            }));
        }
        return lines;
    }

    /** Draws the status values out on the bucket */
    private _drawStatuses(): Array<D3Text> {
        const statusSectionHeight = this._getStatusSectionHeight();
        return this._statuses
            .sort(this._sortStatuses.bind(this))
            .map((status, index) => {
                const y = statusSectionHeight / 2 + statusSectionHeight * index + this._bucketMeasures.y;
                return this.drawText({
                    x: this._getBucketCenter(),
                    y: y,
                    text: status.name,
                    class: 'status-text',
                    anchor: 'middle',
                    createTooltip: (tooltipData: TooltipData) => this._displayTooltip(tooltipData),
                    removeTooltip: () => this._hideTooltip()
                });
            });
    }

    private _fillArea(coordinates: FillCoordinates): D3Polygon {
        const points = [
            this._bucketMeasures.x, coordinates.y,
            this._bucketMeasures.x + this._bucketMeasures.w, coordinates.y,
            this._bucketMeasures.x + this._bucketMeasures.w, coordinates.y + coordinates.h,
            this._bucketMeasures.x, coordinates.y + coordinates.h
        ];
        return this.drawPolygon({
            points: points,
            class: 'bucket-value'
        });
    }

    private _animateArea(area: D3Polygon, coordinates: FillCoordinates): void {
        const points = [
            this._bucketMeasures.x, coordinates.y,
            this._bucketMeasures.x + this._bucketMeasures.w, coordinates.y,
            this._bucketMeasures.x + this._bucketMeasures.w, coordinates.y + coordinates.h,
            this._bucketMeasures.x, coordinates.y + coordinates.h
        ];
        this.movePolygon(area, {
            points: points,
            class: 'bucket-value'
        });
    }

    private _drawLimit(coordinates: FillCoordinates, dottedLimit?: boolean): D3Line {
        return this.drawLine({
            startX: this._bucketMeasures.x,
            startY: coordinates.y,
            endX: this._getLineEnding(),
            endY: coordinates.y,
            color: this._whitelabelService.getPropertyValue(COLORWHITELABEL.BRAND_PRIMARY),
            dotted: dottedLimit
        });
    }

    private _animateLimit(limit: D3Line, coordinates: FillCoordinates, dottedLimit?: boolean): void {
        this.moveLine(limit, {
            startX: this._bucketMeasures.x,
            startY: coordinates.y,
            endX: this._getLineEnding(),
            endY: coordinates.y,
            color: this._whitelabelService.getPropertyValue(COLORWHITELABEL.BRAND_PRIMARY),
            dotted: dottedLimit
        });
    }

    private _drawArrow(points: Array<number>): D3Polygon {
        return this.drawPolygon({
            points: points,
            fill: this._whitelabelService.getPropertyValue(COLORWHITELABEL.BRAND_PRIMARY)
        });
    }

    private _animateArrow(arrow: D3Polygon, points: Array<number>): void {
        this.movePolygon(arrow, {
            points: points,
            fill: this._whitelabelService.getPropertyValue(COLORWHITELABEL.BRAND_PRIMARY)
        });
    }

    private _drawArrowTextBox(coordinates: FillCoordinates, value: string, tooltip?: string): D3Text {
        return this.drawText({
            x: coordinates.x,
            removeOffset: true,
            y: coordinates.y,
            text: value.toString(),
            class: 'bucket-value-text',
            anchor: 'middle',
            tooltip: tooltip,
            createTooltip: (tooltipData: TooltipData) => this._displayTooltip(tooltipData),
            removeTooltip: () => this._hideTooltip()
        });
    }

    private _animateArrowTextBox(text: D3Text, coordinates: FillCoordinates, value: string, tooltip?: string): void {
        this.moveText(text, {
            x: coordinates.x,
            removeOffset: true,
            y: coordinates.y,
            text: value.toString(),
            class: 'bucket-value-text',
            anchor: 'middle',
            tooltip: tooltip,
            createTooltip: (tooltipData: TooltipData) => this._displayTooltip(tooltipData),
            removeTooltip: () => this._hideTooltip()
        });
    }

    private _getThresholdValues(): Array<ExternalValueBlock> {
        return this._thresholds.filter(threshold => Boolean(threshold.value))
            .filter(threshold => isFinite(+threshold.value.value))
            .map(threshold => {
                const procent = this._getProcentOfTotal(threshold.value.value);
                const rawY = this._bucketMeasures.y + NumberHelper.getProcentValueOf(this._bucketMeasures.h, this.MAX_PROCENT - procent);
                const yPos = this._adjustYValue(rawY, Constants.THRESHOLD.HEIGHT * 0.5);
                return ExternalValueBlock.fromThreshold(threshold, yPos, this._bucketMeasures.h);
            });
    }

    private _getBucketIntervalEndPointValues(): Array<ExternalValueBlock> {
        const externalValueBlocks = [];
        const upperBound = this.interval.upperBound;
        if (upperBound.isFinite()) {
            const procent = this._getProcentOfTotal(upperBound.value.value);
            const rawY = this._bucketMeasures.y
                + NumberHelper.getProcentValueOf(this._bucketMeasures.h, this.MAX_PROCENT - procent);
            const yPos = this._adjustYValue(rawY, Constants.THRESHOLD.HEIGHT * 0.5);
            externalValueBlocks.push(ExternalValueBlock.fromIntervalEndPoint(upperBound, yPos, this._bucketMeasures.h));
        } else {
            const procent = 100;
            const rawY = this._bucketMeasures.y
                + NumberHelper.getProcentValueOf(this._bucketMeasures.h, this.MAX_PROCENT - procent);
            const yPos = this._adjustYValue(rawY, Constants.THRESHOLD.HEIGHT * 0.5);
            const positiveInfinity = new EndPoint(upperBound);
            positiveInfinity.value = new BucketValue({
                value: this._bucketHasMaxValue() ? this._bucket.maxValue.value : Infinity,
                displayValue: 'Undefined'
            });
            externalValueBlocks.push(ExternalValueBlock.fromIntervalEndPoint(positiveInfinity, yPos, this._bucketMeasures.h));
        }
        const lowerBound = this.interval.lowerBound;
        if (lowerBound.isFinite()) {
            const procent = this._getProcentOfTotal(lowerBound.value.value);
            const rawY = this._bucketMeasures.y
                + NumberHelper.getProcentValueOf(this._bucketMeasures.h, this.MAX_PROCENT - procent);
            const yPos = this._adjustYValue(rawY, Constants.THRESHOLD.HEIGHT * 0.5);
            externalValueBlocks.push(ExternalValueBlock.fromIntervalEndPoint(lowerBound, yPos, this._bucketMeasures.h));
        } else {
            const procent = 0;
            const rawY = this._bucketMeasures.y
                + NumberHelper.getProcentValueOf(this._bucketMeasures.h, this.MAX_PROCENT - procent);
            const yPos = this._adjustYValue(rawY, Constants.THRESHOLD.HEIGHT * 0.5);
            const negativeInfinity = new EndPoint(lowerBound);
            negativeInfinity.value = new BucketValue({
                value: this._bucketHasMinValue() ? this._bucket.minValue.value : -Infinity,
                displayValue: 'Undefined'
            });
            externalValueBlocks.push(ExternalValueBlock.fromIntervalEndPoint(negativeInfinity, yPos, this._bucketMeasures.h));
        }
        return externalValueBlocks;
    }

    private _getThresholdWithHighestValue(): BucketThreshold {
        if (this._thresholds.length > 1) {
            return this._thresholds.reduce((prev, curr) => {
                return prev.value.value >
                    curr.value.value
                    ? prev
                    : curr;
            });
        } else {
            return this._thresholds[0];
        }
    }

    private _getThresholdWithLowestValue(): BucketThreshold {
        if (this._thresholds.length > 1) {
            return this._thresholds.reduce((prev, curr) => {
                return prev.value.value <
                    curr.value.value
                    ? prev
                    : curr;
            });
        } else {
            return this._thresholds[0];
        }
    }

    /** Calculates the height an object should have in the bucket */
    private _getHeight(value: BucketValue): number {
        const procent = this._getProcentOfTotal(Number(value.value));
        return NumberHelper.getProcentValueOf(this._bucketMeasures.h, procent);
    }

    /** Calculates the Y position for an arrow inside the bucket */
    private _getY(value: BucketValue): number {
        const procent = this._getProcentOfTotal(Number(value.value));
        return this._bucketMeasures.y +
            NumberHelper.getProcentValueOf(this._bucketMeasures.h, this.MAX_PROCENT - procent);
    }

    private _getCoordinatesToFillValue(value: BucketValue, x: number): FillCoordinates {
        const arrowHalfHeight = Constants.VALUES.ARROW_HEIGHT * 0.5;
        const rawY = Math.trunc(this._getY(value));
        const y = this._adjustYValue(rawY, arrowHalfHeight);
        const h = this._getHeight(value) - (y - rawY);
        return {
            y: y,
            h: h,
            x: x
        };
    }

    private _forkBlocks(externalValues: Array<ExternalValueBlock>): Array<ExternalValueBlock> {
        for (let i = 0; i < externalValues.length; i++) {
            for (let j = i + 1; j < externalValues.length; j++) {
                if (externalValues[i].isIntersectingWith(externalValues[j]) || externalValues[j].isIntersectingWith(externalValues[i])) {
                    const th1 = externalValues.splice(j, 1);
                    externalValues[i] = th1[0].merge(externalValues[i]);
                    return this._forkBlocks(externalValues);
                }
            }
        }
        return externalValues;
    }

    /**
     * Order statuses according to sort order
     * @param x - First status
     * @param y - Second status
     */
    private _sortStatuses(x: Status, y: Status): number {
        if (this._options.statusOrder === STATUS_ORDER.DESCENDING) {
            return x.orderIndex > y.orderIndex
                ? -1
                : x.orderIndex < y.orderIndex
                    ? 1
                    : 0;
        } else {
            return x.orderIndex < y.orderIndex
                ? -1
                : x.orderIndex > y.orderIndex
                    ? 1
                    : 0;
        }
    }

    /** Calculates the status section height */
    private _getStatusSectionHeight(): number {
        return this._bucketMeasures.h / this._statuses.length;
    }

    /** Check if bucket has max value set */
    private _bucketHasMaxValue(): boolean {
        return Boolean(this._bucket && this._bucket.hasMaxValue());
    }

    /** Check if bucket has min value set */
    private _bucketHasMinValue(): boolean {
        return Boolean(this._bucket && this._bucket.hasMinValue());
    }

    /** Check if bucket has initial value set */
    private _bucketHasInitialValue(): boolean {
        return Boolean(this._bucket && this._bucket.hasInitialValue());
    }

    /** Check if bucket has actual value set */
    private _bucketHasActualValue(): boolean {
        return Boolean(this._bucket && this._bucket.hasActualValue());
    }

    /** Check if bucket has an interval set */
    private _hasBucketInterval(): boolean {
        return Boolean(this.interval);
    }

    /** Gets the line ending, on the right hand side of the bucket */
    private _getLineEnding(): number {
        return this._bucketMeasures.x + this._bucketMeasures.w;
    }

    /** Returns the center X position of the visual bucket */
    private _getBucketCenter(): number {
        return this._bucketMeasures.x + (this._bucketMeasures.w - 35) / 2;
    }

    /** Get height that svg has to have, dynamic height if amount of statuses is more then MAX_STATUSES_FOR_STATIC */
    private _getSvgHeight(): number {
        const customHeight = this._options.bucketHeight
            ? Math.max(this._options.bucketHeight, Constants.BUCKET_MEASURES.MIN_HEIGHT)
            : Constants.BUCKET_MEASURES.MIN_DEFAULT_HEIGHT;
        if (this._options.bucketMode === BUCKET_MODE.SHOW_THRESHOLDS_RELATIVE_WITH_VALUE || this._statuses.length === 0) {
            return customHeight;
        } else if (this._statuses.length < this.MAX_STATUSES_FOR_STATIC) {
            return Constants.BUCKET_MEASURES.MIN_DEFAULT_HEIGHT;
        } else {
            return this._statuses.length * Constants.BUCKET_MEASURES.STATUS_SECTION_HEIGHT;
        }
    }

    /** Get amount of seperators needed to be drawn */
    private _amountOfSeperators(): number {
        return this._statuses.length - 1;
    }

    /** Add error marking and message on dropdowns if applicable */
    private _displayErrors(): void {
        if (this._disabled) {
            this._statusThresholds.forEach(statusThreshold => statusThreshold.error = null);
        } else if (this._thresholdErrors.length > 0) {
            this._statusThresholds.forEach(statusThreshold => {
                const error = this._thresholdErrors.find(thresholdError => thresholdError.thresholdId === statusThreshold.id);
                statusThreshold.error = error ? error.message : null;
            });
        } else if (this.error && Array.isArray(this.error.thresholdIds)) {
            this._statusThresholds.forEach(statusThreshold => {
                const hasError = this.error.thresholdIds.some(id => id === statusThreshold.id);
                statusThreshold.error = hasError ? this.error.message : null;
            });
        }
    }

    /** Goes over all selectboxes and set the applicable selected threshold and selected value */
    private _setSelectedThresholds(): void {
        this._getOrderedThresholdList()
            .sort(this.sortThresholdsOnOrder)
            .forEach((threshold: BucketThreshold) => {
                if (!this._statusThresholds[threshold.order]) {
                    return;
                }
                this._statusThresholds[threshold.order].id = threshold.id;
            });
        this._displayErrors();
    }

    /** @private */
    _getMaxValue(): number {
        let maxValue = null;
        const maxThreshold = this._getThresholdWithHighestValue();
        maxValue = maxThreshold && maxThreshold.value ? Math.max(maxValue, maxThreshold.value.value) : maxValue;

        if (this._bucketHasMaxValue()) {
            maxValue = Math.max(maxValue, this._bucket.maxValue.value);
        }
        if (this._bucketHasInitialValue()) {
            maxValue = Math.max(maxValue, this._bucket.initialValue.value);
        }
        if (this._bucketHasActualValue()) {
            maxValue = Math.max(maxValue, this._bucket.actualValue.value);
        }
        if (this._bucketHasMinValue()) {
            maxValue = Math.max(maxValue, this._bucket.minValue.value);
        }
        if (this._hasBucketInterval() && this.interval.upperBound.isFinite()) {
            if (this.interval.lowerBound.isFinite()) {
                maxValue = Math.max(maxValue,
                    Math.max(
                        this.interval.lowerBound.value.value,
                        this.interval.upperBound.value.value));
            } else {
                maxValue = Math.max(maxValue, this.interval.upperBound.value.value);
            }
        }
        return Math.max(0, maxValue);
    }

    /** @private */
    _getMinValue(): number {
        let minValue = null;
        const minThreshold = this._getThresholdWithLowestValue();
        minValue = minThreshold && minThreshold.value ? Math.min(minValue, minThreshold.value.value) : minValue;

        if (this._bucketHasMinValue()) {
            minValue = Math.min(minValue, this._bucket.minValue.value);
        }
        if (this._bucketHasInitialValue()) {
            minValue = Math.min(minValue, this._bucket.initialValue.value);
        }
        if (this._bucketHasActualValue()) {
            minValue = Math.min(minValue, this._bucket.actualValue.value);
        }
        if (this._bucketHasMaxValue()) {
            minValue = Math.min(minValue, this._bucket.maxValue.value);
        }
        if (this._hasBucketInterval() && this.interval.lowerBound.isFinite()) {
            if (this.interval.upperBound.isFinite()) {
                minValue = Math.min(minValue,
                    Math.min(
                        this.interval.lowerBound.value.value,
                        this.interval.upperBound.value.value));
            } else {
                minValue = Math.min(minValue, this.interval.lowerBound.value.value);
            }
        }
        return Math.min(0, minValue);
    }

    /**
     * Returns how much procentage the value is of the bucket
     * @param value - Value to check
     */
    _getProcentOfTotal(value: number): number {
        const maxValue = this._bucketHasMaxValue() ? +this._bucket.maxValue.value : +this._getMaxValue();
        const minValue = this._bucketHasMinValue() ? +this._bucket.minValue.value : +this._getMinValue();

        const totalValue = Math.abs(maxValue - minValue);
        const normalizedValue = value - Math.min(minValue, maxValue);
        let procentValue = (normalizedValue / totalValue) * 100;

        if (!this._bucketHasMaxValue() && !this._bucketHasMinValue()) {
            if (value === 0) {
                return 50;
            } else if (value > 0) {
                return procentValue * 0.4 + 50;
            } else {
                return procentValue * 0.4 + 10;
            }
        } else if (!this._bucketHasMinValue()) {
            if (totalValue === 0) {
                if (value === maxValue) {
                    return 100;
                } else {
                    return value < maxValue ? -100 : 200;
                }
            }
            procentValue = procentValue * 0.9 + 10;
            return procentValue;
        } else if (!this._bucketHasMaxValue()) {
            if (totalValue === 0) {
                if (value === minValue) {
                    return 0;
                } else {
                    return value < maxValue ? -100 : 200;
                }
            }
            procentValue = procentValue * 0.9;
            return procentValue;
        } else {
            if (totalValue === 0) {
                if (value === maxValue) {
                    return 100;
                } else {
                    return value < maxValue ? -100 : 200;
                }
            }
            if (this._bucket.minValue.value > this._bucket.maxValue.value) {
                return 0;
            }
            return procentValue;
        }
    }

    /**
     * Adjust the Y value if it would span outside the visual part of the bucket
     * @private
     */
    _adjustYValue(rawY: number, objectHalfHeight: number) {
        if (rawY < objectHalfHeight) {
            return Math.trunc(objectHalfHeight);
        } else if (rawY > this._bucketMeasures.h + Constants.BUCKET_MEASURES.EXTRA_HEIGHT - objectHalfHeight) {
            return Math.trunc(this._bucketMeasures.h + Constants.BUCKET_MEASURES.EXTRA_HEIGHT - objectHalfHeight);
        } else {
            return Math.trunc(rawY);
        }
    }

    private _removeActualValueArea(): void {
        if (this._actualBucketValue) {
            this._actualBucketValue.remove();
            this._actualBucketValue = null;
        }
    }

    private _removeInitialValueArea(): void {
        if (this._initialBucketValue) {
            this._initialBucketValue.remove();
            this._initialBucketValue = null;
        }
    }

    private _removeBucketValues(): void {
        this._removeActualValueArea();
        this._removeInitialValueArea();
    }

    private _removeZero(): void {
        if (this._zero) {
            this._zero.remove();
            this._zero = null;
        }
    }

    private _removeRelativeExternalValues(): void {
        if (this._drawnExternalValues.length) {
            this._drawnExternalValues.forEach(drawnExternalValue => drawnExternalValue.remove());
            this._drawnExternalValues = [];
        }
    }

    private _removeStatuses(): void {
        if (this._drawnStatuses && this._drawnStatuses.statuses.length > 0) {
            this._drawnStatuses.remove();
            this._drawnStatuses = null;
        }
    }

    private _removeBucketInterval(): void {
        if (this._drawnBucketInterval) {
            this._drawnBucketInterval.remove();
            this._drawnBucketInterval = null;
        }
    }

    /**
     * Responsible to create and position the tooltip relative to where the text element is in the bucket component
     */
    private _displayTooltip(tooltipData: TooltipData): void {
        this._tooltipData.text = tooltipData.text;
        this._tooltipData.textBox = tooltipData.textBox;
        if (this._tooltipTimeout !== null) {
            clearTimeout(this._tooltipTimeout);
            this._tooltipTimeout = null;
        }
        this._tooltipTimeout = setTimeout(() => {
            this._tooltipTimeout = null;
            const bucketRect = this.bucketTooltip.nativeElement.getBoundingClientRect();
            const halfWidth = bucketRect.width * 0.5;
            const left = tooltipData.left - halfWidth;
            this._tooltipData.top = tooltipData.top;
            this._tooltipData.left = Math.min(Math.max(left, 0), this._native.getBoundingClientRect().width - bucketRect.width);
            this._tooltipData.show();
        }, 0);
    }

    private _hideTooltip(): void {
        this._tooltipData.hide();
    }

    private mapToThreshold(threshold: BucketThreshold): Threshold {
        const value = new ValueWithUnit({
            value: threshold.value.value,
            unit: undefined
        });
        return new Threshold({
            id: threshold.id,
            name: threshold.name,
            order: threshold.order,
            value: value,
            valueInBucketUnit: value
        });
    }
}
