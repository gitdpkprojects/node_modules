import { ComponentFactoryResolver, ComponentRef, ElementRef, Injectable, Renderer, Renderer2 } from '@angular/core';
import { ComponentType } from '../../core/interfaces/component-type.interface';
import { OVERLAY_CONTEXT } from '../overlay/overlay.constants';
import { OverlayService } from '../overlay/overlay.service';
import { DrawerComponent } from './drawer.component';
import { AppHeaderService } from '../app-header/app-header.service';
import { DRAWER_CONTEXT, DRAWER_POSITION } from '../../core/constants/drawer.constants';
import { IDrawerContent } from '../../core/interfaces/drawer-content.interface';
import { MultiDrawerComponent } from './multi-drawer/multi-drawer.component';
import { ANIMATION } from '../../core/constants/animation.constants';
import { IMultiDrawerContent } from '../../core/interfaces/multi-drawer-content.interface';
import { FocusShiftBaseComponent } from '../modal/focus-shift/focus-shift-base.component';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../core/classes';
import { Subject } from 'rxjs';

@Injectable()
@UnSub()
export class DrawerService {
    private _timeout: any;
    private _fixWidthAndMarginListeners: Map<IDrawerContent, Function> = new Map<IDrawerContent, Function>();
    private _fixWidthAndMarginForMultiDrawerListeners: Map<IDrawerContent, Function> = new Map<IDrawerContent, Function>();
    private _subscriptions: Array<Subscription> = [];

    readonly toggleDrawer$ = new Subject<boolean>();
    constructor(private _componentFactoryResolver: ComponentFactoryResolver,
        private _overlayService: OverlayService,
        private _appHeaderService: AppHeaderService) {
    }

    /** @deprecated use createMultiDrawer instead **/
    createDrawer<C extends IDrawerContent>
        (componentType: ComponentType<C>,
        context: DRAWER_CONTEXT = DRAWER_CONTEXT.APPLICATION,
        componentFactoryResolver: ComponentFactoryResolver = this._componentFactoryResolver): Promise<ComponentRef<DrawerComponent<C>>> {
        return new Promise((resolve) => {
            const factory = componentFactoryResolver.resolveComponentFactory(DrawerComponent);
            const componentRef = this._overlayService.getOverlay(OVERLAY_CONTEXT.ROOT).createComponent(factory);
            componentRef.instance.componentFactoryResolver = componentFactoryResolver;
            componentRef.instance.zIndex = this._overlayService.zIndex;
            componentRef.instance.setDrawerContentComponent<C>(componentType);
            componentRef.instance.drawerContext = context;
            componentRef.instance.drawerPosition = componentRef.instance.outputComponent.drawerPosition > -1 ?
                componentRef.instance.outputComponent.drawerPosition : DRAWER_POSITION.RIGHT;
            if (componentRef.instance.outputComponent.drawerWidth !== undefined) {
                componentRef.instance.width = componentRef.instance.outputComponent.drawerWidth;
            }
            componentRef.instance.show();
            resolve(componentRef);
        });
    }

    /**
     * Creates an and returns MultiDrawer promise
     * @param {FocusShiftBaseComponent} focusShift
     * @param {Array<any>} drawers
     * @param {DRAWER_CONTEXT} context
     * @param {ComponentFactoryResolver} componentFactoryResolver
     * @returns {Promise<ComponentRef<MultiDrawerComponent>>}
     */
    createMultiDrawer(
        focusShift: FocusShiftBaseComponent,
        drawers: Array<ComponentType<IMultiDrawerContent>>,
        context: DRAWER_CONTEXT = DRAWER_CONTEXT.APPLICATION,
        componentFactoryResolver: ComponentFactoryResolver
    ): Promise<ComponentRef<MultiDrawerComponent>> {
        return new Promise((resolve) => {
            const factory = componentFactoryResolver.resolveComponentFactory(MultiDrawerComponent);
            const componentRef = this._overlayService.getOverlay(OVERLAY_CONTEXT.ROOT).createComponent(factory);
            const drawerInstance = <MultiDrawerComponent>componentRef.instance;
            drawerInstance.componentFactoryResolver = componentFactoryResolver;
            drawerInstance.zIndex = this._overlayService.zIndex;
            drawerInstance.drawerContext = context;
            this._fixWidthAndMarginForMultiDrawerListeners.set(componentRef.instance,
                focusShift.renderer.listen('window', 'resize', () => {
                    this.fixWidthAndMarginForMultiDrawer(drawerInstance, focusShift.renderer, focusShift.element);
                }));
            this._subscriptions.push(componentRef.instance.toggled.subscribe(() => {
                this.fixWidthAndMarginForMultiDrawer(drawerInstance, focusShift.renderer, focusShift.element, true);
            }));
            this.fixWidthAndMarginForMultiDrawer(drawerInstance, focusShift.renderer, focusShift.element, true);
            let i = 0;
            drawers.forEach((componentType) => {
                componentRef.instance.addDrawerContentComponent(componentType).then((component: any) => {
                    if (i === 0) {
                        drawerInstance.showDrawer(component);
                        drawerInstance.drawerPosition = component.drawerPosition !== undefined ?
                            component.drawerPosition : DRAWER_POSITION.LEFT;
                    }
                    i++;
                    if (i === drawers.length) {
                        drawerInstance.show();
                        resolve(componentRef);
                    }
                });
            });
        });
    }

    /**
     * Gets the application drawer if present
     * @returns {HTMLElement|null}
     */
    getApplicationDrawer(): HTMLElement {
        return <HTMLElement>document.querySelector('.drawer-context-application');
    }

    /**
     * Create the application drawer
     * @param componentType
     * @param hostElementRef
     * @param hostRenderer
     * @param componentFactoryResolver
     * @returns Promise<ComponentRef<DrawerComponent<C>>>
     */
    /** @deprecated use createApplicationMultiDrawer instead **/
    createApplicationDrawer<C extends IDrawerContent | any>(
        componentType: ComponentType<C>,
        hostElementRef: ElementRef,
        hostRenderer: Renderer2 | Renderer | any,
        componentFactoryResolver: ComponentFactoryResolver = this._componentFactoryResolver
    ): Promise<ComponentRef<DrawerComponent<C>>> {
        return new Promise((resolve) => {
            this.createDrawer<C>(componentType, DRAWER_CONTEXT.APPLICATION, componentFactoryResolver)
                .then((componentRef: ComponentRef<DrawerComponent<C>>) => {
                    this._appHeaderService.setStickyZIndex(componentRef.instance.zIndex + 5);
                    this.fixWidthAndMargin(componentRef.instance.width, hostRenderer, hostElementRef);
                    if (typeof(hostRenderer.setStyle) !== 'undefined') {
                        // Renderer2 API
                        this._fixWidthAndMarginListeners.set(componentRef.instance, hostRenderer.listen('window', 'resize', () => {
                            this.fixWidthAndMargin(componentRef.instance.width, hostRenderer, hostElementRef);
                        }));
                    } else {
                        // Renderer API
                        console.warn('Deprecation warning! Use Renderer2 with createApplicationDrawer');
                        this._fixWidthAndMarginListeners.set(componentRef.instance, hostRenderer.listenGlobal('window', 'resize', () => {
                            this.fixWidthAndMargin(componentRef.instance.width, hostRenderer, hostElementRef);
                        }));
                    }
                    resolve(componentRef);
                });
        });
    }

    fixWidthAndMargin(drawerWidth: number, hostRenderer: Renderer2 | Renderer | any, hostElementRef: ElementRef): void {

        if (typeof(hostRenderer.setStyle) !== 'undefined') {
            // Renderer2 API
            hostRenderer.setStyle(hostElementRef.nativeElement, 'transition', `all 500ms ${ANIMATION.EASE_IN_OUT_QUINT}`);
            const marginLeft = `${drawerWidth}px`;
            hostRenderer.setStyle(hostElementRef.nativeElement, 'width', `calc(100% - ${drawerWidth}px)`);
            hostRenderer.setStyle(hostElementRef.nativeElement, 'marginLeft', `${marginLeft}`);
        } else {
            console.warn('Deprecation warning! Use Renderer2 when creating drawer.');
            // Renderer API
            hostRenderer.setElementStyle(hostElementRef.nativeElement, 'transition', `all 500ms ${ANIMATION.EASE_IN_OUT_QUINT}`);
            const marginLeft = `${drawerWidth}px`;
            hostRenderer.setElementStyle(hostElementRef.nativeElement, 'width', `calc(100% - ${drawerWidth}px)`);
            hostRenderer.setElementStyle(hostElementRef.nativeElement, 'marginLeft', `${marginLeft}`);
        }
    }

    /**
     * Fixing width and margins for our multi drawer. Will get called on creation and when resizing the screen.
     * We call this function with transition=true when we toggle, otherwise transition is false and then we temporarily
     * remove all transitions to prohibit ugly glitches when resizing.
     * @param {MultiDrawerComponent} drawerInstance
     * @param {Renderer2 | any} hostRenderer
     * @param {ElementRef} hostElementRef
     * @param {boolean} transition
     */
    fixWidthAndMarginForMultiDrawer(drawerInstance: MultiDrawerComponent, hostRenderer: Renderer2 | any, hostElementRef: ElementRef,
        transition: boolean = false): void {
        if (typeof(hostRenderer.setStyle) !== 'undefined') {
            // Renderer2 API
            // make sure we don't have any CSS transitions
            if (!transition) {
                hostRenderer.setStyle(hostElementRef.nativeElement, 'transition', `none`);
            }
            const width = drawerInstance.calculatedWidth;
            const marginLeft = `${width}px`;
            // css for in-application Drawer
            if (drawerInstance.drawerContext === DRAWER_CONTEXT.APPLICATION) {
                hostRenderer.addClass(hostElementRef.nativeElement, 'drawer-left');
                hostRenderer.setStyle(hostElementRef.nativeElement, 'width', `calc(100% - ${width}px)`);
                hostRenderer.setStyle(hostElementRef.nativeElement, 'marginLeft', marginLeft);
            } else if (drawerInstance.drawerContext === DRAWER_CONTEXT.FOCUS_SHIFT) {
                // css for Focus shift Drawer
                const hostElementDrawerCssClass =
                    drawerInstance.drawerPosition === DRAWER_POSITION.LEFT ?
                        'focus-shift-drawer-left' :
                        'focus-shift-drawer-right';
                hostRenderer.addClass(
                    hostElementRef.nativeElement, hostElementDrawerCssClass);
                hostRenderer.setStyle(hostElementRef.nativeElement, 'width', `calc(100% - ${width}px)`);
                const position = drawerInstance.drawerPosition === DRAWER_POSITION.LEFT ? 'left' : 'right';
                hostRenderer.setStyle(hostElementRef.nativeElement, position, `${width}px`);
            }
            // remove our temporary transition=none css
            if (!transition) {
                hostRenderer.removeStyle(hostElementRef.nativeElement, 'transition');
            }
        } else {
            // Renderer API
            // ToDo this part will be removed later
            console.warn('Deprecation warning! Use Renderer2 in DrawerService');
            if (!transition) {
                hostRenderer.setElementStyle(hostElementRef.nativeElement, 'transition', `none`);
            }
            const width = drawerInstance.calculatedWidth;
            const marginLeft = `${width}px`;
            // css for in-application Drawer
            if (drawerInstance.drawerContext === DRAWER_CONTEXT.APPLICATION) {
                hostRenderer.setElementStyle(hostElementRef.nativeElement, 'width', `calc(100% - ${width}px)`);
                hostRenderer.setElementStyle(hostElementRef.nativeElement, 'marginLeft', marginLeft);
            } else if (drawerInstance.drawerContext === DRAWER_CONTEXT.FOCUS_SHIFT) {
                // css for Focus shift Drawer
                hostRenderer.setElementStyle(hostElementRef.nativeElement, 'width', `calc(100% - ${width}px)`);
                const position = drawerInstance.drawerPosition === DRAWER_POSITION.LEFT ? 'left' : 'right';

                hostRenderer.setElementStyle(hostElementRef.nativeElement, position, `${width}px`);
            }
            // remove our temporary transition=none css
            if (!transition) {
                hostRenderer.setElementStyle(hostElementRef.nativeElement, 'transition', null);
            }
        }
    }

    /**
     * Creates an and returns MultiDrawer promise
     * @param hostElementRef
     * @param hostRenderer
     * @param componentFactoryResolver
     * @return {Promise<ComponentRef<MultiDrawerComponent>>}
     */
    createApplicationMultiDrawer(
        hostElementRef: ElementRef,
        hostRenderer: Renderer2,
        componentFactoryResolver: ComponentFactoryResolver
    ): Promise<ComponentRef<MultiDrawerComponent>> {
        // Values that are specific for the application drawer.
        const context: DRAWER_CONTEXT = DRAWER_CONTEXT.APPLICATION;
        const drawerPosition: DRAWER_POSITION = DRAWER_POSITION.LEFT;
        const promise: Promise<ComponentRef<MultiDrawerComponent>> = new Promise((resolve) => {
            const factory = componentFactoryResolver.resolveComponentFactory(MultiDrawerComponent);
            const componentRef = this._overlayService.getOverlay(OVERLAY_CONTEXT.APP).createComponent(factory);
            const drawerInstance = <MultiDrawerComponent>componentRef.instance;
            drawerInstance.componentFactoryResolver = componentFactoryResolver;
            drawerInstance.drawerContext = context;
            drawerInstance.drawerPosition = drawerPosition;
            drawerInstance.zIndex = 9;
            this.fixWidthAndMarginForMultiDrawer(drawerInstance, hostRenderer, hostElementRef, true);
            this._fixWidthAndMarginForMultiDrawerListeners.set(componentRef.instance,
                hostRenderer.listen('window', 'resize', () => {
                    this.fixWidthAndMarginForMultiDrawer(drawerInstance, hostRenderer, hostElementRef);
                }));
            this._subscriptions.push(componentRef.instance.toggled.subscribe(() => {
                this.fixWidthAndMarginForMultiDrawer(drawerInstance, hostRenderer, hostElementRef, true);
            }));
            resolve(componentRef);
        });
        return promise;
    }

    /**
     * Removes a drawer from the DOM.
     * @param {ComponentRef<any>} componentRef
     * @param {Renderer2} renderer
     * @param {ElementRef} hostElementRef
     */
    destroyDrawer(componentRef: ComponentRef<any>, renderer?: Renderer2 | Renderer | any, hostElementRef?: ElementRef): void {
        clearTimeout(this._timeout);
        if (!componentRef) {
            return;
        }
        // will remove listeners
        const drawerListener = this._fixWidthAndMarginListeners.get(componentRef.instance);
        if (typeof (drawerListener) !== 'undefined') {
            drawerListener();
            this._fixWidthAndMarginListeners.delete(componentRef.instance);
        }
        const multiDrawerListener = this._fixWidthAndMarginForMultiDrawerListeners.get(componentRef.instance);
        if (typeof (multiDrawerListener) !== 'undefined') {
            multiDrawerListener();
            this._fixWidthAndMarginForMultiDrawerListeners.delete(componentRef.instance);
        }
        componentRef.destroy();
        // TODO: Listen for animation stop (then remove overflow-x-hidden class)
        if (!renderer) {
            // TODO: Add this warning after we use Renderer2 on all places
            // console.warn('Deprecation warning! Use Renderer2 in DrawerService.destroyDrawer');
        } else {
            if (hostElementRef) {
                if (typeof(renderer.setStyle) !== 'undefined') {
                    // Renderer2 API
                    renderer.removeClass(hostElementRef.nativeElement, 'drawer-left');
                    renderer.removeClass(
                        hostElementRef.nativeElement, 'focus-shift-drawer-left');
                    renderer.removeClass(
                        hostElementRef.nativeElement, 'focus-shift-drawer-right');
                    renderer.setStyle(hostElementRef.nativeElement, 'transition', `all 500ms ${ANIMATION.EASE_IN_OUT_QUINT}`);
                    renderer.removeStyle(hostElementRef.nativeElement, 'width');
                    renderer.removeStyle(hostElementRef.nativeElement, 'marginLeft');
                } else {
                    console.warn('Deprecation warning! Use Renderer2 in destroyDrawer');
                    // Renderer API
                    renderer.setElementStyle(hostElementRef.nativeElement, 'transition', `all 500ms ${ANIMATION.EASE_IN_OUT_QUINT}`);
                    renderer.setElementStyle(hostElementRef.nativeElement, 'width', null);
                    renderer.setElementStyle(hostElementRef.nativeElement, 'marginLeft', null);
                }
            }
        }
    }
}
