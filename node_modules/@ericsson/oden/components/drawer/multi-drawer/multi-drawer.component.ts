import {
    Component,
    ComponentFactoryResolver,
    ComponentRef,
    ElementRef,
    EventEmitter,
    HostBinding,
    OnDestroy,
    OnInit,
    Output,
    Renderer2,
    ViewChild,
    ViewContainerRef,
    ViewEncapsulation,
    forwardRef,
    Inject
} from '@angular/core';
import { ComponentType } from '../../../core/interfaces/component-type.interface';
import { ANIMATION } from '../../../core/constants/animation.constants';
import { DRAWER_CONTEXT, DRAWER_POSITION } from '../../../core/constants/drawer.constants';
import { animate, state, style, transition, trigger } from '@angular/animations';
import { SIZING } from '../../../core/constants/sizing.constants';
import { IMultiDrawerContent } from '../../../core/interfaces/multi-drawer-content.interface';
import { GuidedWorkflowService } from '../../guided-workflow/guided-workflow.service';
import { GUIDED_WORKFLOW } from '../../../core/constants/guided-workflow.constants';
import { DRAWERICON } from '../../../core/constants/drawer-icon.constants';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../../core/classes';
import AnimationHelper from '../../../core/helpers/animation.helper';
import { Base } from '../../../core/classes/base';
import { DrawerService } from '../drawer.service';
import { TranslateService } from '@ngx-translate/core';

@Component({
    selector: 'cui-multi-drawer',
    templateUrl: 'multi-drawer.component.html',
    styleUrls: ['multi-drawer.component.scss'],
    encapsulation: ViewEncapsulation.None,
    animations: [
        trigger('visibility', [
            state('*', style({ opacity: 0 })),
            state('left', style({ opacity: 1, left: 0, display: 'block' })),
            state('right', style({ opacity: 1, right: 0, display: 'block' })),
            transition('* => left', [
                style({ left: '-30%', opacity: 0 }),
                animate('500ms ' + ANIMATION.EASE_IN_OUT_QUINT)
            ]),
            transition('* => right', [
                style({ right: '-30%', opacity: 0 }),
                animate('500ms ' + ANIMATION.EASE_IN_OUT_QUINT)
            ]),
            transition('right => *', animate('500ms ' + ANIMATION.EASE_IN_OUT_QUINT, style({
                right: '-30%',
                opacity: '0'
            }))),
            transition('left => *', animate('500ms ' + ANIMATION.EASE_IN_OUT_QUINT, style({
                left: '-30%',
                opacity: '0',
            })))
        ])
    ],
    providers: [{ provide: Base, useExisting: forwardRef(() => MultiDrawerComponent) }]

})
@UnSub()
export class MultiDrawerComponent extends Base implements OnDestroy, OnInit {
    drawerPosition: DRAWER_POSITION;
    drawerContext: DRAWER_CONTEXT;
    drawerElements: Map<IMultiDrawerContent, ElementRef> = new Map<IMultiDrawerContent, ElementRef>();
    drawers: Array<IMultiDrawerContent> = [];
    drawerIcons: Array<string> = [];
    activeIcon: any;
    width: number = 336; // Will be overwritten by IDrawerContent
    top: number = SIZING.SYSTEMBAR_HEIGHT;
    guidedWorkflowIsOn: boolean = false;
    active: boolean = false;
    _maximized: boolean = false;
    _drawerMaximization: boolean = false;
    _defaultTooltip: string = '';
    _toggleViewSelectorsIcon: string;
    private _subscriptions: Array<Subscription> = [];

    @HostBinding('@visibility') visibility: string = 'hidden';
    @ViewChild('output', { read: ViewContainerRef }) output;
    @HostBinding('style.z-index') zIndex: number;

    @HostBinding('style.margin')
    get _marginLeft(): string {
        let margin = `0 0 0 -${this.width}px`;
        if (this.drawerPosition === DRAWER_POSITION.RIGHT) {
            margin = `0 -${this.width}px 0 0`;
        }
        return this.active ? '0px' : `${margin}`;
    }

    get togglersStyles(): any {
        return {
            margin: this.togglersMargin(),
            top: this.togglersTop(),
            height: this.togglersHeight(),
            left: this.drawerPosition === DRAWER_POSITION.RIGHT ? null : 0,
            right: this.drawerPosition === DRAWER_POSITION.RIGHT ? 0 : null,
            zIndex: this.zIndex
        };
    }

    @Output() toggled: EventEmitter<boolean> = new EventEmitter();
    @Output() toggledAnimationComplete: EventEmitter<boolean> = new EventEmitter();
    @HostBinding('style.width')
    get _width(): string {
        return this._maximized ? 'calc(90% - 56px)' : this.width + 'px';
    }

    @HostBinding('style.top')
    get _top(): string {
        if (this.drawerContextString === 'focus-shift') {
            return SIZING.SYSTEMBAR_HEIGHT + 'px';
        }
        if ((this.guidedWorkflowIsOn || this.guidedWorkflowService.toggleModeOn)
            && this.guidedWorkflowService.position === GUIDED_WORKFLOW.TOP) {
            return (SIZING.SYSTEMBAR_HEIGHT + SIZING.GUIDED_WORKFLOW_HEIGHT -
                (document.getElementById('cui-application').scrollTop > this.guidedWorkflowService.breakpoint ?
                    this.guidedWorkflowService.breakpoint : document.getElementById('cui-application').scrollTop)) + 'px';
        } else if ((this.guidedWorkflowIsOn || this.guidedWorkflowService.toggleModeOn)) {
            return SIZING.SYSTEMBAR_HEIGHT + 'px';
        }
        const appTabWrapper = document.querySelector('#app-tab-wrapper');
        if (appTabWrapper) {
            const appTabWrapperRect = appTabWrapper.getBoundingClientRect();
            const appTabBottomPos = appTabWrapperRect.top + appTabWrapperRect.height;
            return appTabBottomPos + 'px';
        }
        return '0px';
    }

    @HostBinding('style.height')
    get _height(): string {
        return `calc(100% - ${this._top})`;
    }

    @HostBinding('class')
    get positionClass(): string {
        return `cui-drawer scroll-area cui-multi-drawer tabview-wrapper drawer-${this.drawerPositionString}
            ${(this.active ? ' active' : '')} drawer-context-${this.drawerContextString}
            ${((this.guidedWorkflowIsOn || this.guidedWorkflowService.toggleModeOn) &&
                this.guidedWorkflowService.position !== GUIDED_WORKFLOW.TOP ? ' guided-workflow' : '')}`;
    }

    @Output() maximizing: EventEmitter<boolean> = new EventEmitter();
    @Output() maximized: EventEmitter<boolean> = new EventEmitter();

    constructor(public componentFactoryResolver: ComponentFactoryResolver,
        public element: ElementRef, public guidedWorkflowService: GuidedWorkflowService,
        public renderer: Renderer2,
        @Inject(forwardRef(() => DrawerService)) public _drawerService: DrawerService,
        translate: TranslateService) {
        super();
        this._subscriptions.push(
            translate.stream('ODEN.COMPONENTS.DRAWER.LIBRARY').subscribe(value => this._defaultTooltip = value)
        );
    }

    get drawerPositionIsLeft(): boolean {
        return this.drawerPosition === DRAWER_POSITION.LEFT || this.drawerContext === DRAWER_CONTEXT.APPLICATION;
    }

    get drawerPositionString(): string {
        return this.drawerPositionIsLeft ? 'left' : 'right';
    }

    get drawerContextString(): string {
        return this.drawerContext === DRAWER_CONTEXT.APPLICATION ? 'application' : 'focus-shift';
    }

    get calculatedWidth(): number {
        // If collapsed return width of view selectors + tab-holder width (56)
        return this.active ? this.width + 56 : 56;
    }
    private toggleAnimationComplete(open: boolean) {
        AnimationHelper.animationCompleted(this.element.nativeElement).then(() => {
            setTimeout(() => {
                this.toggledAnimationComplete.emit(open);
            });
        });
    }
    togglersMargin(): string {
        const width = this._width;
        let margin = `0 0 0 ${width}`;
        if (this.drawerPosition === DRAWER_POSITION.RIGHT) {
            margin = `0 ${width} 0 0`;
        }
        return this.active ? `${margin}` : `0px`;
    }

    togglersTop(): string {
        return `${parseInt(this._top, 10)}px`;
    }

    togglersHeight(): string {
        return `calc(100% - ${(parseInt(this._top, 10))}px)`;
    }

    /**
     * Adds your component to the split view. Returns your component instance in an Promise.
     * @param componentType
     * @return {Promise<C>}
     */
    addDrawerContentComponent<C extends IMultiDrawerContent>(componentType: ComponentType<C>): Promise<C> {
        const promise: Promise<C> = new Promise((resolve) => {
            const factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
            const componentRef = <ComponentRef<C>>this.output.createComponent(factory);
            const component = componentRef.instance;
            this.renderer.addClass(componentRef.location.nativeElement, 'inactive');
            this.renderer.addClass(componentRef.location.nativeElement, 'split-view-drawer-content');
            this.drawerElements.set(component, componentRef.location);
            // default to library
            if (!component.drawerIcon) {
                component.drawerIcon = DRAWERICON.LIBRARY;
            }
            this.drawerIcons.push(component.drawerIcon);
            this.drawers.push(component);
            resolve(componentRef.instance);
        });
        return promise;
    }

    /**
     * Displays the drawer from the argument. Emits onShow and onHide for different drawers
     * @param {IMultiDrawerContent} drawerContent
     */
    showDrawer(drawerContent: IMultiDrawerContent): void {
        this.activeIcon = null;
        if (!this.active) {
            this.show();
        }
        this.drawerElements.forEach((elementRef, _drawerContent) => {
            if (_drawerContent === drawerContent) {
                this.renderer.addClass(elementRef.nativeElement, 'active');
                this.renderer.removeClass(elementRef.nativeElement, 'inactive');
                this.activeIcon = drawerContent.drawerIcon;
                if (typeof (_drawerContent.onShow) === 'function') {
                    _drawerContent.onShow();
                }
                setTimeout(() => {
                    if (drawerContent.drawerMaximization === undefined || drawerContent.drawerMaximization === null) {
                        drawerContent.drawerMaximization = elementRef.nativeElement.querySelector('cui-library') !== null;
                    }
                    this.drawerMaximization = drawerContent.drawerMaximization;
                });
            } else {
                if (elementRef.nativeElement.classList.contains('active')) {
                    this.renderer.addClass(elementRef.nativeElement, 'inactive');
                    this.renderer.removeClass(elementRef.nativeElement, 'active');
                    if (typeof (_drawerContent.onHide) === 'function') {
                        _drawerContent.onHide();
                    }
                }
            }
        });
    }

    /**
     * Opens a new drawer, or collapses the multi drawer
     * @param {IMultiDrawerContent} drawer
     */
    drawerIconClick(drawer: IMultiDrawerContent): void {
        if (this.activeIcon && this.activeIcon === drawer.drawerIcon) {
            this.collapseDrawer();
        } else {
            this.activeIcon = drawer.drawerIcon;
            this.expandDrawer();
            this.showDrawer(drawer);
        }
    }

    ngOnInit(): void {
        this._subscriptions.push(this.guidedWorkflowService.onWorkflowShow$.subscribe(() => {
            this.guidedWorkflowIsOn = true;
        }));
        this._subscriptions.push(this.guidedWorkflowService.onWorkflowHide$.subscribe(() => {
            // 350ms timeout so the hide animation finishes
            setTimeout(() => {
                this.guidedWorkflowIsOn = false;
            }, 350);
        }));
        this._subscriptions.push(this._drawerService.toggleDrawer$.subscribe(() => {
            this.show();
        }));
        this.guidedWorkflowIsOn = this.guidedWorkflowService.guideIsVisible;
        this.visibility = this.drawerPositionString;
        this._setToggleViewSelectorsIcon();
    }

    /**
     * Shows the multi-drawer
     */
    show(): void {
        this.visibility = this.drawerPositionString;
        // timeout to trigger .view-selectors animation
        setTimeout(() => {
            if (!this.active) {
                this.active = true;
                this.toggled.emit(true);
                this._setToggleViewSelectorsIcon();
                this.toggleAnimationComplete(true);
                if (!this.activeIcon && this.drawers.length) {
                    this.showDrawer(this.drawers[0]);
                }
            }
        });
    }

    /**
     * Removes added styling from other elements
     */
    ngOnDestroy(): void {
        this.active = false;
        this.element.nativeElement.querySelector('.view-selectors').style[this.drawerPositionString] = `-${this.width}px`;
        this._subscriptions.forEach((subscription) => {
            subscription.unsubscribe();
        });
    }

    /**
     * Open or collapse the multi drawer
     */
    toggleDrawer(): void {
        this.active = !this.active;
        this.activeIcon = null;
        this.unmaximizeDrawer();
        if (this.active && this.drawers.length) {
            this.showDrawer(this.drawers[0]);
        }
        this._setToggleViewSelectorsIcon();
        this.toggled.emit(this.active);
        this.toggleAnimationComplete(this.active);
    }

    /**
     * Collapses the multi drawer
     */
    collapseDrawer() {
        this.activeIcon = null;
        this.active = false;
        this._setToggleViewSelectorsIcon();
        this.toggled.emit(false);
        this.toggleAnimationComplete(false);
        this.unmaximizeDrawer();
    }
    /**
     * Expands the multi drawer
     */
    expandDrawer() {
        this.active = true;
        this._setToggleViewSelectorsIcon();
        this.toggled.emit(true);
        this.toggleAnimationComplete(true);
    }

    set drawerMaximization(drawerMaximization: boolean) {
        this._drawerMaximization = drawerMaximization;
        if (!this._drawerMaximization && this._maximized) {
            this.unmaximizeDrawer();
        }
    }

    /**
     * Maximize drawer
     */
    maximizeDrawer(): void {
        if (!this._maximized) {
            this._animateMaximization(true);
        }
    }

    /**
     * Maximize drawer
     */
    unmaximizeDrawer(): void {
        if (this._maximized) {
            this._animateMaximization(false);
        }
    }

    /**
     * Maximize or restore the multi drawer
     */
    toggleMaximized(): void {
        if (!this.active) {
            this.toggleDrawer();
        }
        this._maximized ? this.unmaximizeDrawer() : this.maximizeDrawer();
    }

    private _animateMaximization(maximized: boolean): void {
        setTimeout(() => {
            const scrollTop = this.element.nativeElement.scrollTop;
            const scrollHeight = this.element.nativeElement.scrollHeight;
            this.maximizing.emit(true);
            setTimeout(() => {
                this._maximized = maximized;
                this.maximized.emit(maximized);
                setTimeout(() => {
                    this.maximizing.emit(false);
                    const newScrollHeight = this.element.nativeElement.scrollHeight;
                    this.element.nativeElement.scrollTop = (scrollTop / scrollHeight) * newScrollHeight;
                }, parseInt(ANIMATION.DUR3, 10));
            }, parseInt(ANIMATION.DUR1, 10));
        });
    }

    private _setToggleViewSelectorsIcon(): void {
        if (this.drawerPositionIsLeft) {
            this._toggleViewSelectorsIcon = this.active ? 'sidemenu-left-close' : 'sidemenu-left-open';
        } else {
            this._toggleViewSelectorsIcon = this.active ? 'sidemenu-right-close' : 'sidemenu-right-open';
        }
    }
}
