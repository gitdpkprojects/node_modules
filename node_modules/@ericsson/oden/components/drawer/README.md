[//]: # (title: Drawers)
[//]: # (category: Layout)
[//]: # (icon: fa-arrow-down)

#Drawers
* import { DrawerModule, DrawerService, IMultiDrawerContent, DRAWER_POSITION, DRAWER_ICON } from '@ericsson/oden';

A drawer is an output component which will display one or more components you specify, all reachable via a vertical tab list to its right.
The components you want to display should implement the `IMultiDrawerContent` interface.

##Creating a Drawer content component
```
@Component({
    selector: 'basic-drawer',
    template: '<h1>Hello Drawer</h1>'
})
export class HelloDrawerComponent implements IMultiDrawerContent {
    drawerIcon: string = DRAWER_ICON.DETAILS;
    drawerTooltip: string = 'Details';
    drawerPosition: DRAWER_POSITION = DRAWER_POSITION.RIGHT;
    drawerMaximization?: boolean;
    ....
}
```

The following settings are available for IMultiDrawerContent, although only the `drawerIcon` and `drawerTooltip` are mandatory.
```
 drawerIcon: string;
 drawerTooltip: string;
 drawerWidth?: number;
 drawerPosition?: DRAWER_POSITION;
 drawerMaximization?: boolean;
```
The `drawerWidth` will be set by the `DrawerComponent` and will default to `336px`.
The `drawerPosition` will also be set by the `DrawerComponent` and will default to `DRAWER_POSITION.RIGHT`. How ever,
in an Application context (Not Focus Shift), the `drawerPosition` will always be LEFT.
The `drawerMaximization` determines if drawer should display maximize button, default is true if drawer contains library, otherwise false.
There are currently two ways opening a drawer. Either via IFocusShift properties or via DrawerService.

##Via IFocusShift
If you have a Focus shift component, either extending the `FocusShiftBaseComponent` or implementing your own `IFocusShift`, you can set the property `drawerTypes: Array` to the type of components you want displayed in the drawer.
The property `drawerTypes` expects an array of types and not instances.
When the FocusShift component is created, it will check if you have filled `drawerTypes` and in that case create a drawer with those components.
After the drawer component is created, it will be assigned to your `IFocusShift` components `drawer` property.

To use the example we created above, the FocusShiftComponent would look something like this
```
@Component({
    selector: 'basic-focus-shift',
    template: '<button (click)="openDrawer2()">Open drawer tab #2</button>'
    animations: [FOCUS_SHIFT.ANIMATION]
})
export class BasicFocusShiftComponent extends FocusShiftBaseComponent {
    ...
    @HostBinding('@shiftAnimation') shiftAnimation: string;
    drawerTypes = [HelloDrawerComponent, AnotherDrawerComponent];
    openDrawer2Emitter: EventEmitter<any> = new EventEmitter<any>();

    constructor(element: ElementRef, renderer: Renderer2) {
        super(element, renderer);
    }

    openDrawer2(): void {
        this.openDrawer2Emitter.emit();
    }

    ...
}
```

And the component opening it (from a button):

```
<button cui-button (click)="openFocusShift(myButton)" class="primary" value="Open" #myButton></button>
```
```
openFocusShift(button: ButtonComponent): void {
    this._modalService.createFocusShiftBlockFromComponent<BasicFocusShiftComponent>
        (BasicFocusShiftComponent, button, 'My custom title').then((componentRef) => {
            this.basicFocusShiftComponent = componentRef.instance;
            // subscribe to the `openDrawer2Emitter`
            this.basicFocusShiftComponent.openDrawer2Emitter.subscribe() => {
                // open drawer 2 by accessing the MultiDrawerComponent in my focus shift's `drawer`
                // and calling the showDrawer() function
                this.basicFocusShiftComponent.drawer.instance.
                    showDrawer(this.basicFocusShiftComponent.drawer.instance.drawers[1]);
            });
        });

```

After this component is opened as a FocusShift, the drawer property will be set.
This method changes the behaviour of opening and closing the `IFocusShift`. You should not close the drawer yourself,
let the ModalService handle that.

##Via DrawerService
Use the method `createApplicationMultiDrawer(ElementRef, Renderer2, ComponentFactoryResolver)` to create an drawer next to a canvas.
The `ElementRef` & `Renderer` is provided to your component by Angular, but you need to specify them to the method.

The method returns a `Promise` which resolves into the drawer wrapper component, `MultiDrawerComponent`. Use that one to add your components into the drawer with `addDrawerContentComponent()`, like this:

```
myDrawer: ComponentRef<MultiDrawerComponent>;
...
ngOnInit(): void {
    this._drawerService.createApplicationMultiDrawer(
        this._elementRef, this._renderer, this._componentFactoryResolver).then(
        (drawer: ComponentRef<MultiDrawerComponent>) => {
            this.myDrawer = drawer;
            drawer.instance.addDrawerContentComponent(HelloDrawerComponent).then(
            (helloDrawerComponent: HelloDrawerComponent) => {
                drawer.instance.showDrawer(helloDrawerComponent);
            });
            // add another component to the drawer
            drawer.instance.addDrawerContentComponent(AnotherDrawerComponent);
            // show the drawer (not needed if you run a drawer.instance.showDrawer above)
            drawer.instance.show();
        }
    );
}

```

Import DrawerModule.forRoot() to instantiate DrawerService.

###destroyDrawer(_componentRef_: ComponentRef<any>, _renderer?_: Renderer2, _hostElementRef?_: ElementRef)

To remove a drawer, call the `destroyDrawer` function in `DrawerService` and pass your component's `Renderer` and its `ElementRef`. Using the same example above, we can do this:

```
ngOnDestroy(): void {
    this._drawerService.destroyDrawer(this.myDrawer, this._renderer, this._elementRef);
}

```

## Events
Multidrawer contains the following events

### toggled:_EventEmitter<boolean>
Event triggered when a drawer is toggled.

### toggledAnimationComplete:_EventEmitter<boolean>
Event triggered when a drawer is toggled and animation is finished.


