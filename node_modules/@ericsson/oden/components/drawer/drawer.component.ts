import { Base } from './../../core/classes/base';
import {
    Component, ComponentFactoryResolver,
    ElementRef,
    HostBinding,
    Renderer2,
    ViewChild,
    ViewContainerRef,
    ViewEncapsulation,
    forwardRef,
    OnInit,
    Inject,
    OnDestroy
} from '@angular/core';
import { ComponentType } from '../../core/interfaces/component-type.interface';
import { ANIMATION } from '../../core/constants/animation.constants';
import { IDrawerContent } from '../../core/interfaces/drawer-content.interface';
import { DRAWER_CONTEXT, DRAWER_POSITION } from '../../core/constants/drawer.constants';
import { animate, state, style, transition, trigger } from '@angular/animations';
import { SIZING } from '../../core/constants/sizing.constants';
import { GuidedWorkflowService } from '../guided-workflow/guided-workflow.service';
import { GUIDED_WORKFLOW } from '../../core/constants/guided-workflow.constants';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../core/classes/subscription.decorator';
import { DrawerService } from './drawer.service';

/** @deprecated use MultiDrawerComponent instead **/
@Component({
    selector: 'cui-drawer',
    templateUrl: 'drawer.component.html',
    styleUrls: ['drawer.component.scss'],
    encapsulation: ViewEncapsulation.None,
    providers: [{ provide: Base, useExisting: forwardRef(() => DrawerComponent) }],
    animations: [
        trigger('visibility', [
            state('*', style({opacity: 0})),
            state('left', style({opacity: 1, left: 0, display: 'block'})),
            state('right', style({opacity: 1, right: 0, display: 'block'})),
            transition('* => left', [
                style({left: '-30%', opacity: 0}),
                animate('500ms ' + ANIMATION.EASE_IN_OUT_QUINT)
            ]),
            transition('* => right', [
                style({right: '-30%', opacity: 0}),
                animate('500ms ' + ANIMATION.EASE_IN_OUT_QUINT)
            ]),
            transition('right => void', animate('500ms ' + ANIMATION.EASE_IN_OUT_QUINT, style({right: '-30%', opacity: '0'}))),
            transition('left => void', animate('500ms ' + ANIMATION.EASE_IN_OUT_QUINT, style({left: '-30%', opacity: '0'})))
        ])
    ]
})
@UnSub()
export class DrawerComponent <C extends IDrawerContent|any> implements OnInit, OnDestroy {
    outputComponent: C;
    drawerPosition: DRAWER_POSITION;
    drawerContext: DRAWER_CONTEXT;
    width: number = 336; // Will be overwritten by IDrawerContent
    top: number = SIZING.SYSTEMBAR_HEIGHT;
    guidedWorkflowIsOn: boolean = false;
    private _subscriptions: Array<Subscription> = [];

    @HostBinding('@visibility') visibility: string = 'hidden';
    @ViewChild('output', {read: ViewContainerRef}) output;
    @HostBinding('style.z-index') zIndex: number;
    @HostBinding('style.width') get _width(): string {
        return this.width + 'px';
    }
    @HostBinding('style.top') get _top(): string {
        return this.setTopPosition() + 'px';
    }
    @HostBinding('style.height') get _height(): string {
        return `calc(100% - ${this._top})`;
    }
    @HostBinding('class') get positionClass(): string {
        return `cui-drawer tabview-wrapper drawer-${this.drawerPositionString} drawer-context-${this.drawerContextString}`
            + (this.guidedWorkflowIsOn && this.guidedWorkflowService.position !== GUIDED_WORKFLOW.TOP ? ' guided-workflow' : '');
    }

    constructor(public componentFactoryResolver: ComponentFactoryResolver,
                public element: ElementRef, public guidedWorkflowService: GuidedWorkflowService,
                public renderer: Renderer2,
                @Inject(forwardRef(() => DrawerService)) public _drawerService: DrawerService) {}

    ngOnInit() {
        this.guidedWorkflowIsOn = this.guidedWorkflowService.guideIsVisible;
        this._subscriptions.push(this.guidedWorkflowService.onWorkflowShow$.subscribe(() => {
            this.guidedWorkflowIsOn = true;
        }));
        this._subscriptions.push(this.guidedWorkflowService.onWorkflowHide$.subscribe(() => {
            // 350ms timeout so the hide animation finishes
            setTimeout(() => {
                this.guidedWorkflowIsOn = false;
            }, 350);
        }));
        this._subscriptions.push(this._drawerService.toggleDrawer$.subscribe(() => {
            this.show();
        }));
    }

    ngOnDestroy(): void {
        this._subscriptions.forEach((subscription) => {
            subscription.unsubscribe();
        });
    }

    get drawerPositionString(): string {
        return this.drawerPosition === DRAWER_POSITION.LEFT || this.drawerContext === DRAWER_CONTEXT.APPLICATION ? 'left' : 'right';
    }

    get drawerContextString(): string {
        return this.drawerContext === DRAWER_CONTEXT.APPLICATION ? 'application' : 'focus-shift';
    }

    setTopPosition(): number {
        if (this.drawerContextString === 'focus-shift') {
            return SIZING.SYSTEMBAR_HEIGHT;
        } else if (this.guidedWorkflowIsOn && this.guidedWorkflowService.position === GUIDED_WORKFLOW.TOP) {
            const activeGuide = document.querySelector('.cui-guided-workflow.active:not(.maximized):not(.ng-animating)');
            if (activeGuide) {
                const activeGuideClientRect = activeGuide.getBoundingClientRect();
                return activeGuideClientRect.top + activeGuideClientRect.height;
            } else {
                return (SIZING.SYSTEMBAR_HEIGHT + SIZING.GUIDED_WORKFLOW_HEIGHT);
            }
        } else if (this.guidedWorkflowIsOn) {
            return SIZING.SYSTEMBAR_HEIGHT;
        } else {
            const appTabWrapper = document.querySelector('#app-tab-wrapper');
            if (appTabWrapper) {
                const appTabWrapperRect = appTabWrapper.getBoundingClientRect();
                return appTabWrapperRect.top + appTabWrapperRect.height;
            }
        }
        return 0;
    }

    setDrawerContentComponent<D extends IDrawerContent>(componentType: ComponentType<D>) {
        const factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
        const componentRef = this.output.createComponent(factory);
        this.outputComponent = componentRef.instance;
        return componentRef;
    }

    show(): void {
        this.visibility = this.drawerPositionString;
    }
}
