import * as _ from 'lodash';
import { Injectable, ComponentFactoryResolver } from '@angular/core';
import { ILibraryItemReceiver } from '../../core/interfaces/library-item-receiver.interface';
import { TactileBlockItem, ModalActionItem } from '../../core/models';
import { ModalHelperService } from '../modal';
import { DialogConfig, DIALOG_TYPE } from '../modal/dialog';
import { SelectReceiverDialogComponent } from './select-receiver-dialog/select-receiver-dialog.component';
import { TranslateService } from '@ngx-translate/core';
import { Observable, Subject, Subscription } from 'rxjs';

@Injectable()
export class LibraryItemReceiverService {
    private _receivers: Array<ILibraryItemReceiver> = [];
    private _cancelAction = new ModalActionItem({
        label: 'Close',
        action: 'close',
        cssClass: 'discard'
    });
    private _addAction = new ModalActionItem({
        label: 'Add',
        action: 'add'
    });
    private _title = '';
    private _defaultNamePrefix = '';

    constructor(
        private _modalHelperService: ModalHelperService,
        private _componentFactoryResolver: ComponentFactoryResolver,
        translate: TranslateService) {
        translate.stream([
            'ODEN.COMMON.CANCEL',
            'ODEN.COMMON.ADD',
            'ODEN.COMPONENTS.LIBRARY.ADD_TO_CONFIGURATION',
            'ODEN.COMPONENTS.LIBRARY.CONFIGURATION'
        ]).subscribe(res => {
            this._cancelAction.label = res['ODEN.COMMON.CANCEL'];
            this._addAction.label = res['ODEN.COMMON.ADD'];
            this._title = res['ODEN.COMPONENTS.LIBRARY.ADD_TO_CONFIGURATION'];
            this._defaultNamePrefix = res['ODEN.COMPONENTS.LIBRARY.CONFIGURATION'];
        });
    }

    /**
     * Returns list of receivers capable of receiving item.
     * @param {TactileBlockItem} tactileItem
     */
    receiversFor(tactileItem: TactileBlockItem): Array<ILibraryItemReceiver> {
        return this._receivers.filter(receiver => receiver.canReceiveLibraryItem(tactileItem))
            .map((receiver, index) => {
                return {
                    name: receiver.name || `${this._defaultNamePrefix} ${index + 1}`,
                    canReceiveLibraryItem: (item) => receiver.canReceiveLibraryItem(item),
                    onReceiveLibraryItem: (item) => receiver.onReceiveLibraryItem(item)
                };
            });
    }

    /**
     * Send tactile item to registered receiver.
     *
     * @param {TactileBlockItem} tactileItem
     * @param {Element} callingElement
     */
    send(tactileItem: TactileBlockItem, callingElement?: Element): Observable<boolean> {
        const receivers = this.receiversFor(tactileItem);
        if (receivers.length === 1) {
            this._sendTo(tactileItem, receivers[0]);
            return Observable.of(true);
        } else if (receivers.length) {
            const config: DialogConfig = new DialogConfig({
                title: this._title,
                actions: [this._cancelAction, this._addAction],
                component: SelectReceiverDialogComponent,
                type: DIALOG_TYPE.DIALOG,
                width: 'fit-content'
            });
            const dialog = this._modalHelperService.createDialog(config, this._componentFactoryResolver, false, callingElement);
            const component: SelectReceiverDialogComponent = dialog.customComponent;
            component._receivers = receivers;
            component._selectedReceiver = receivers[0];
            const subject = new Subject<boolean>();
            const onActionSubscription: Subscription = dialog.onAction.subscribe((actionItem: ModalActionItem) => {
                dialog.close();
                onActionSubscription.unsubscribe();
                switch (actionItem.action) {
                    case 'add':
                        const receiver = component._selectedReceiver;
                        this._sendTo(tactileItem, receiver);
                        subject.next(true);
                        break;
                    default:
                        subject.next(false);
                }
                subject.complete();
            });
            dialog.open();
            return subject.asObservable();
        } else {
            return Observable.of(false);
        }
    }

    /**
     * Register receiver.
     *
     * @param {ILibraryItemReceiver} receiver
     */
    registerReceiver(receiver: ILibraryItemReceiver): void {
        this.deregisterReceiver(receiver);
        this._receivers.push(receiver);
    }

    /**
     * Deregister receiver.
     *
     * @param {ILibraryItemReceiver} receiver
     */
    deregisterReceiver(receiver: ILibraryItemReceiver): void {
        this._receivers = this._receivers.filter(r => r !== receiver);
    }

    /**
     * Send to receiver
     *
     * @param {TactileBlockItem} tactileItem
     * @param {ILibraryItemReceiver} receiver
     */
    private _sendTo(tactileItem: TactileBlockItem, receiver: ILibraryItemReceiver) {
        receiver.onReceiveLibraryItem(_.cloneDeep(tactileItem));
    }
}
