import { CATEGORY_FILTER_LAYOUT } from './../../../core/constants/category-filter.constants';
/* tslint:disable:component-selector-prefix */
/* tslint:disable:component-selector-name */
/* tslint:disable:no-input-rename */
import {
    Component,
    DoCheck,
    ElementRef,
    EventEmitter,
    HostBinding,
    Input,
    IterableDiffer,
    IterableDiffers,
    OnInit,
    Output,
    Renderer2,
    ViewChild,
    ViewEncapsulation,
    ViewChildren
} from '@angular/core';
import { TAB_VIEW, TabView, TabViewService } from '../../tab-view';
import { ActivatedRoute } from '@angular/router';
import { LibraryGroup } from '../../../core/models/library-group.model';
import { TactileBlockItem } from '../../../core/models/tactile-block-item.model';
import { FilterService } from '../../../core/services/filter.service';
import { LibraryService } from '../../../core/services/library.service';
import { LibraryActionEvent } from '../../../core/models/library-action-event.model';
import { ArrayHelper } from '../../../core/helpers/array.helper';
import { PaginationData } from '../../pagination/pagination.model';
import AnimationHelper from '../../../core/helpers/animation.helper';
import { DropzoneService } from '../../dropzone/dropzone.service';
import { DOMHelper } from '../../../core/helpers/dom.helper';
import { ElementOverlayConfig } from '../../../core/models/element-overlay-config.model';
import { ELEMENT_OVERLAY_STATE } from '../../../core/constants/element-overlay-state.constants';
import * as _ from 'lodash';
import { ListControllerCategoryFilterComponent } from '../../list-controller';
import { LibraryItemReceiverService } from '../library-item-receiver.service';

@Component({
    selector: 'cui-library-group',
    templateUrl: './library-group.component.html',
    styleUrls: ['./library-group.component.scss'],
    encapsulation: ViewEncapsulation.None,
    animations: [TAB_VIEW.ANIMATION_FULL]
})
export class LibraryGroupComponent extends TabView implements OnInit, DoCheck {
    @HostBinding('@routeAnimation') animationDirection: string;
    @HostBinding('class') tabViewClass: string = 'cui-library-group tab-view';
    @ViewChild('tactileBlocksWrapper') tactileBlocksWrapper: ElementRef;
    @ViewChildren('categoryFilters') categoryFilters: Array<ListControllerCategoryFilterComponent>;
    @Input('tabIndex') tabIndex: number;
    @Input('group') group: LibraryGroup;

    @Input() customPagination: boolean; // If false inbuilt pagination and filtering is used.
    @Input() paginationData: PaginationData;

    @Input() expandableTactileBlocks: boolean = false;
    @Input() maximizing: boolean = false;
    @Input() maximized: boolean = false;

    @Output() onPagination: EventEmitter<PaginationData> = new EventEmitter<PaginationData>();

    overlayConfig: ElementOverlayConfig = new ElementOverlayConfig({ state: ELEMENT_OVERLAY_STATE.NONE });
    _paginationData: PaginationData = new PaginationData();
    paginatedData: Array<TactileBlockItem> = [];
    goUp: boolean = false;
    goDown: boolean = false;
    groupItems: Array<TactileBlockItem>;
    layout = CATEGORY_FILTER_LAYOUT.MULTISELECT;
    private _differ: IterableDiffer<any>;
    private _lastPage: number = 0;

    private _groupItems(): Array<TactileBlockItem> {
        let items;
        // If custom pagination is required, dont use default filters.
        if (this.customPagination) {
            items = (this.group && this.group.items) ? this.group.items : [];
            if (this.paginationData) {
                // If pagination data is present use that.
                this._paginationData = this.paginationData;
            }
        } else {
            const allItems = this.filterService.getItems(this.group.items, this.group.id);
            if (this.group.filterString === undefined) {
                items = allItems;
                // remove highlighted tag
                Array.from(document.querySelectorAll
                    ('.cui-library-group .title, .cui-library-group .subtitle, .cui-library-group .description')).
                    forEach((element: HTMLElement) => {
                        element.innerHTML = element.innerText;
                    });
            } else {
                // filter by keys 'title', 'subtitle' and 'description'
                // filter by tags
                // merge two filtered arrays
                items = _.union(
                    ArrayHelper.filterOnKeys(allItems, this.group.filterString, ['title', 'subtitle', 'description']),
                    allItems.filter((_item) => {
                        if (_item.data && _item.data.tags) {
                            return (ArrayHelper.matchArray(_item.data.tags, this.group.filterString).length > 0);
                        }
                        return null;
                    })
                );
                items.forEach((_item) => {
                    // add highlighted tag around filter match
                    Array.from(document.querySelectorAll('#tactile-' + _item.id + ' .title, #tactile-' + _item.id + ' .subtitle, ' +
                        '#tactile-' + _item.id + ' .description')).forEach((element: HTMLElement) => {
                            element.innerHTML = DOMHelper.highlightString(this.group.filterString, element.innerText);
                        });
                });
            }
            if (items) {
                this._paginationData.totalItems = items.length;
            }
        }
        return items;
    }

    constructor(tabViewService: TabViewService, router: ActivatedRoute, public filterService: FilterService,
        public libraryService: LibraryService, private _renderer: Renderer2, public dropzoneService: DropzoneService,
        private _differs: IterableDiffers, private _libraryItemReceiverService: LibraryItemReceiverService) {
        super(tabViewService, router);
        this._subscriptions.push(this.dropzoneService.onAddTactileBlockToDropzone.subscribe(() => {
            this.setPaginatedData();
        }));
        this._subscriptions.push(this.libraryService.onCategoryFilterChange.subscribe(() => {
            this._paginationData.currentPage = 0;
            this.setPaginatedData();
        }));
        this._subscriptions.push(this.libraryService.onFilter.subscribe(() => {
            this._paginationData.currentPage = 0;
            this.setPaginatedData();
        }));
        this._differ = this._differs.find([]).create(null);
    }

    ngOnInit(): void {
        this.filterService.empty();
        this.groupItems = this._groupItems();
        if (this.groupItems && this.groupItems.length > 0) {
            this._initPagination(this.groupItems);
            this.setPaginatedData();
        } else {
            this.overlayConfig.label = 'No existing entities';
            this.overlayConfig.text = '';
            this.onErrorMsgHandling();
        }
    }

    ngDoCheck() {
        const change = this._differ.diff(this.group.items);
        if (change) {
            this.setPaginatedData();
        }
    }

    private _initPagination(data: Array<TactileBlockItem>): void {
        // Creates a new instance of PaginationData with the defaults values.
        if (!this.customPagination) {
            this._paginationData.totalItems = data.length;
            this._paginationData.itemsPerPage = 20;
        } else {
            if (this.paginationData) {
                this._paginationData = this.paginationData;
            }
        }
    }

    /**
     * Is executed when a user uses an pagination method.
     */
    paginationClick(data: PaginationData): void {
        const block = this.tactileBlocksWrapper.nativeElement;
        this.goUp = data.currentPage > this._lastPage;
        this.goDown = !this.goUp;
        AnimationHelper.animationCompleted(block).then(() => {
            if (this.customPagination) {
                this.libraryService.paginatonClick(data);
            } else {
                this.setPaginatedData();
            }
            this._renderer.setStyle(block, 'transition', 'none');
            this.goDown = data.currentPage > this._lastPage;
            this.goUp = !this.goDown;
            this._renderer.removeStyle(block, 'transition');
            setTimeout(() => {
                // scroll to bottom
                const drawer = DOMHelper.closestParent(block, 'cui-drawer');
                if (drawer) {
                    drawer.scrollTop = drawer.scrollHeight;
                }
                this.goDown = false;
                this.goUp = false;
                this._lastPage = data.currentPage;
            }, 0);
        });
    }


    /**
     * Callback for filtering. If user has defined own onFilter function, use that, otherwise use built in filtering.
     * @param filter
     */
    onFilterLibraryGroup(filter: string): void {
        this.group.filterString = filter;
        this.libraryService.filterChange(filter);
    }

    /**
     * Action dispatcher for onMenuActionClick
     * @param item
     * @param libraryActionEvent
     */
    menuActionClick(item: TactileBlockItem, libraryActionEvent: LibraryActionEvent): void {
        libraryActionEvent.item = item;
        this.libraryService.menuActionClick(libraryActionEvent);
    }

    /**
     * When the category filter is changed, we emit an event allowing manipulation of the data for table.
     * @param obj Consists of 'group' and 'ngModel'
     */
    onCategoryFilter(obj: any): void {
        this.libraryService.categoryFilterChange(obj);
    }

    /**
     * Makes the paginated data
     */
    setPaginatedData(): void {
        this.groupItems = this._groupItems();
        if (this.customPagination) {
            Promise.resolve().then(() => {
                this.paginatedData = this.groupItems;
            });
        } else {
            const pData = this._paginationData;
            const startIndex = pData.currentPage * pData.itemsPerPage;
            let endIndex = startIndex + pData.itemsPerPage;
            if (endIndex > this.groupItems.length) {
                endIndex = this.groupItems.length;
            }
            Promise.resolve().then(() => {
                this.paginatedData = this.groupItems.slice(startIndex, endIndex);
            });
        }
        // to handle zero result of group items
        if (this.group.items.length > 0) {
            this.overlayConfig.label = 'No matching results';
            this.overlayConfig.text = 'Try using another filter configuration';
        }
        this.onErrorMsgHandling();
    }

    /**
     * Action dispatcher for onButtonActionClick
     * @param item
     * @param libraryActionEvent
     */
    buttonActionClick(item: TactileBlockItem, libraryActionEvent: LibraryActionEvent): void {
        libraryActionEvent.item = item;
        this.libraryService.buttonActionClick(libraryActionEvent);
    }

    /**
     * Action dispatcher for onAddItemActionClick
     * @param item
     */
    addItemActionClick(item: TactileBlockItem): void {
        this._libraryItemReceiverService.send(item, event.target as Element)
            .filter(sent => sent)
            .forEach(() => this.libraryService.added$.emit(item));
    }

    /**
     * To populate errormessage for lib
     */
    onErrorMsgHandling(): void {
        if (!this.groupItems || (this.groupItems && this.groupItems.length === 0)) {
            this.paginatedData = [];
            this.overlayConfig.state = ELEMENT_OVERLAY_STATE.NOTICE;
            this.overlayConfig.actions = [];
            this.overlayConfig.inlinePlaceholder = true;
        } else {
            this.overlayConfig.state = ELEMENT_OVERLAY_STATE.NONE;
            this.overlayConfig.actions = [];
            this.overlayConfig.inlinePlaceholder = true;
        }
    }

    /**
     * Clear all filters, set text filter to empty string and select all checkboxes.
     */
    onClearFilters(): void {
        // Set text filter to empty string
        const filter = '';
        this.group.filterString = filter;
        this.libraryService.filterChange(filter);

        // Loop through all category filters and check all checkboxes.
        this.categoryFilters.forEach((categoryFilter: ListControllerCategoryFilterComponent) => {
            categoryFilter.checkAll();
        });
    }
}
