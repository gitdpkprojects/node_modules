import {
    Component,
    EventEmitter,
    forwardRef,
    HostBinding,
    Input,
    OnInit,
    Optional,
    Output,
    SkipSelf,
    ViewEncapsulation
} from '@angular/core';
import * as _ from 'lodash';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../core/classes';
import { ParentHelper } from '../../core/helpers/parent.helper';
import { UUID } from '../../core/helpers/uuid.class';
import { ITabs } from '../../core/interfaces';
import { ITabsItem } from '../../core/interfaces/tabs.interface';
import { ActionItem } from '../../core/models';
import { LibraryAction } from '../../core/models/library-action.model';
import { LibraryGroup } from '../../core/models/library-group.model';
import { TactileBlockItem } from '../../core/models/tactile-block-item.model';
import { LibraryService } from '../../core/services/library.service';
import { DraggableService } from '../draggable/draggable.service';
import { MultiDrawerComponent } from '../drawer';
import { PaginationData } from '../pagination/pagination.model';
import { Base } from './../../core/classes/base';
import { ResizeService } from '../../core/services';
import { IWindowSize, ScreenSize } from '../../core/interfaces/window-size';

@Component({
    selector: 'cui-library',
    templateUrl: './library.component.html',
    styleUrls: ['./library.component.scss'],
    encapsulation: ViewEncapsulation.None,
    providers: [
        { provide: Base, useExisting: forwardRef(() => LibraryComponent) }
    ]
})
@UnSub()
export class LibraryComponent implements OnInit {
    @HostBinding('attr.id') id: string = 'library-' + UUID.create();
    @HostBinding('class.cui-library') addClass: boolean = true;
    // tslint:disable-next-line:no-input-rename
    @Input('title') title: string;
    @Input() actions: Array<ActionItem> = [];
    @Input() groups: Array<LibraryGroup> = [];
    @Input() customPagination: boolean = false;
    @Input() paginationData: PaginationData;

    @Output() onActionClick: EventEmitter<ActionItem> = new EventEmitter<ActionItem>();
    @Output() onCategoryFilterChange: EventEmitter<any> = new EventEmitter<any>();
    @Output() onButtonActionClick: EventEmitter<LibraryAction> = new EventEmitter<LibraryAction>();
    @Output() onMenuActionClick: EventEmitter<LibraryAction> = new EventEmitter<LibraryAction>();
    @Output() onGroupChange: EventEmitter<LibraryGroup> = new EventEmitter<LibraryGroup>();
    @Output() onFilter: EventEmitter<string> = new EventEmitter<string>();
    @Output() onPagination: EventEmitter<PaginationData> = new EventEmitter<PaginationData>();

    tabs: ITabs = [];
    currentWindowSize: IWindowSize;
    _maximizing: boolean = false;
    _maximized: boolean = false;
    private _subscriptions: Array<Subscription> = [];

    constructor(public libraryService: LibraryService, @SkipSelf() @Optional() public parent: Base,
        private _resizeService: ResizeService, @Optional() private _draggableService: DraggableService) { }

    /**
     * Create tabs from groups
     */
    ngOnInit(): void {
        this._subscriptions.push(
            this._resizeService.resize$.subscribe(windowSize => {
                this.currentWindowSize = windowSize;
            })
        );
        const drawer: MultiDrawerComponent = <MultiDrawerComponent>(
            ParentHelper.getFirstParentOfType(this, MultiDrawerComponent)
        );
        if (drawer && this._draggableService) {
            this._subscriptions.push(
                this._draggableService.onStartDrag.delay(300).subscribe(() => {
                    if (this.currentWindowSize.size === ScreenSize.SMALL) {
                        drawer.collapseDrawer();
                    } else {
                        drawer.unmaximizeDrawer();
                    }
                })
            );
            this._subscriptions.push(drawer.maximizing.subscribe((maximizing: boolean) => {
                this._maximizing = maximizing;
            }));
            this._subscriptions.push(drawer.maximized.subscribe((maximized: boolean) => {
                this._maximized = maximized;
            }));
        }
        this._subscriptions.push(this.libraryService.added$.subscribe((tactileItem: TactileBlockItem) => {
            this.groups.forEach(group => {
                const index: number = this._indexOfTactileItem(group.items, tactileItem);
                if (index !== -1) {
                    if (!tactileItem.persist) {
                        group.items.splice(index, 1);
                    } else {
                        group.items[index] = _.cloneDeep(group.items[index]);
                    }
                }
            });
        }));
        this._subscriptions.push(this.libraryService.onCategoryFilterChange.subscribe((obj: any) => {
            this.onCategoryFilterChange.emit(obj);
        }));
        this._subscriptions.push(this.libraryService.onButtonActionClick.subscribe((action: LibraryAction) => {
            this.onButtonActionClick.emit(action);
        }));
        this._subscriptions.push(this.libraryService.onFilter.subscribe((string: string) => {
            this.onFilter.emit(string);
        }));
        this._subscriptions.push(this.libraryService.onMenuActionClick.subscribe((action: LibraryAction) => {
            this.onMenuActionClick.emit(action);
        }));
        this._subscriptions.push(this.libraryService.onPagination.subscribe((paginationData: PaginationData) => {
            this.onPagination.emit(paginationData);
        }));

        const setFirstTabAsActive = this.groups.filter((group) => group.active).length === 0;
        this.groups.forEach((group, id) => {
            const item: ITabsItem = {
                id,
                title: group.title,
                path: null,
                active: setFirstTabAsActive ? id === 0 : group.active
            };
            this.tabs.push(item);
            if (item.active) {
                this.setActive(group);
            }
        });
    }

    /**
     * Sets group active from tab
     * @param tab
     */
    setActiveGroupFromTabItem(tab: ITabsItem): void {
        this.setActive(this.groups[tab.id]);
        this.onGroupChange.emit(this.groups[tab.id]);
    }

    /**
     * Action dispatcher for onActionClick
     * @param actionItem
     */
    actionClick(actionItem: ActionItem): void {
        this.onActionClick.emit(actionItem);
    }

    /**
     * Sets clicked group to active and all other to inactive
     * @param group
     */
    setActive(group: LibraryGroup): void {
        this.groups.forEach(_group => {
            _group.active = false;
        });
        group.active = true;
    }

    /**
     * Returns the index of the TactileBlockItem
     * @param items
     * @param tactileItem
     * @return {number}
     * @private
     */
    private _indexOfTactileItem(items: Array<TactileBlockItem>, tactileItem: TactileBlockItem): number {
        return tactileItem ? items.map(item => item.id).indexOf(tactileItem.id) : -1;
    }
}
