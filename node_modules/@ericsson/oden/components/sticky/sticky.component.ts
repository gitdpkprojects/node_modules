import {
    AfterViewInit,
    Component,
    ElementRef,
    EventEmitter,
    HostBinding,
    Input,
    OnDestroy,
    OnInit,
    Output,
    Renderer2,
    ViewEncapsulation
} from '@angular/core';
import { SIZING } from '../../core/constants/sizing.constants';

@Component({
    selector: 'cui-sticky',
    styleUrls: ['sticky.component.scss'],
    templateUrl: 'sticky.component.html',
    encapsulation: ViewEncapsulation.None
})

export class StickyComponent implements OnInit, OnDestroy, AfterViewInit {
    @HostBinding('class.cui-sticky') addClass: boolean = true;
    @Input() zIndex: number = 10;
    @Input() width: string = 'auto';
    @Input() offsetTop: number = SIZING.SYSTEMBAR_HEIGHT;
    @Input() offsetBottom: number = 0;
    @Input() start: number = 0;
    @Input() stickClass: string = 'sticky';
    @Input() mediaQuery: string = '';
    @Input() parent: boolean = true;
    @Input() canvasId: string = null;

    @Output() activated = new EventEmitter();
    @Output() deactivated = new EventEmitter();

    private onScrollBind: EventListener = this.onScroll.bind(this);
    private onResizeBind: EventListener = this.onResize.bind(this);

    private isStuck: boolean = false;

    private elem: any;
    private container: any;
    private originalCss: any;

    private _width: string;
    private windowHeight: number;
    private containerHeight: number;
    private elemHeight: number;
    private containerStart: number;
    private scrollFinish: number;

    private body = document.body;
    private canvas: HTMLElement = null;
    private html = document.documentElement;

    constructor(_element: ElementRef, private _renderer: Renderer2) {
        this.elem = _element.nativeElement;
    }

    ngOnInit(): void {
        if (this.canvasId) {
            this.canvas = document.getElementById(this.canvasId);

            if (this.canvas === null) {
                return;
                // throw 'Could not find specified canvasId in DOM';
            }
            this.canvas.addEventListener('scroll', this.onScrollBind);

        } else {
            window.addEventListener('scroll', this.onScrollBind);
        }

        window.addEventListener('resize', this.onResizeBind);
    }

    ngAfterViewInit(): void {
        // define scroll container as parent element
        this.container = this.elem.parentNode;

        if (this.canvas) {
            this.setOriginalCss(this.canvas);
            if (this.originalCss) {
                this.originalCss.paddingTop = window.getComputedStyle(this.canvas).getPropertyValue('padding-top');
            }
        }

        this.defineDimensions();

        this.sticker();
    }

    private setOriginalCss(bodyOrCanvas: HTMLElement): void {
        if (bodyOrCanvas) {
            this.originalCss = {
                zIndex: window.getComputedStyle(this.elem).getPropertyValue('z-index'),
                position: window.getComputedStyle(this.elem).getPropertyValue('position'),
                top: window.getComputedStyle(this.elem).getPropertyValue('top'),
                right: window.getComputedStyle(this.elem).getPropertyValue('right'),
                left: window.getComputedStyle(this.elem).getPropertyValue('left'),
                bottom: window.getComputedStyle(this.elem).getPropertyValue('bottom'),
                width: window.getComputedStyle(this.elem).getPropertyValue('width'),
                background: window.getComputedStyle(this.elem).getPropertyValue('background'),
                paddingTop: window.getComputedStyle(bodyOrCanvas).getPropertyValue('padding-top')
            };
            if (this.width === 'auto') {
                this._width = window.getComputedStyle(this.elem).getPropertyValue('width');
            } else {
                this._width = this.width;
            }
        }
    }

    ngOnDestroy(): void {
        if (this.canvas) {
            this.canvas.removeEventListener('scroll', this.onScrollBind);
        } else {
            window.removeEventListener('scroll', this.onScrollBind);
        }
        window.removeEventListener('resize', this.onResizeBind);
        this.resetElement(this.canvas);
    }

    onScroll(): void {
        this.defineDimensions();
        this.sticker();
    }

    onResize(): void {
        this.elem.style.width = `${this.container.scrollWidth}px`;
        this.elem.style.left = `${this.getBoundingClientRectValue(this.container, 'left')}px`;
    }

    defineDimensions(): void {
        const containerTop: number = this.getBoundingClientRectValue(this.container, 'top');
        this.windowHeight = window.innerHeight;
        this.elemHeight = parseInt(window.getComputedStyle(this.elem).getPropertyValue('height'), 10) || 0;
        this.containerHeight = parseInt(window.getComputedStyle(this.container).getPropertyValue('height'), 10) || 0;
        this.containerStart = this.start > -1 ? this.start : containerTop
            + this.scrollbarYPos() - this.offsetTop + this.start;
        if (this.parent) {
            this.scrollFinish = this.containerStart - this.start - this.offsetBottom
                + (this.containerHeight - this.elemHeight);
        } else {
            this.scrollFinish = Math.max( this.body.scrollHeight, this.body.offsetHeight,
                this.html.clientHeight, this.html.scrollHeight, this.html.offsetHeight, (this.canvas ? this.canvas.scrollHeight : 0) );
        }
    }

    resetElement(container: HTMLElement): void {
        this.isStuck = false;
        this._renderer.removeClass(this.elem, this.stickClass);
        if (container) {
            this._renderer.removeClass(container, 'sticky-container');
            if (this.originalCss) {
                this._renderer.setStyle(container, 'paddingTop', this.originalCss.paddingTop);
            }
        }
        this._renderer.setAttribute(this.elem, 'style', null);
    }

    stuckElement(container: HTMLElement): void {
        this.setOriginalCss(container);

        this.isStuck = true;

        this._renderer.setStyle(container, 'paddingTop', this.elem.getBoundingClientRect().height + 'px');
        this._renderer.addClass(container, 'sticky-container');

        this._renderer.addClass(this.elem, this.stickClass);

        const elementLeft = this.getBoundingClientRectValue(this.elem, 'left');
        this.elem.style.zIndex = this.zIndex;
        this.elem.style.position = 'fixed';
        this.elem.style.top = this.offsetTop + 'px';
        this.elem.style.right = 'auto';
        this.elem.style.left = elementLeft + 'px';
        this.elem.style.bottom = 'auto';
        this.elem.style.width = this._width;

        this.activated.next(this.elem);
    }

    unstuckElement(container: HTMLElement): void {
        this.isStuck = false;
        if (this.originalCss) {
            this._renderer.setStyle(container, 'paddingTop', this.originalCss.paddingTop);
        }

        this.container.style.position = 'relative';

        this.deactivated.next(this.elem);
    }

    matchMediaQuery(): any {
        if (!this.mediaQuery) {
            return true;
        }
        return (
            window.matchMedia('(' + this.mediaQuery + ')').matches ||
            window.matchMedia(this.mediaQuery).matches
        );
    }

    doCheckForCanvasScroll(container: HTMLElement, position: number): void {
        if (!this.isStuck && position <= this.scrollFinish + 10 && position >= this.containerStart) {
            this.stuckElement(container);
        } else {
            if (position > this.scrollFinish + 10 || position < this.containerStart) {
                this.resetElement(container);
                this.unstuckElement(container);
            }
        }
    }

    doCheckForBodyScroll(container: HTMLElement, position: number): void {
        if (!this.isStuck && position > SIZING.SYSTEMBAR_HEIGHT) {
            this.stuckElement(container);
        } else {
            if (position <= SIZING.SYSTEMBAR_HEIGHT) {
                this.resetElement(container);
                this.unstuckElement(container);
            }
        }
    }

    sticker(): void {
        // Define the affected canvas - or body if canvas is not current
        const container: HTMLElement = this.canvas ? this.canvas : this.body;

        // check media query
        if (this.isStuck && !this.matchMediaQuery()) {
            this.resetElement(container);
            return;
        }

        // detecting when a container's height changes
        const currentContainerHeight: number = parseInt(window.getComputedStyle(this.container).getPropertyValue('height'), 10) || 0;
        if (currentContainerHeight !== this.containerHeight || this.windowHeight !== window.innerHeight) {
            this.defineDimensions();
        }

        const position: number = this.scrollbarYPos();

        if (this.canvas) {
            this.doCheckForCanvasScroll(container, position);
        } else {
            this.doCheckForBodyScroll(container, position);
        }
    }

    private scrollbarYPos(): number {
        if (this.canvas) {
            return this.canvas.scrollTop;
        } else {
            return window.pageYOffset || document.documentElement.scrollTop;
        }
    }

    private getBoundingClientRectValue(element: any, property: string): number {
        let result = 0;
        if (element.getBoundingClientRect) {
            const rect = element.getBoundingClientRect();
            result = (typeof rect[property] !== 'undefined') ? rect[property] : 0;
        }
        return result;
    }

}
