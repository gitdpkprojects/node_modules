import {
    ComponentFactory,
    ComponentFactoryResolver,
    ComponentRef,
    EventEmitter,
    HostListener,
    Input,
    OnChanges,
    OnDestroy,
    Output,
    SimpleChanges,
    ViewChild,
    ViewContainerRef,
    HostBinding,
    AfterViewInit,
    ElementRef
} from '@angular/core';
import { ObjectHelper } from '../../core/helpers/object.helper';
import { CHART_ADDON, CHART_ADDON_POSITION } from '../../core/constants/chart-addons.constants';
import { Addon } from '../../core/models/addon.model';
import { AddonHelper } from './addon/addon.helper';
import { ChartService } from './chart.service';
import { UUID } from '../../core/helpers/uuid.class';
import { Subscription } from 'rxjs/Subscription';
import { ChartData } from '../../core/models/chart.model';
import * as _ from 'lodash';
import { UnSub } from '../../core/classes';

@UnSub()
export class ChartWithAddons implements OnDestroy, OnChanges, AfterViewInit {
    private _tooltipElement: any;
    _subscriptions: Array<Subscription> = [];
    chartService: ChartService;

    @Input() addons: Array<Addon> = [];
    @Input() addonsPosition: CHART_ADDON_POSITION = CHART_ADDON_POSITION.RIGHT;
    @Output() onItemSelected: EventEmitter<ChartData> = new EventEmitter<ChartData>();
    @Output() onOpenLink: EventEmitter<ChartData> = new EventEmitter<ChartData>();

    @HostBinding('class.addons-position-right')
    get isAddonsPositionsRight(): boolean {
        return this.addonsPosition === CHART_ADDON_POSITION.RIGHT;
    }
    @HostBinding('class.addons-position-bottom')
    get isAddonsPositionsBottom(): boolean {
        return this.addonsPosition === CHART_ADDON_POSITION.BOTTOM;
    }

    @ViewChild('chartContainer', { read: ElementRef }) element: ElementRef;
    @ViewChild('addonsContainer', { read: ViewContainerRef }) addonsContainer;

    constructor(private _componentFactoryResolver: ComponentFactoryResolver,
                chartService: ChartService) {
        this.chartService = chartService;
        this._subscriptions.push(chartService.activeItem$.subscribe((item: ChartData) => {
            this.onItemSelected.emit(item);
        }));

        // Whenever an item.link is clicked
        this._subscriptions.push(chartService.openLink$.subscribe((item: ChartData) => {
            this.onOpenLink.emit(item);
        }));
    }

    /**
     * Bootstrap component
     */
    ngAfterViewInit(): void {
        if (this.element) {
            this.setContainerHeight(this.element.nativeElement);
        }
    }

    @HostListener('click', ['$event'])
    _onClick(event): void {
        event.stopPropagation();
    }

    get hasAddons() {
        return this.addons.length > 0;
    }

    reloadAddons() {
        this.createAddons(this.addonsContainer, this.addons);
    }

    /**
     * Hack to fix height in a column based chart
     * @param element Element to take height from
     */
    setContainerHeight(element: HTMLElement) {
        setTimeout(() => {
            if (this.isAddonsPositionsBottom) {
                const svg = element.querySelector('svg');
                if (svg) {
                    svg.style.height = element.clientHeight + 'px';
                }
            }
        });
    }

    /**
     * Make sure the chartservice get the new data when the component changes
     * @param changes
     */
    ngOnChanges(changes: SimpleChanges): void {
        if (changes['dataSet'] && changes['dataSet'].previousValue !== changes['dataSet'].currentValue) {
            this.chartService.data = changes['dataSet'].currentValue;
            this.setSelectedItem(this.chartService.data);
        }
        if (changes['addons']) {
            this.chartService.addons = changes['addons'].currentValue;
            if (changes['addons'].previousValue !== changes['addons'].currentValue) {
                this.reloadAddons();
            }
        }
    }

    /**
     * Creates an instance of addon component and inject it into sub component
     * @param addonsContainer
     * @param addons
     * @param onInitOnly boolean if true runs only once per instance
     */
    createAddons(addonsContainer: ViewContainerRef, addons: Addon[]): void {
        addonsContainer.clear();
        addons.forEach((addon) => {
            const factory = this._createAddonFactory(addon.type);
            const component: ComponentRef<any> = addonsContainer.createComponent(factory);
            ObjectHelper.mergeObjects(component.instance, addon);
        });
    }

    /**
     * Creates a factory for correct addons component
     * @param type
     * @return ComponentFactory<any>
     * @private
     */
    private _createAddonFactory(type: CHART_ADDON): ComponentFactory<any> {
        return this._componentFactoryResolver.resolveComponentFactory(AddonHelper.getAddonComponent(type));
    }

    /**
     * Removes click event and destroys tooltip element
     */
    ngOnDestroy(): void {
        this._destroyTooltipElement();
    }

    /**
     * Create tooltip element and append it to the selected element
     * Will be removed on destroy
     *
     * @param element An element from D3.select
     *
     * @example
     * this.createTooltip(D3.select('body'));
     */
    createTooltip(element, id = `cd-${UUID.create()}`): void {
        this._tooltipElement = element.append('div').attr('class', 'cui-tooltip').attr('id', id);
        this._tooltipElement.append('div').attr('class', 'cui-tooltip-text');
    }

    /**
     * Used to show and move the tooltip, should be used in a 'mousemove'
     * event with D3.event
     * @example
     * this.showTooltip('I like turtles', D3.event.pageX + 10, D3.event.pageY - 25);
     *
     * @param {string} label
     * @param {Pixels} left
     * @param {Pixels} top
     */
    showTooltip(label: string, left: Pixels, top: Pixels, options: any = {}): void {
        this._tooltipElement
            .style('opacity', 1)
            .selectAll('.cui-tooltip-text')
            .html(label);

        if (options.id) {
            const element = document.getElementById(options.id);
            top = top - element.offsetHeight + 20;
            left = left - element.offsetWidth / 2;
        }

        this._tooltipElement
            .style('left', left + 'px')
            .style('top', top + 'px');
        if (options.leftAlign) {
            this._tooltipElement.style('text-align', 'left');
        }
    }

    hideTooltip(): void {
        this._tooltipElement
            .style('opacity', 0)
            .selectAll('.cui-tooltip-text');
    }

    private _destroyTooltipElement(): void {
        if (this._tooltipElement) {
            this._tooltipElement.remove();
            this._tooltipElement = null;
        }
    }


    /**
     * Sets the activeItem from chartObject.selected property
     */
    setSelectedItem(data: ChartData[]): void {
        this.chartService.activeItem = null;
        if (data && data.length > 0) {
            this.chartService.activeItem = _.find(data, { 'selected': true });
        }
    }
}

/**
 * Alias for number
 */
type Pixels = number;
