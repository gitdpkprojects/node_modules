import {
    AfterViewInit,
    Component,
    ComponentFactoryResolver,
    HostBinding,
    HostListener,
    Input,
    OnChanges,
    Renderer2,
    SimpleChanges,
    ViewEncapsulation,
    OnInit
} from '@angular/core';

import { LINECHARTCONFIG, LineChartMargins } from '../../../core/constants/line-chart-config.constants';
import * as _ from 'lodash';
import * as D3 from 'd3';
import { ChartService } from '../chart.service';
import { ChartData } from '../../../core/models/chart.model';
import { ChartWithAddons } from '../chart-with-addons.class';
import { LINE_CHART_TYPE } from '../../../core/constants/line-chart.constant';
import { ChartHelper } from '../../../core/helpers/chart.helper';
import { WhitelabelService } from '../../../core/services/whitelabel.service';

@Component({
    selector: 'cui-line-chart',
    templateUrl: 'line-chart.component.html',
    styleUrls: ['../chart-base.scss', 'line-chart.component.scss'],
    providers: [ChartService],
    encapsulation: ViewEncapsulation.None
})

export class LineChartComponent extends ChartWithAddons implements AfterViewInit, OnChanges, OnInit {
    @HostBinding('class.cui-line-chart') addClass: boolean = true;

    /** @deprecated */
    @Input() ticks: number;

    @Input() title?: string;
    @Input() set colorSet(colorSet: Array<string>) {
        if ( colorSet) {
            this._colorSet = colorSet;
        } else {
            this._setWhitelabelColor();
        }
    }
    get colorSet() {
        return this._colorSet;
    }
    @Input() dataSet: Array<ChartData> = [];
    @Input() yTicks: number = 6;
    @Input() min: number;
    @Input() max: number;
    @Input() height: number;
    @Input() tickFormat: string;
    @Input() xTitle: string = '';
    @Input() yTitle: string = '';
    @Input() rotatedLabels: boolean = false;

    private _colorSet: Array<string>;
    private _svg: any;
    private _opacity: number = .65;
    private _axisTitleOpacity: number = .45;
    private _width: number;
    private _height: number;
    private _x: any;
    private _y: any;
    private _z: any;
    private _line: any;
    private _area: any;
    private _lines: any;
    private _type: LINE_CHART_TYPE;
    private _xLabelsRotated = false;

    constructor(
        private _chartService: ChartService,
        componentFactoryResolver: ComponentFactoryResolver,
        private _renderer: Renderer2,
        private _whitelabelService: WhitelabelService
    ) {
        super(componentFactoryResolver, _chartService);
        this._chartService.colorSet = this.colorSet;
        this._chartService.isInteractive = true;
        this._subscriptions.push(this._chartService.data$.subscribe((data) => {
            if (data.length > LINECHARTCONFIG.MAXLINES) {
                console.warn('Line chart warning: Maximum number of lines is limited to ' + LINECHARTCONFIG.MAXLINES + '.');
                this.ticks = 12;
                data = data.slice(0, LINECHARTCONFIG.MAXLINES);
            }

            if (this._svg) {
                this._setType();
                this._renderData();
                setTimeout(() => {
                    this._rotate();
                    this._crop();
                    this._updateLayout();
                });
                this._highlightActive();

            }
        }));

        // Whenever an item becomes active or null
        this._subscriptions.push(this._chartService.activeItem$.subscribe(() => {
            if (this._svg) {
                this._highlightActive();
            }
        }));
    }

    ngOnInit(): void {
        this._setWhitelabelColor();
    }

    /**
     * Bootstrap component
     */
    ngAfterViewInit(): void {
        this._setType();
        this._renderSvg();
        this.createTooltip(D3.select('body'));
        this._renderData();
        setTimeout(() => {
            this._rotate();
            this._crop();
            this._updateLayout();
            this._highlightActive();
        });

    }

    /**
     * Reload component on new data
     * @param changes
     */
    ngOnChanges(changes: SimpleChanges): void {
        // We need this timeout to make sure the svg has been rendered properly before reload is run
        // In some cases when data is added to the chart instantly (demo site) ngAfterViewInit and ngOnChanges
        // Will run at the same time which will lead to svg not beeing available for data to be rendered
        // TODO: Find a solution for this behaviour
        setTimeout(() => {
            this.reload();
        });
        super.ngOnChanges(changes);
        if (changes['colorSet'] && changes['colorSet'].previousValue !== changes['colorSet'].currentValue) {
            this.chartService.colorSet = changes['colorSet'].currentValue;
        }
    }

    /**
     * re-render
     */
    reload(): void {
        this._setWhitelabelColor();
        setTimeout(() => {
            this._setType();
            this._renderData();
            this._rotate();
            setTimeout(() => {
                this._crop();
                this._updateLayout();
                this._chartService.data = this.dataSet;
                this.createAddons(this.addonsContainer, this.addons);
            });
        });
    }

    /**
     * Sets linechart type based on dataset length
     */
    private _setType(): void {
        this._type = this.dataSet.length > 1 ? LINE_CHART_TYPE.LINE : LINE_CHART_TYPE.AREA;
    }

    /**
     * Runs when window is resized and recalculates chart containers and triggers update
     */
    @HostListener('window:resize', ['$event'])
    onResize(): void {
        if (this._svg) {
            this._renderData();
            this._updateLayout();
            setTimeout(() => {
                this._rotate();
                this._crop();
                this._updateLayout();
            });
        }
    }

    /**
     * Return an BARCHARTCONFIG.MARGINS object
     * With manipulated values
     * calculated depending on chart type
     *
     * @returns {any}
     */
    private _getMargins(): any {
        const margins: LineChartMargins = LINECHARTCONFIG.MARGINS;
        return {
            bottom: this._xLabelsRotated ? margins.bottom + 30 : margins.bottom,
            right: margins.right + this.xTitle.length,
            top: margins.top,
            left: margins.left + this.yTitle.length + 5
        };
    }

    private _setWhitelabelColor() {
        if ( !this._colorSet ) {
            this._colorSet = this._whitelabelService.getBrandColors(false);
        }
    }


    private _updateHeightWidth(): void {
        const margins = this._getMargins();
        this._width = this.element.nativeElement.offsetWidth - margins.left - margins.right;
        this._height = this.element.nativeElement.offsetHeight - margins.top - margins.bottom;
    }

    /**
     * Render component SVG to DOM
     */
    private _renderSvg(): any {
        const margins: LineChartMargins = this._getMargins();
        this._updateHeightWidth();

        this._svg = D3.select(this.element.nativeElement)
            .append('svg')
            .style('width', '100%')
            .style('height', '100%');

        this._svg.transition();

        const g = this._svg.append('g')
            .attr('class', 'axis--wrapper')
            .attr('transform', 'translate(' + margins.left + ',' + margins.top + ')');

        g.append('g')
            .attr('class', 'axis axis--x')
            .attr('fill', '#000')
            .style('font-size', '11px')
            .style('opacity', this._opacity)
            .attr('transform', 'translate(0,' + this._height + ')');

        g.select('.axis--x')
            .append('text')
            .attr('class', 'x--title')
            .attr('text-anchor', 'end')
            .attr('transform', 'translate(' + (this._width + margins.right) + ',17)')
            .text(this.xTitle)
            .style('fill', '#000')
            .style('font-size', '9px')
            .style('opacity', this._axisTitleOpacity);

        g.append('g')
            .attr('class', 'axis axis--y')
            .style('font-size', '11px')
            .style('fill', 'none')
            .style('stroke', 'none')
            .style('opacity', this._opacity);

        g.select('.axis--y')
            .append('text')
            .attr('class', 'y--title')
            .attr('fill', '#000')
            .style('font-size', '9px')
            .style('opacity', this._axisTitleOpacity)
            .attr('y', -20)
            .attr('text-anchor', 'end')
            .text(this.yTitle);

        const focus = g.append('g')
            .attr('class', 'focus')
            .style('display', 'none');

        focus.append('line')
            .attr('class', 'x-hover-line hover-line')
            .attr('y1', 0)
            .attr('y2', this._height);
    }

    /**
     * Update layout with recalculates values
     */
    private _updateLayout(): void {
        this._updateHeightWidth();
        const margins: LineChartMargins = this._getMargins();
        this._svg.select('.axis--wrapper')
            .attr('transform', 'translate(' + margins.left + ',' + margins.top + ')');

        this._svg.selectAll('.axis--x')
            .attr('transform', 'translate(0,' + this._height + ')');

        this._svg.selectAll('.x--title')
            .attr('transform', 'translate(' + (this._width + margins.right) + ',17)')
            .text(this.xTitle);

        this._svg.selectAll('.y--title')
            .text(this.yTitle);

        this._svg.selectAll('.x-hover-line')
            .attr('y2', this._height);

        this._svg.select('.axis--y')
            .transition().duration(LINECHARTCONFIG.DURATION)
            .selectAll('.tick line')
            .attr('x2', this._width)
            .attr('stroke', '#E5E6E6');

        this._svg.selectAll('.axis--x .tick line').remove();
    }

    /**
     * Render data as lines in the SVG
     */
    private _renderData(): void {
        this._x = D3.scaleTime().range([0, this._width]);
        this._y = D3.scaleLinear().range([this._height, 0]);

        // TODO: Understand why we need to unshift to get the proper colors
        const colors = _.cloneDeep(this.colorSet);
        colors.unshift('');
        this._z = D3.scaleOrdinal(colors);

        this._area = D3.area()
            .defined((d: any) => { return d; })
            .x((d: any) => this._x(d.date))
            .y0(this._height)
            .y1((d: any) => this._y(d.value));

        this.dataSet.forEach((d) => {
            d.value = +d.value;
        });

        this._lines = this.dataSet.map((data: ChartData) => {
            return {
                id: data.id,
                values: data.data.map((nestedData: ChartData) => {
                    return nestedData ? new ChartData({
                        id: nestedData.id,
                        date: nestedData.date,
                        label: data.label + (this.tickFormat ? `, ${D3.timeFormat(this.tickFormat)(new Date(nestedData.date))}` : ''),
                        value: nestedData.value,
                        parent: data
                    }) : null;
                })
            };
        });

        // set number of ticks based on data
        if (!this.ticks) {
            const maxLines = Math.max.apply(Math, this._lines.map((d) => d.values.length));
            this.ticks = maxLines < LINECHARTCONFIG.MAXLINES ? maxLines : LINECHARTCONFIG.MAXLINES;
        }

        const g = this._svg.select('g.axis--wrapper');

        const minFromData = parseInt(D3.min(this._lines, (c: any) => D3.min(c.values, (d: any) => d ? d.value : null)), 10);
        const maxFromData = parseInt(D3.max(this._lines, (c: any) => D3.max(c.values, (d: any) => d ? d.value : null)), 10);

        this._y.domain([
            !isNaN(this.min) && this.min < minFromData ? this.min : minFromData,
            !isNaN(this.max) && this.max > maxFromData ? this.max : maxFromData
        ]);
        this._z.domain(this._lines.map((c) => { return c.label; }));
        this._x.domain([
            D3.min(this._lines, (c: any) => { return D3.min(c.values, (d: any) => { return d ? d.date : null; }); }),
            D3.max(this._lines, (c: any) => { return D3.max(c.values, (d: any) => { return d ? d.date : null; }); })
        ]);

        g.select('.axis--y')
            .transition().duration(LINECHARTCONFIG.DURATION)
            .call(D3.axisLeft(this._y).ticks(this.yTicks));

        this._line = D3.line()
            .defined((d: any) => { return d; })
            .x((d: any) => { return this._x(d.date); })
            .y((d: any) => { return this._y(!d.value ? 0 : d.value); });

        if (this.tickFormat) {
            g.select('.axis--x')
                .transition().duration(LINECHARTCONFIG.DURATION)
                .call(D3.axisBottom(this._x)
                    .ticks(this.ticks)
                    .tickFormat(D3.timeFormat(this.tickFormat ? this.tickFormat : null)));
        } else {
            g.select('.axis--x')
                .transition()
                .call(D3.axisBottom(this._x).ticks(this.ticks));
        }

        // remove lines no longer in the dataset
        g.selectAll('.one-line, .one-area')
            .filter((d) =>
                this.dataSet.filter((comp) => d.id === comp.id).length < 1
            ).remove();

        let areas;
        if (this._type === LINE_CHART_TYPE.AREA) {
            // JOIN new data with old elements.
            areas = g.selectAll('.one-area').data(this._lines, (d) => d.id);

            // EXIT old elements not present in new data.
            areas.exit()
                .transition().duration(LINECHARTCONFIG.DURATION)
                .style('opacity', 0)
                .remove();

            // UPDATE old elements present in new data.
            areas
                .attr('id', (d) => `area-${d.id}`)
                .select('path')
                .transition().duration(LINECHARTCONFIG.DURATION)
                .style('fill', (d: any) => this._z(d.id))
                .attr('d', (d: any) => this._area(d.values));

            // ENTER new elements present in new data.
            areas.enter().append('g')
                .attr('class', 'one-area')
                .attr('id', (d) => `area-${d.id}`)
                .append('path')
                .transition().duration(LINECHARTCONFIG.DURATION)
                .attr('class', 'area')
                .style('fill', (d: any) => this._z(d.id))
                .attr('d', (d: any) => this._area(d.values));
        } else {
            // hide any areas in chart
            g.selectAll('.one-area')
                .transition().duration(LINECHARTCONFIG.DURATION)
                .style('opacity', '0')
                .remove();
        }

        // JOIN new data with old elements.
        const lines = g.selectAll('.one-line')
            .data(this._lines, (d) => d.id);

        // EXIT old elements not present in new data.
        lines.exit()
            .transition().duration(LINECHARTCONFIG.DURATION)
            .style('opacity', 0)
            .remove();

        // UPDATE old elements present in new data.
        lines
            .attr('id', (d) => `${d.id}`)
            .select('path')
            .transition().duration(LINECHARTCONFIG.DURATION)
            .style('stroke', (d: any) => this._z(d.id))
            .attr('d', (d: any) => this._line(d.values));

        // ENTER new elements present in new data.
        const newLines = lines.enter().append('g')
            .attr('class', 'one-line')
            .attr('id', (d) => `${d.id}`);

        newLines.append('path')
            .attr('class', 'line')
            .style('stroke', (d: any) => this._z(d.id))
            .attr('d', (d: any) => this._line(d.values));

        // JOIN new data with old elements.
        const dots = lines.selectAll('.dot')
            .data((d) => d.values, (d) => d.id);

        // EXIT old elements not present in new data.
        dots.exit()
            .transition().duration(LINECHARTCONFIG.DURATION)
            .style('opacity', 0)
            .remove();

        // UPDATE old elements present in new data.
        dots.transition().duration(LINECHARTCONFIG.DURATION)
            .style('stroke', (d: any) => this._z(d.parent.id))
            .style('fill', (d: any) => this._z(d.parent.id))
            .attr('id', (d) => `visible-dot-${d.id}`)
            .attr('data-value', (d) => d.value)
            .attr('r', 5)
            .attr('cx', (d) => this._x(d.date))
            .attr('cy', (d) => this._y(d.value));

        // ENTER new elements present in new data.
        dots.enter().append('circle')
            .attr('class', 'dot')
            .attr('id', (d) => `visible-dot-${d.id}`)
            .attr('data-value', (d) => d.value)
            .style('stroke', (d: any) => this._z(d.parent.id))
            .style('fill', (d: any) => this._z(d.parent.id))
            .attr('r', 5)
            .attr('cx', (d) => this._x(d.date))
            .attr('cy', (d) => this._y(d.value));

        // JOIN new data with old elements.
        const hoverDots = lines.selectAll('.hover-dot')
            .data((d) => d.values, (d) => d.id);

        // EXIT old elements not present in new data.
        hoverDots.exit()
            .transition().duration(LINECHARTCONFIG.DURATION)
            .style('opacity', 0)
            .remove();

        // UPDATE old elements present in new data.
        hoverDots.transition().duration(LINECHARTCONFIG.DURATION)
            .attr('id', (d) => `dot-${d.id}`)
            .attr('r', 15)
            .attr('cx', (d) => this._x(d.date))
            .attr('cy', (d) => this._y(d.value));

        // ENTER new elements present in new data.
        hoverDots.enter().append('circle')
            .attr('class', 'hover-dot')
            .attr('id', (d) => `dot-${d.id}`)
            .transition().duration(LINECHARTCONFIG.DURATION)
            .attr('r', 15)
            .attr('cx', (d) => this._x(d.date))
            .attr('cy', (d) => this._y(d.value))
            .attr('cx', (d) => this._x(d.date))
            .attr('cy', (d) => this._y(d.value));

        this._bindEvents();

        if (this._shouldRotateLabels()) {
            this._rotateXAxis(true);
        } else {
            this._rotateXAxis(false);
        }
    }

     /**
     *Determine if labels should be rotated. Either if rotatedLabels is set to true
     *  or if any label is wider than the size available.
     */
    private _shouldRotateLabels() {
        if ( this._svg && this._svg.node ) {
            const labelIsWider = ChartHelper.isLabelWiderThanContainer(this._svg.node(), this.ticks);
            if ( this.rotatedLabels || labelIsWider) {
                return true;
            }
        }
        return false;
    }
    private _crop() {
        if ( this._svg) {
            const margin: LineChartMargins = this._getMargins();
            this._svg.selectAll('.axis--x')
                    .attr('transform', 'translate(0,' + this._height + ')');
            this._svg = ChartHelper.cropBarChartLabel(this._svg.node(), this._xLabelsRotated, this.ticks, margin.bottom);
        }

    }
    private _rotateXAxis(rotate: boolean) {
        let rotationString = '';
        let xOffset = 0.5;
        let yOffset = 9;
        if (rotate) {
             rotationString = 'rotate(-45)';
             xOffset = -22;
             yOffset = 7;
        }

        this._svg.selectAll('.axis--x')
            .selectAll('.tick')
            .selectAll('text')
            .attr('y', 0)
            .attr('x', xOffset)
            .attr('y', yOffset)
            .attr('transform', rotationString);
    }
    private _rotate() {
        const shouldRotateLabels = this._shouldRotateLabels();
        if (shouldRotateLabels ) {
            this._rotateXAxis(true);
            this._xLabelsRotated = true;
        } else if ( !shouldRotateLabels ) {
            if ( this._xLabelsRotated) {
                this._xLabelsRotated = false;
                this._rotateXAxis(false);
            }
        }
        this._updateLayout();
    }

    /**
     * Bind mouse click and hover events to lines
     */
    private _bindEvents(): void {
        const focus = this._svg.select('.focus');
        this._renderer.listen(this.element.nativeElement, 'mouseleave', () => {
            focus.style('display', 'none');
            this._svg.selectAll('.dot:not(.active)').style('opacity', 0);
        });
        this._svg.selectAll('.hover-dot')
            .on('mouseover', (chartData, index, array) => {
                if (D3.select(array[index]).attr('class') !== 'hover-dot disabled') {
                    this._svg.selectAll('.dot:not(.active)').style('opacity', 0);
                    this._svg.select(`#visible-dot-${chartData.id}`).style('opacity', 1);
                    this.showTooltip(`${chartData.value}`, D3.event.pageX + 5, D3.event.pageY - 35);
                    this._chartService.hoverItem = chartData.parent;
                }
            })
            .on('mousemove', (chartData, index, array) => {
                if (D3.select(array[index]).attr('class') !== 'hover-dot disabled') {
                    focus.style('display', 'block');
                    focus.attr('transform', 'translate(' + this._x(chartData.date) + ',' + this._y(chartData.value) + ')');
                    focus.select('.x-hover-line').attr('y2', this._height - this._y(chartData.value));
                }
            })
            .on('mouseleave', () => {
                if (!this._chartService.activeItem && this._type === LINE_CHART_TYPE.LINE) {
                    focus.style('display', 'none');
                    this._svg.selectAll('.dot').style('opacity', 0);
                    this._chartService.hoverItem = null;
                }
                this.hideTooltip();
            })
            .on('click', (chartData) => {
                this._chartService.activeItem = chartData;
            });
    }

    /**
     * Highlight or un-highlight active line
     */
    private _highlightActive(): void {
        // Highlight new active Item
        const focus = this._svg.select('.focus');
        this._svg.selectAll('.hover-dot').attr('class', 'hover-dot');
        this._svg.selectAll('.dot').attr('class', 'dot').style('opacity', 0);
        if (this._chartService.activeItem) {
            const id = this._chartService.activeItem.parent
                ? this._chartService.activeItem.parent.id
                : this._chartService.activeItem.id;
            this._svg.selectAll('.one-line, .one-area').style('opacity', 0.2);
            this._svg.selectAll(`#${id}, #area-${id}`).style('opacity', 1);
            Array.from(this.element.nativeElement.querySelectorAll('.one-line'))
                .sort((_element: HTMLElement) => _element.getAttribute('id') !== id ? -1 : 1)
                .forEach((line) => {
                    this.element.nativeElement.querySelector('.axis--wrapper').appendChild(line);
                });
            this._svg.selectAll(`.one-line:not(#${id}) .hover-dot`).attr('class', 'hover-dot disabled');
            // if the click comes from the legend addon (it doesn't have a parent)
            if (!this._chartService.activeItem.parent) {
                this._svg.selectAll('.dot').attr('class', 'dot').style('opacity', 0);
            } else {
                // if the click comes from clicking a dot
                const { id: activeId, date, value } = this._chartService.activeItem;
                this._svg
                    .select(`#visible-dot-${activeId}`)
                    .attr('class', 'dot active').style('opacity', 1);
                focus.attr('transform', 'translate(' + this._x(date) + ',' + this._y(value) + ')');
                focus.select('.x-hover-line').attr('y2', this._height - this._y(value));
            }
        } else {
            focus.style('display', 'none');
            this._svg.selectAll('.dot').style('opacity', 0);
            this._svg.selectAll('.one-line, .one-area').style('opacity', 1);
        }
    }
}
