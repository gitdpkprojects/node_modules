import {
    OnInit,
    AfterViewInit,
    Component,
    ComponentFactoryResolver,
    HostBinding,
    Input,
    OnChanges,
    SimpleChanges,
    ViewEncapsulation,
    NgZone
    }
    from '@angular/core';

import { BARCHARTCONFIG, BarChartMargins } from '../../../core/constants/bar-chart-config.constants';
import * as _ from 'lodash';
import * as D3 from 'd3';
import { ChartService } from '../chart.service';
import { ChartData } from '../../../core/models/chart.model';
import { ChartWithAddons } from '../chart-with-addons.class';
import { BAR_CHART_TYPE } from '../../../core/constants/bar-chart.constants';
import { UUID } from '../../../core/helpers/uuid.class';
import { ColorHelper } from '../../../core/helpers/color.helper';
import { ChartHelper } from '../../../core';
import { ResizeService } from '../../../core/services/resize.service';
import { WhitelabelService } from '../../../core/services/whitelabel.service';
import { COLORWHITELABEL } from '../../../core/constants/color.whitelabel';

@Component({
    selector: 'cui-bar-chart',
    templateUrl: 'bar-chart.component.html',
    styleUrls: ['../chart-base.scss', 'bar-chart.component.scss'],
    providers: [ChartService, ResizeService],
    encapsulation: ViewEncapsulation.None
})
export class BarChartComponent extends ChartWithAddons implements OnInit, AfterViewInit, OnChanges {
    @HostBinding('class.cui-bar-chart') addClass: boolean = true;

    @Input() title?: string = '';
    @Input() set color(color: string) {
        if (color) {
            this._color = color;
        } else {
            this._setWhitelabelColor();
        }
    }
    get color() {
        return this._color;
    }
    @Input() dataSet: Array<ChartData> = [];
    @Input() type: BAR_CHART_TYPE = BAR_CHART_TYPE.VERTICAL;
    @Input() ticks: number = BARCHARTCONFIG.DEFAULT_TICKS;
    @Input() height: number = 0;
    @Input() xTitle: string = '';
    @Input() yTitle: string = '';
    @Input() rotatedLabels: boolean = false;

    private _color: string;
    private _svg: any;
    private _colors: (index: number) => string;
    private _width: number;
    private _height: number;
    private _x: any;
    private _y: any;
    private _clipID: string;
    private _didWarnAboutDatasetLength: boolean = false;
    private _xLabelsRotated = false;

    constructor(private _chartService: ChartService,
                componentFactoryResolver: ComponentFactoryResolver,
                private _resizeService: ResizeService,
                private _zone: NgZone,
                private _whitelabelService: WhitelabelService) {
        super(componentFactoryResolver, _chartService);

        this._chartService.isInteractive = true;
        this._chartService.addMiddleware((data: Array<ChartData>) => {
            if (!this._didWarnAboutDatasetLength && data.length > BARCHARTCONFIG.MAXBARS) {
                this._didWarnAboutDatasetLength = true;
                console.warn(`Maximum number of bars are limited to ${BARCHARTCONFIG.MAXBARS}. The chart has been sliced down.`);
            }
            return data.slice(0, BARCHARTCONFIG.MAXBARS);
        });
        this._subscriptions.push(this._chartService.data$.subscribe((data) => {
            if (this._svg) {
                this._createColorFunction();
                this._chartService.colorSet = data.map((chartData) => this._colors(this._getItemFillColorIndex(chartData)));
                this._renderSvgData();
                this._rotate();
                const margin: any = this._getMargins();
                this._width = this.element.nativeElement.offsetWidth - margin.left - margin.right;
                this._height = this.element.nativeElement.offsetHeight - margin.top - margin.bottom;
                this._svg.style('min-height', this.element.nativeElement.offsetHeight);
                this._renderSvgData();
                this._crop();
                this._updateLayout();
            }
            this.setSelectedItem(data);
            if (this._chartService.hoverItem) {
                D3.selectAll('#' + this._chartService.hoverItem.id)
                    .style('fill', this._chartService.hoverItem.color || this.color)
                    .style('cursor', 'pointer')
                    .style('opacity', 1);
            }
        }));
        this._subscriptions.push(this._resizeService.resize$.subscribe(() => {
            this._zone.runOutsideAngular(() => {
                this._zone.run(() => {
                    this._resize();
                });
            });
        }));
        this._subscriptions.push(this._chartService.hoverItem$.subscribe((item: ChartData) => {
            if (item) {
                D3.selectAll('#' + item.id)
                    .style('fill', item.color || this.color)
                    .style('cursor', 'pointer')
                    .style('opacity', 1);
            } else {
                this._highlightActive();
            }
        }));

        // Whenever an item becomes active or null
        this._subscriptions.push(this._chartService.activeItem$.subscribe(() => {
            if (this._svg) {
                this._highlightActive();
            }
        }));
        // On whitelabel change
        this._subscriptions.push(this._whitelabelService._whitelabelingLoaded.subscribe(() => {
            this.reload();
        }));

        this._clipID = UUID.create();
    }

    ngOnInit(): void {
        this._setWhitelabelColor();
        this._chartService.data = this.dataSet;
    }

    /**
     * Bootstrap component
     */
    ngAfterViewInit(): void {
        this.createTooltip(D3.select('body'));
        setTimeout(() => {
            this.createChart();
        });
        super.ngAfterViewInit();
    }

    /**
     * Function to handle property updates
     */
    ngOnChanges(changes: SimpleChanges): void {
        if (changes['type'] ||
            changes['xTitle'] ||
            changes['yTitle'] ||
            changes['color']
        ) {
            if (this._svg) {
                this.reload();
            }
        }
        if ( changes['rotatedLabels'] ) {
            this._xLabelsRotated = this.rotatedLabels;
        }

        super.ngOnChanges(changes);
    }

    get _renderData(): ChartData[] {
        if (this.type === BAR_CHART_TYPE.VERTICAL) {
            return this.dataSet;
        }
        return this.dataSet.slice().reverse();
    }

    createChart(): void {
        this._createColorFunction();
        this._renderSvg();
        this._renderSvgData();
        this._rotate();
        this._chartService.data = this.dataSet;
        this._chartService.color = this.color;
        const margin: BarChartMargins = this._getMargins();
        this._width = this.element.nativeElement.offsetWidth - margin.left - margin.right;
        this._height = this.element.nativeElement.offsetHeight - margin.top - margin.bottom;
        this._svg.style('min-height', this.element.nativeElement.offsetHeight);

        setTimeout(() => {
            this._crop();
            this._updateLayout();

        });


    }

    /**
     * Re-render svg and data
     */
    public reload(): void {
        this._setWhitelabelColor();
        this.createAddons(this.addonsContainer, this.addons);
        setTimeout(() => {
            this._svg.remove();
            this._svg = null;
            this.createChart();
            this._calculateHeight();

        });
    }

    /**
     * Runs when window is resized and recalculates chart containers and triggers update
    */
    private _resize() {
        if ( this._svg) {
                this._rotate();
                const margin: BarChartMargins = this._getMargins();
                this._width = this.element.nativeElement.offsetWidth - margin.left - margin.right;
                this._height = this.element.nativeElement.offsetHeight - margin.top - margin.bottom;
                this._svg.style('min-height', this.element.nativeElement.offsetHeight);
                this._renderSvgData();
            this._zone.onStable.asObservable().subscribe(() => {
                this._crop();
                this._updateLayout();
            });
        }
    }

    /**
     * Calculate color-offsets based on dataSet-length
     * 0 is ~17% color and 100 is ~83% color
     */
    private _createColorFunction(): void {
        if (this.dataSet[0] && this.dataSet[0].color) {
            const colors = this._renderData.map(item => ColorHelper.tintColor(item.color, 0.17));
            this._colors = (index) => {
                return colors[index];
            };
        } else {
            this._colors = D3.scaleLinear<string>()
                .domain([-20, 120])
                .range(['white', this.color])
                .interpolate(D3.interpolateRgb);
        }
    }

    /**
     * Get Fill-color for current item
     *
     * @param chartData ChartData
     * @returns {number}
     */
    private _getItemFillColorIndex(chartData: ChartData): number {
        if (chartData.color) {
            return this._renderData.findIndex(_chartData => _chartData.id === chartData.id);
        } else {
            const highestValue = _.maxBy(this.dataSet, 'value').value;
            return Math.floor(chartData.value / highestValue * 100);
        }
    }

    /**
     * Return an BARCHARTCONFIG.MARGINS object
     * With manipulated values
     * calculated depending on chart type
     *
     * @returns {any}
     */
    private _getMargins(): any {
        const margin: any = _.cloneDeep(BARCHARTCONFIG.MARGINS);
        margin.bottom = this._xLabelsRotated ? margin.bottom + 30 : margin.bottom;
        margin.right += this.xTitle.length;
        margin.left += (this.yTitle.length + 5 );
        margin.top += (this.type === BAR_CHART_TYPE.HORIZONTAL) ? 10 : 0;
        return margin;
    }

    /**
     * Render component SVG to DOM
     */
    private _renderSvg(): void {
        const margin: BarChartMargins = this._getMargins();
        this._width = this.element.nativeElement.offsetWidth - margin.left - margin.right;
        this._height = this.element.nativeElement.offsetHeight - margin.top - margin.bottom;
        if (this.type === BAR_CHART_TYPE.VERTICAL) {
            this._x = D3.scaleBand();
            this._y = D3.scaleLinear();
        } else {
            this._x = D3.scaleLinear();
            this._y = D3.scaleBand();
        }
        this._svg = D3.select(this.element.nativeElement)
            .append('svg')
            .style('width', '100%')
            .style('height', '100%');
        const g = this._svg.append('g')
            .attr('class', 'axis--wrapper')
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
        // Y-axis
        g.append('g')
            .attr('class', 'axis axis--y')
            .style('font-size', '11px')
            .style('fill', 'none')
            .style('stroke', 'none')
            .style('opacity', BARCHARTCONFIG.OPACITY)
            // Y-axis title
            .append('text')
            .text(this.yTitle)
            .attr('text-anchor', 'end')
            .attr('transform', 'translate(-10,-15)')
            .style('fill', '#000')
            .style('font-size', '9px')
            .style('opacity', BARCHARTCONFIG.AXIS_TITLE_OPACITY);
        // X-axis
        g.append('g')
            .attr('class', 'axis axis--x')
            .attr('transform', 'translate(0,' + this._getHeight() + ')')
            .style('font-size', '11px')
            .style('fill', 'none')
            .style('stroke', 'none')
            .style('opacity', BARCHARTCONFIG.OPACITY)
            // X-axis title
            .append('text')
            .attr('class', 'x--title')
            .text(this.xTitle)
            .attr('transform', 'translate(' + this._getWidth() + ',17)')
            .style('fill', '#000')
            .style('font-size', '9px')
            .style('opacity', BARCHARTCONFIG.AXIS_TITLE_OPACITY);
        // Bar container
        g.append('g')
            .style('width', '100%')
            .style('height', '100%')
            .attr('class', 'axis--bars');
        this._svg.append('clipPath')
            .attr('id', 'barcut' + this._clipID)
            .attr('class', 'bar-clip')
            .append('rect')
            .attr('class', 'bar-clip-rect')
            .attr('x', 0)
            .attr('width', this._getWidth())
            .attr('y', 0)
            .attr('height', this._getHeight());
        this._svg.style('min-height', this.element.nativeElement.offsetHeight);
    }

    /**
     *Determine if labels should be rotated. Either if rotatedLabels is set to true
     *  or if any label is wider than the size available.
     */
    private _shouldRotateLabels() {
        if ( this._svg && this._svg.node() ) {
            const labelIsWider = ChartHelper.isLabelWiderThanContainer(this._svg.node(), this.dataSet.length);
            if ( this.rotatedLabels || labelIsWider) {
                return true;
            }
        }
        return false;
    }

    /**
     * Update layout with recalculates values
     */
    private _updateLayout(): void {
        let xAxisOffset = this._getWidth();
        if ( this._xLabelsRotated) {
            xAxisOffset = this._getWidth() + 32;
        }
        this._svg.selectAll('.x--title')
            .attr('transform', 'translate(' + xAxisOffset + ',17)');
        this._svg.selectAll('.bar-clip-rect')
            .attr('width', this._getWidth());
        this._svg.selectAll('.axis--bars')
            .attr('width', this._getWidth());
        this._y.rangeRound([this._getHeight(), 0]);
        this._svg.selectAll('.bar-clip')
            .selectAll('.bar-clip-rect')
            .attr('height', this._getHeight());
        this._svg.selectAll('.axis--x')
            .attr('transform', 'translate(0,' + this._getHeight() + ')');
        this._x.rangeRound([0, this._getWidth() ]);
        this._y.rangeRound([this._getHeight(), 0], .1);
        if (this.type === BAR_CHART_TYPE.HORIZONTAL) {
            this._svg.selectAll('.axis--x')
            .attr('transform', 'translate(0,' + this._getHeight() + ')');
            this._svg.selectAll('.axis--bars')
                .selectAll('.bar')
                .attr('clip-path', 'url(#barcut' + this._clipID + ')')
                .attr('width', (d) => this._x(d.value));
                this._y.rangeRound([this._getHeight(), 0]);
                this._svg.selectAll('.bar-clip')
                    .selectAll('.bar-clip-rect')
                        .attr('height', this._getHeight());
                this._svg.selectAll('.axis--y').call(D3.axisLeft(this._y).ticks(this.ticks));
        }



    }

    private _getWidth() {
        if ( isNaN(this._width)) {
            return 0;
        }
        return Math.max(0, this._width);
    }
    private _getHeight() {
        if ( isNaN(this.height)) {
            return 0;
        }
        return Math.max(0, this._height);
    }

    private _calculateBarPadding(): number {
        let padding: number;
        let barBaseWidth: number;
        const barCount: number = this.dataSet.length;
        if (this.type === BAR_CHART_TYPE.VERTICAL) {
            padding = 16;
            barBaseWidth = this._getWidth() / barCount - padding;
        } else {
            padding = 8;
            barBaseWidth = this._height / barCount - padding;
        }
        return padding / (barBaseWidth + padding);
    }

    /**
     * Render data as bars in the SVG
     */
    private _renderSvgData(redrawLabels: boolean = true): void {
        if ( this._svg) {
            const padding: number = this._calculateBarPadding();
            let maxValue: any = D3.max(this.dataSet, (d) => d.value as number);
            const xLength: number = (this.type === BAR_CHART_TYPE.HORIZONTAL && this.xTitle.length)
                ? this._getWidth() - (this.xTitle.length + 28) : this._getWidth();

            maxValue = (maxValue === 0) ? 100 : maxValue;

            this._x.rangeRound([0, xLength]);
            this._y.rangeRound([this._height, 0]);

            if (this.type === BAR_CHART_TYPE.VERTICAL) {
                this._x.padding(padding);
                this._x.domain(this._renderData.map((d) => d.label));
                this._y.domain([0, maxValue]).nice();
            } else {
                this._y.padding(padding);
                this._x.domain([0, maxValue]).nice();
                this._y.domain(this._renderData.map((d) => d.label));
            }

            if (this.type === BAR_CHART_TYPE.VERTICAL) {
                this._svg.selectAll('.axis--x').call(D3.axisBottom(this._x));
                this._svg.selectAll('.axis--y').call(D3.axisLeft(this._y).ticks(this.ticks));
                this._svg.selectAll('.axis--y').selectAll('.tick')
                    .selectAll('line')
                    .remove();
                this._svg.selectAll('.axis--y').selectAll('.tick')
                    .append('line')
                    .attr('class', 'axis-y-line')
                    .attr('x1', 0)
                    .attr('y1', 0)
                    .attr('x2', this._getWidth())
                    .attr('y2', 0)
                    .style('stroke', '#E5E6E6');
            } else {
                this._svg.selectAll('.axis--x').call(D3.axisBottom(this._x).ticks(this.ticks));
                this._svg.selectAll('.axis--y').call(D3.axisLeft(this._y));
                this._svg.selectAll('.axis--x').selectAll('.tick')
                    .selectAll('line')
                    .remove();
                    this._svg.selectAll('.axis--x').selectAll('.tick')
                        .append('line')
                        .attr('class', 'axis-x-line')
                        .attr('x1', 0)
                        .attr('y1', 0)
                        .attr('x2', 0)
                        .attr('y2', `-${this._getHeight()}`)
                        .style('stroke', '#E5E6E6');
            }

            const bars = this._svg.selectAll('.axis--bars')
                .selectAll('.bar')
                .data(this._renderData);

            const barsExit = bars.exit()
                .transition()
                .duration(BARCHARTCONFIG.DURATION)
                .style('fill-opacity', 1e-6);
            if (this.type === BAR_CHART_TYPE.VERTICAL) {
                barsExit
                    .attr('y', this._y(0))
                    .attr('height', this._getWidth() - this._y(0));
            } else {
                barsExit
                    .attr('x', this._x(0))
                    .attr('width', this._getWidth() - this._x(0));
            }
            barsExit.remove();

            const barsEnter = bars.enter()
                .append('rect')
                .attr('clip-path', 'url(#barcut' + this._clipID + ')')
                .attr('class', 'bar bar--value')
                .attr('id', (d) => { return d.id; })
                .attr('data-value', (d) => { return d.value; })
                .attr('rx', 4);

            if (this.type === BAR_CHART_TYPE.VERTICAL) {
                barsEnter
                    .style('fill', (d) => d.color || this._colors(this._getItemFillColorIndex(d)))
                    .attr('x', (d) => this._x(d.label) + this._findXposition())
                    .attr('width', () =>  this._verticalBarWidth())
                    .attr('y', () => this._getHeight())
                    .attr('height', () => BARCHARTCONFIG.BARRADIUS);
                if ( redrawLabels) {
                    barsEnter
                        .attr('x', (d) => this._x(d.label) + this._findXposition());
                }

            } else {
                this._calculateHeight();
                barsEnter
                    .style('fill', (d) => d.color || this._colors(this._getItemFillColorIndex(d)))
                    .attr('x', () => `-${BARCHARTCONFIG.BARRADIUS}`)
                    .attr('height', () =>  {
                        const height = this._horizontalBarHeight();
                        return height;
                    })
                    .attr('y', (d) =>  {
                    return this._y(d.label);
                    })
                    .attr('width', () => BARCHARTCONFIG.BARRADIUS)
                    .attr('transform', () => {
                        const barOffset = this._horizontalBarOffset();
                        return 'translate(0, ' + barOffset
                        + ')';
                    });

            }

            if (this.type === BAR_CHART_TYPE.VERTICAL) {
                bars.transition()
                    .duration(BARCHARTCONFIG.DURATION)
                    .attr('y', (d) => this._y(d.value))
                    .attr('height', (d) => this._getHeight() - this._y(d.value) + BARCHARTCONFIG.BARRADIUS);
            } else {
                bars.transition()
                    .duration(BARCHARTCONFIG.DURATION)
                    .attr('width', (d) => this._x(d.value) + BARCHARTCONFIG.BARRADIUS);
            }

            if (this.type === BAR_CHART_TYPE.VERTICAL ) {
                this._svg.selectAll('.axis--bars')
                    .selectAll('.bar')
                    .attr('width', () =>  this._verticalBarWidth())
                    .attr('x', (d) => this._x(d.label) + this._findXposition());

            }

            this._highlightActive();

            // Bind mouse events
            bars
                .on('mousemove', (d) => {
                    this.showTooltip(d.value, D3.event.pageX + 10, D3.event.pageY - 25);
                })
                .on('mouseover', (chartData) => {
                    this._chartService.hoverItem = chartData;
                })
                .on('mouseout', () => {
                    this._chartService.hoverItem = null;
                    this.hideTooltip();
                })
                .on('click', (chartData) => {
                    this._chartService.activeItem = chartData;
                });
        }
    }

    private _setWhitelabelColor() {
        if (!this._color) {
            this._color = this._whitelabelService.getPropertyValue(COLORWHITELABEL.BRAND_PRIMARY);
        }
    }

    private _crop() {
            const margin: BarChartMargins = this._getMargins();
            this._svg.selectAll('.axis--x')
                    .attr('transform', 'translate(0,' + this._getHeight() + ')');
            if (this.type === BAR_CHART_TYPE.VERTICAL) {
                this._svg = ChartHelper.cropBarChartLabel(this._svg.node(), this._xLabelsRotated, this.dataSet.length, margin.bottom);
            }
    }
    private _horizontalBarOffset(): number {
        if (this._y.bandwidth() > BARCHARTCONFIG.MAX_HORIZONTAL_BARWIDTH ) {
            return this._y.bandwidth() / 2 - BARCHARTCONFIG.MAX_HORIZONTAL_BARWIDTH / 2;
        } else if ( this._y.bandwidth() < BARCHARTCONFIG.MIN_HORIZONTAL_BARWIDTH ) {
            return this._y.bandwidth() / 2 - BARCHARTCONFIG.MIN_HORIZONTAL_BARWIDTH / 2;
        } else {
            return 0;
        }
    }
    private _horizontalBarHeight(): number {
        if (this._y.bandwidth() > BARCHARTCONFIG.MAX_HORIZONTAL_BARWIDTH ) {
           return BARCHARTCONFIG.MAX_HORIZONTAL_BARWIDTH;
        } else if (this._y.bandwidth() < BARCHARTCONFIG.MIN_HORIZONTAL_BARWIDTH) {
            return BARCHARTCONFIG.MIN_HORIZONTAL_BARWIDTH;
        }
        return this._y.bandwidth();
    }

    private _verticalBarWidth(): number {
        if ( this._x.bandwidth()) {
            if (this._x.bandwidth() > BARCHARTCONFIG.MAX_VERTICAL_BARWIDTH ) {
                return BARCHARTCONFIG.MAX_VERTICAL_BARWIDTH;
             } else if (this._x.bandwidth() < BARCHARTCONFIG.MIN_VERTICAL_BARWIDTH) {
                 return BARCHARTCONFIG.MIN_VERTICAL_BARWIDTH;
             }
             return this._x.bandwidth();
        }
        return BARCHARTCONFIG.MAX_VERTICAL_BARWIDTH;
    }

    private _calculateHeight(): void {
        const minHeight = 280;
        const padding = 8;
        const margins = this._getMargins();
        const totalHeight: number = ( (this._horizontalBarHeight() + padding) *  this.ticks );
        if ( totalHeight > this._height && totalHeight > minHeight) {
            this.height = totalHeight;
            this._height = totalHeight - margins.top - margins.bottom;
            this._updateLayout();
        }
    }
    private _rotate() {
        const shouldRotateLabels = this._shouldRotateLabels();
        if (this.type === BAR_CHART_TYPE.VERTICAL && shouldRotateLabels ) {
            this._rotateXAxis(true);
            this._xLabelsRotated = true;
        } else if ( !shouldRotateLabels ) {
            if ( this._xLabelsRotated) {
                this._xLabelsRotated = false;
                this._rotateXAxis(false);
            }
        }
        this._updateLayout();
    }

    /**
     * Find x-position for x-axix label based on max-width
     */
    private _findXposition(): number {
        if (this._x.bandwidth() < BARCHARTCONFIG.MAX_VERTICAL_BARWIDTH) {
            return 0;
        } else {
            return (this._x.bandwidth() / 2 - BARCHARTCONFIG.MAX_VERTICAL_BARWIDTH / 2);
        }
    }

    private _rotateXAxis(rotate: boolean) {
        let rotationString = '';
        let xOffset = 0;
        if (rotate) {
             rotationString = 'rotate(-45)';
             xOffset = -32;
        }

        this._svg.selectAll('.axis--x')
            .selectAll('text')
            .attr('y', 0)
            .attr('x', xOffset)
            .attr('transform', rotationString);
    }

    /**
     * Higlight active bar
     * Or reset colors to all bars if no item is selected
     */
    private _highlightActive(): void {
        // Highlight new active Item
        if (this._chartService.activeItem) {
            if (this._chartService.activeItem.color) {
                this._svg.selectAll('.bar')
                    .style('fill', (d) => ColorHelper.tintColor(d.color, 0.83));
            } else {
                this._svg.selectAll('.bar')
                    .style('fill', this._colors(0));
            }

            this._svg.selectAll('#' + this._chartService.activeItem.id)
                .style('fill', this._chartService.activeItem.color || this.color);

        } else {
            this._svg.selectAll('.bar')
                .style('fill', (d) => this._colors(this._getItemFillColorIndex(d)));
        }
    }
}
