import { Component, HostBinding, Input, OnInit, ViewChild, ViewContainerRef, ViewEncapsulation } from '@angular/core';
import { ChartData } from '../../../../core/models/chart.model';
import { ChartService } from '../../chart.service';
import * as D3 from 'd3';
import * as _ from 'lodash';
import { ScaleLinear } from 'd3-scale';
import { PIECHARTCONFIG } from '../../../../core/constants/pie-chart-config';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../../../core/classes';
import { AddonHelper } from '../addon.helper';
import { TranslateService } from '@ngx-translate/core';

@Component({
    selector: 'cui-legend-addon',
    templateUrl: 'legend-addon.component.html',
    styleUrls: ['legend-addon.component.scss'],
    encapsulation: ViewEncapsulation.None
})
@UnSub()
export class LegendAddonComponent implements OnInit {
    @HostBinding('class.cui-legend-addon') addClass: boolean = true;
    @Input() data: Array<ChartData> = [];
    @Input() color: string;
    @Input() colorSet: Array<string>;
    _colorSet: Array<string>;
    activeItem: ChartData;
    colors: ScaleLinear<string, string> = D3.scaleLinear<string>();
    tooltip: any;
    label: string = 'More';
    _subscriptions: Array<Subscription> = [];
    customData: ChartData[];

    @ViewChild('customToolTip', { read: ViewContainerRef }) customToolTip;
    constructor(private _chartService: ChartService,
        private _translateService: TranslateService) {
        this._subscriptions.push(_chartService.data$.subscribe((data) => {
            this.setColors();
            this.isToggler();
            if (this.customData) {
                this.renderLegendData(this.customData);
            } else {
                this.renderLegendData(data);
            }
        }));
        this._subscriptions.push(_chartService.color$.subscribe((color) => this.color = color));
        if (_chartService.colorSet) {
            this.colorSet = _chartService.colorSet;
            this._colorSet = _chartService.colorSet;
        }
        this._subscriptions.push(_chartService.colorSet$.subscribe((colorSet) => {
            this.colorSet = colorSet;
            this._colorSet = colorSet;
        }));
        this._subscriptions.push(_chartService.activeItem$.subscribe((item: ChartData) => {
            this.activeItem = item;
            if (item && _chartService.stackedKeys) {
                this.data = _chartService.stackedKeys.map(key => new ChartData({ label: key, value: item[key] }));

                const chartObj: ChartData = _.find(this.data, { 'label': _chartService.miscLabel });
                if (chartObj) {
                    chartObj.misc = this._chartService.stackedExtraKeys ? (
                        this._chartService.stackedExtraKeys.map(key => new ChartData(
                            { label: key, value: item[key] }))) : null;
                }

            } else if (!item && _chartService.stackedKeys) {
                this.data = _chartService.stackedKeys.map(key => new ChartData(
                    { label: key, value: this.summarise(_chartService.data, key) }));

                const chartObj: ChartData = _.find(this.data, { 'label': _chartService.miscLabel });
                if (chartObj) {
                    chartObj.misc = this._chartService.stackedExtraKeys ? (
                        this._chartService.stackedExtraKeys.map(key => new ChartData(
                            { label: key, value: this.summarise(_chartService.data, key) }))) : null;
                }
            }
        }));
    }

    ngOnInit(): void {
        this.setColors();
        if (this._chartService.colorSet) {
            this.colorSet = this._chartService.colorSet;
            this._colorSet = this._chartService.colorSet;
        }
        this.activeItem = this._chartService.activeItem;
        if (this.customData) {
            this.renderLegendData(this.customData);
        } else if (this._chartService.data) {
            this.renderLegendData(this._chartService.data);
        }
    }

    /**
     * Returns summarised value of items
     * @param items
     * @param attr
     * @returns {number}
     */
    summarise(items: any[], attr: string): any {
        return items.reduce((a, b) => a + b[attr], 0);
    }
    /**
     * Returns true if item is active, false if not active
     * @param item
     * @returns {boolean|any}
     */
    isActive(item): boolean {
        return (item === this.activeItem) ||
            (this.activeItem && this.activeItem.parent && this.activeItem.parent.label === item.label) ||
            (this._chartService.stackedKeys && this._chartService.stackedKeys.length > 0);
    }

    /**
     * Sets the colors properly with regards to the dataset
     */
    setColors(): void {
        if (this._chartService.data) {
            this.colors = D3.scaleLinear<string>()
                .domain([0, this._chartService.data.length])
                .range([this.color, 'white'])
                .interpolate(D3.interpolateRgb);
        }
    }

    /**
     * Returns color based on index number and isInteractive value
     * @param index
     * @returns {string}
     */
    getBgColor(index: number): string {
        if (this._colorSet) {
            return this._colorSet[index];
        } else if (this._chartService.isInteractive) {
            return this.colors(index);
        }
        return null;
    }

    /**
     * Sets new chart data item as active within chart
     * @param item
     */
    setActiveItem(item: ChartData): void {
        // set active item back to default (null) if we toggle the already active item
        if (this._chartService.isInteractive && !this._chartService.stackedKeys) {

            if (this._chartService.activeItem && (this._chartService.activeItem === item && item.link)) {
                this._chartService.activeItem = item;
                return;
            } else if (this._chartService.activeItem === item ||
                (this._chartService.activeItem && this._chartService.activeItem.parent === item)) {

                this._chartService.activeItem = null;
            } else {
                this._chartService.activeItem = item;
            }
        }
    }

    /**
     * Sets new chart data item as active within chart
     * @param item
     */
    setActiveItemWithLink(item: ChartData): void {
        // set active item back to default (null) if we toggle the already active item
        if (this._chartService.isInteractive && !this._chartService.stackedKeys) {
            if (this._chartService.activeItem === item ||
                (this._chartService.activeItem && this._chartService.activeItem.parent === item)) {

                this._chartService.activeItem = null;
            }
        }
    }

    /**
     * Set link for legend item if it available
     * @param item
     */
    showLink(item): boolean {
        return (item === this._chartService.activeItem) && (this._chartService.activeItem.link ? true : false);
    }

    /**
     * Send chart data when link is clicked
     * @param item
     */
    setItemLink(item): void {
        if (this._chartService.activeItem === item && item.link) {
            this._chartService.openLink = item;
        }
    }

    /**
     * Sets new chart data item as hover within chart
     * @param item
     */
    setHoverItem(item: ChartData): void {
        if (item) {
            this.tooltip = `<table style="text-align: left; font-size: 12px; height: 20px"><thead><tr> <td> ${item['label']} `
                + `(${this.value(item)})</td></td></tr></thead><tbody>`;
            _.forEach(item['misc'], ((data) => {
                this.tooltip = this.tooltip + `<tr><td style="text-align: left; width: 70%; font-size: 11px;"> &bull; `
                    + `${data['label']}</td><td style="text-align: right; width: 20%;">`
                    + `${this.value(data)}</td></tr>`;
            }));
            this.tooltip = this.tooltip + `</tbody></table>`;
        }
        if (this._chartService.activeItem !== item) {
            this._chartService.hoverItem = item;
        } else {
            this._chartService.hoverItem = null;
        }
    }

    /**
     * Returns a string if item.value is present. Tries to combine it with the unit
     * @param {ChartData} item
     * @returns {string?}
     */
    value(item: ChartData): string | null {
        // defaults to 0 if value is not set
        if (item && !item.value && !item.data) {
            item.value = 0;
        }
        if (!isNaN(item.value)) {
            if (item === this._chartService.activeItem && this._chartService.activeItem.link) {
                return null;
            }
            const value = AddonHelper.getFormattedValue(item, this._translateService);
            let unit = item.unit || '';
            if (unit && unit !== '%') {
                unit = ' ' + unit;
            }
            return value + unit;
        }
        return null;
    }

    /**
     * Set misc items if stackedExtraKeys is present.
     * @param {data}
     */
    renderLegendData(data): void {
        if (data) {
            if (!this._chartService.stackedKeys) {
                this.data = data;
                if (this._chartService.showAll) {
                    this.data = this.data.slice(0, PIECHARTCONFIG.MAX_SLICES);
                }
            } else {
                this.data = this._chartService.stackedKeys.map(key => new ChartData(
                    { label: key, value: this.summarise(data, key) }));
                const chartObj: ChartData = _.find(this.data, { 'label': data.miscLabel });
                if (chartObj) {
                    chartObj.misc = this._chartService.stackedExtraKeys ? (
                        this._chartService.stackedExtraKeys.map(key => new ChartData(
                            { label: key, value: this.summarise(data, key) }))) : null;
                }
            }
        }
    }

    /**
     * Toggle legend overflow to more or less
     */
    overflowToggle(): void {
        let maxPieSlices;

        if (this.label === 'More') {
            this.label = 'Less';
            maxPieSlices = PIECHARTCONFIG.ENHANCED_MAX_SLICES;
        } else {
            this.label = 'More';
            maxPieSlices = PIECHARTCONFIG.MAX_SLICES;
        }
        this.data = this._chartService.data;
        if (this.data.length > maxPieSlices) {
            this.data = this.data.slice(0, maxPieSlices);
        }
    }

    /**
     * Returns a boolean if showAll and data.length > PIECHARTCONFIG.MAX_SLICES
     * @returns {boolean}
     */
    isToggler(): boolean {
        return this._chartService.showAll && this._chartService.data.length > PIECHARTCONFIG.MAX_SLICES;
    }
}
