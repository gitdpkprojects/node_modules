import { Component, HostBinding, Input, ViewEncapsulation, OnInit } from '@angular/core';
import { ChartService } from '../../chart.service';
import { ChartData } from '../../../../core/models/chart.model';
import * as _ from 'lodash';
import { Addon } from '../../../../core/models/addon.model';
import { CHART_ADDON } from '../../../../core/constants/chart-addons.constants';
import { SumAddon } from '../../../../core/models/sum-addon.model';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../../../core/classes';

@Component({
    selector: 'cui-sum-addon',
    templateUrl: 'sum-addon.component.html',
    styleUrls: ['sum-addon.component.scss'],
    encapsulation: ViewEncapsulation.None
})
@UnSub()
export class SumAddonComponent implements OnInit {
    @HostBinding('class.cui-sum-addon') addClass: boolean = true;

    @Input() label: string;
    @Input() unit: string;
    @Input() format: string;
    sum: number;
    currentTitle: string = '';
    currentValue: number = 0;
    currentItem: ChartData;

    private _chartData: ChartData[] = [];
    private _subscriptions: Array<Subscription> = [];

    constructor(private _chartService: ChartService) {
        // Sets new data from parent component
        this._subscriptions.push(_chartService.data$.subscribe((data) => {
            this._chartData = data;
            this.renderStackedData(this._chartData);
            this.setValues();
        }));

        this._subscriptions.push(_chartService.addons$.subscribe((addons: Array<Addon>) => {
            addons.forEach((addon: Addon) => {
                if (addon.type === CHART_ADDON.SUMMARY) {
                    this.unit = (<SumAddon>addon).unit;
                    this.label = (<SumAddon>addon).label;
                    this.format = (<SumAddon>addon).format || undefined;
                    this.sum = (<SumAddon>addon).sum || undefined;
                }
            });
        }));

        // Sets/unsets current active item
        this._subscriptions.push(_chartService.activeItem$.subscribe((item: ChartData) => {
            this.currentItem = item;
            this.setValues();
        }));

    }

    ngOnInit(): void {
        this._chartData = this._chartService.data;
        this.currentItem = this._chartService.activeItem;
        this.renderStackedData(this._chartData);
        this.setValues();
    }
    /**
     * Sets values in summary depending on there's a active item or not.
     */
    setValues() {
        if (this.currentItem) {
            this.currentTitle = this.currentItem.label;
            if (this.sum) {
                this.currentValue = this.sum;
            } else if (!this.sum) {
                if (this.currentItem.data) {
                    this.currentValue = this._getSummarizedValue(this.currentItem.data, false);
                } else {
                    this.currentValue = this.currentItem.value ? this.currentItem.value : 0;
                }
            }
        } else if (!this.currentItem) {
            this.currentTitle = null;
            if (this.sum) {
                this.currentValue = this.sum;
            } else if (!this.sum) {
                this.currentValue = this._getSummarizedValue(this._chartData, false);
            }
        }
    }

    isNaN(number: number): boolean {
        return isNaN(number);
    }

    /**
     * Function to sum up all values in chart data array
     * Bugs in version 1 propmted for this updated version
     * since it is only being called from within sum-addon it has also been simplified
     * @param chartDataArray
     * @returns {number}
     * @private
     */
    private _getSummarizedValue(chartDataArray: ChartData[], isFlat: boolean = false): number {
        if (isFlat && this._chartService.stackedKeys) {
            return _.sumBy(this._chartService.stackedKeys, _.partial(_.sumBy, chartDataArray));
        }
        return _.sumBy(chartDataArray, (chartData: ChartData) => {
            if (chartData && chartData.data) {
                return this._getSummarizedValue(chartData.data, true);
            } else {
                return chartData && chartData.value ? chartData.value : 0;
            }
        });
    }

    /**
     * ToDo this method is not specific to sum, its common for all aggregation methods like sum, min, max and count
     * Gets the aggregated value of a specific property within an object (or array of objects..)
     * @param obj{any} - data
     * @param property{string} - the property of an object
     * @param aggregate{string} - aggregation method (sum, min, max, count) default to sum
     * @param shallow{any} - default to false (if true, only searches (n) levels deep ignoring deeply nested data)
     * @param depth{any} - default to 1, how far down the rabbit hole have we travelled?
     * @return {number}
     * @private
     */
    private _getAggregateValue(obj: any, property: string, aggregate: string, shallow: any = false, depth: number = 1): number | void {
        if ((typeof obj !== 'object') || !property) {
            return;
        }
        obj = _.cloneDeep(obj);
        const validAggregates = ['sum', 'min', 'max', 'count'];
        aggregate = (validAggregates.indexOf(aggregate.toLowerCase()) !== -1 ? aggregate.toLowerCase() : 'sum');

        // default to false (if true, only searches (n) levels deep ignoring deeply nested data)
        if (shallow === true) {
            shallow = 2;
        } else if (isNaN(shallow) || shallow < 2) {
            shallow = false;
        }

        // how far down the rabbit hole have we travelled?
        if (isNaN(depth)) {
            depth = 1;
        }

        let value = ((aggregate === 'min' || aggregate === 'max') ? null : 0);
        for (const prop in obj) {
            if (!obj.hasOwnProperty(prop)) {
                continue;
            }

            let propValue = obj[prop];
            const nested = Array.isArray(propValue);
            if (nested) {

                // the property is an object or an array
                if (prop === property && aggregate === 'count') {
                    value++;
                }

                if (shallow === false || depth < shallow) {
                    // recursively aggregate nested objects and arrays
                    propValue = this._getAggregateValue(propValue, property, aggregate, shallow, depth + 1);
                } else {
                    continue;
                }
            }

            // aggregate the properties value based on the selected aggregation method
            if ((prop === property || nested) && propValue) {
                switch (aggregate) {
                    case 'sum':
                        if (!isNaN(propValue)) {
                            value += propValue;
                        }
                        break;
                    case 'min':
                        if ((propValue < value) || !value) {
                            value = propValue;
                        }
                        break;
                    case 'max':
                        if ((propValue > value) || !value) {
                            value = propValue;
                        }
                        break;
                    case 'count':
                        if (propValue) {
                            if (nested) {
                                value += propValue;
                            } else {
                                value++;
                            }
                        }
                        break;
                }
            }
        }
        return value;
    }

    /**
     * Returns summarised value of items
     * @param items
     * @param attr
     * @returns {number}
     */
    summarise(items: any[], attr: string): any {
        return items.reduce((a, b) => a + b[attr], 0);
    }

    /**
     * Set misc items if stackedExtraKeys is present.
     * @param {stackedData}
     */
    renderStackedData(stackedData) {
        if (this._chartService.data) {
            if (this._chartService.stackedKeys) {

                this._chartData = this._chartService.stackedKeys.map(key => new ChartData(
                    { label: key, value: this.summarise(stackedData, key) }));

                const chartObj: ChartData = _.find(this._chartData, { 'label': this._chartService.miscLabel });
                if (chartObj) {
                    chartObj.misc = this._chartService.stackedExtraKeys ? (
                        this._chartService.stackedExtraKeys.map(key => new ChartData(
                            { label: key, value: this.summarise(stackedData, key) }))) : null;
                }
            } else {
                this._chartData = this._chartService.data;
            }
        }
    }

    /**
     * Send chart data when link is clicked
     * @param item
     */
    setItemLink(): void {
        this._chartService.openLink = this.currentItem;
    }
}
