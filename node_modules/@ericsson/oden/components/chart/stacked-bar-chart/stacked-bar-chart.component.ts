import { ChartService } from '../chart.service';
import {
    ViewEncapsulation,
    Input,
    Component,
    ComponentFactoryResolver,
    SimpleChanges,
    HostBinding,
    AfterViewInit,
    OnChanges,
    NgZone
} from '@angular/core';
import { ChartWithAddons } from '../chart-with-addons.class';
import { ChartData } from '../../../core/models/chart.model';
import { BAR_CHART_TYPE } from '../../../core/constants/bar-chart.constants';
import { BARCHARTCONFIG } from '../../../core/constants/bar-chart-config.constants';
import { UUID } from '../../../core/helpers/uuid.class';
import * as _ from 'lodash';
import * as D3 from 'd3';
import { ColorHelper } from '../../../core/helpers/color.helper';
import { ChartHelper } from '../../../core';
import { BarChartMargins } from '../../../constants';
import { ResizeService } from '../../../core/services/resize.service';
import { WhitelabelService } from '../../../core/services/whitelabel.service';

@Component({
    selector: 'cui-stacked-bar-chart',
    templateUrl: 'stacked-bar-chart.component.html',
    styleUrls: ['../chart-base.scss', 'stacked-bar-chart.component.scss'],
    providers: [ChartService],
    encapsulation: ViewEncapsulation.None
})

export class StackedBarChartComponent extends ChartWithAddons implements AfterViewInit, OnChanges {
    @Input() title?: string = '';
    @Input() set colorSet(colorSet: Array<string>) {
        if ( colorSet) {
            this._colorSet = colorSet;
        } else {
            this._setWhitelabelColor();
        }
    }
    get colorSet() {
        return this._colorSet;
    }
    @Input() dataSet: Array<ChartData> = [];
    @Input() type: BAR_CHART_TYPE = BAR_CHART_TYPE.HORIZONTAL;
    @Input() ticks: number = BARCHARTCONFIG.DEFAULT_TICKS;
    @Input() height: number;
    @Input() xTitle: string = '';
    @Input() yTitle: string = '';
    @Input() rotatedLabels: boolean = false;
    @Input() sorted: boolean = false;
    @Input() miscLabel: string = 'Others';
    @Input() stackedKeys: Array<string> = [];
    @Input() allowLabelRotation: boolean = false;
    @Input() allowLabelCrop: boolean = false;

    @HostBinding('class.cui-stacked-bar-chart') addClass: boolean = true;

    private _colorSet: Array<string>;
    private _renderData = [];
    private _opacity: number = .65;
    private _axisTitleOpacity: number = .45;
    private _width: number;
    private _height: number;
    private _clipID: string;
    private _didWarnAboutSetLength: boolean = false;
    private _didWarnAboutStackedKeys: boolean = false;

    private _svg: any;
    private x: any;
    private y: any;
    private z: any;
    private _stackedKeys: Array<string> = [];
    private _stackedExtraKeys: Array<string> = [];
    private _xLabelsRotated = this.rotatedLabels;

    constructor(private _chartService: ChartService,
                componentFactoryResolver: ComponentFactoryResolver,
                private _resizeService: ResizeService,
                private _zone: NgZone,
                private _whitelabelService: WhitelabelService) {
        super(componentFactoryResolver, _chartService);
        this._stackedKeyData();
        this._chartService.isInteractive = true;
        this._subscriptions.push(this._chartService.data$.subscribe((data) => {

            if (this.type === BAR_CHART_TYPE.VERTICAL) {
                this._renderData = this.dataSet;
            } else {
                this._renderData = this.dataSet.concat().reverse();
            }
            this._renderData = this.trimDataSet(data, this.stackedKeys, this.type);

            if (this._svg) {
                this._stackedKeyData();
                this._calculateColors();
                this._rotate();
                this._renderSvgData();
                const margin: BarChartMargins = this._getMargins();
                this._width = this.element.nativeElement.offsetWidth - margin.left - margin.right;
                this._height = this.element.nativeElement.offsetHeight - margin.top - margin.bottom;
                this._svg.style('min-height', this.element.nativeElement.offsetHeight);
                setTimeout(() => {
                    if ( this._xLabelsRotated) {
                        this._crop();
                    }
                    this._updateLayout();

                });
            }

            if (this._chartService.hoverItem) {
                D3.selectAll('#' + this._chartService.hoverItem.id)
                    .style('cursor', 'pointer')
                    .style('opacity', 1);
            }

        }));

        this._subscriptions.push(this._chartService.hoverItem$.subscribe((item: ChartData) => {
            if (item) {
                this._svg.selectAll('#' + item.id)
                    .style('cursor', 'pointer')
                    .style('fill-opacity', function(d) { return d[2]; });
            } else {
                this._highlightActive();
            }
        }));

        // Whenever an item becomes active or null
        this._subscriptions.push(this._chartService.activeItem$.subscribe(() => {

            if (this._svg) {
                this._highlightActive();
            }
        }));

        this._subscriptions.push(this._resizeService.resize$.subscribe(() => {
            this._zone.runOutsideAngular(() => {
                this._zone.run(() => {
                    this._resize();
                });
            });
        }));
        // On whitelabel change
        this._subscriptions.push(this._whitelabelService._whitelabelingLoaded.subscribe(() => {
            this.reload();
        }));



        this._clipID = UUID.create();
    }
    private _shouldRotateLabels() {
        if ( this._svg && this._svg.node() ) {
            const labelIsWider = ChartHelper.isLabelWiderThanContainer(this._svg.node(), this.dataSet.length);
            if ( this.rotatedLabels || labelIsWider) {
                return true;
            }
        }
        return false;
    }

    private _setWhitelabelColor() {
        if ( !this._colorSet ) {
            this._colorSet = this._whitelabelService.getBrandColors(false);
        }
    }

    /**
     * Set up all things needed
     */
    private _init() {
        this._setWhitelabelColor();
        this._stackedKeyData();
        setTimeout(() => {
            this._calculateColors();
            this._chartService.miscLabel = this.miscLabel;
            this._renderSvg();
            this.createTooltip(D3.select('body'), this._clipID);
            this.createAddons(this.addonsContainer, this.addons);
            if (this.type === BAR_CHART_TYPE.VERTICAL) {
                this._renderData = this.dataSet;
            } else { // The concat call is to reverse the raorder in the local copy, not the referenced array
                this._renderData = this.dataSet.concat().reverse();
            }
            this._renderData = this.trimDataSet(this._renderData, this.stackedKeys, this.type);
            this._renderSvgData();
            this._chartService.data = this._renderData;
            this.setSelectedItem(this._chartService.data);
            this._rotate();
            this._renderSvgData();
            if ( this._xLabelsRotated) {
                this._crop();
            }
        });
    }

    /**
     * Bootstrap component
     */
    ngAfterViewInit(): void {
        this._init();
    }

    /**
     * Function to handle property updates
     */
    ngOnChanges(changes: SimpleChanges): void {
        if (changes['dataSet'] ||
            changes['type'] ||
            changes['xTitle'] ||
            changes['yTitle'] ||
            changes['colorSet'] ||
            changes['addons'] ||
            changes['stackedKeys']
        ) {
            if (this._svg) {
                this.reload();
            }
        }
        if ( changes['rotatedLabels'] ) {
            this._xLabelsRotated = this.rotatedLabels;
        }

        super.ngOnChanges(changes);
    }

    /**
     * Re-render svg and data
     */
    public reload(): void {
        this._setWhitelabelColor();
        this._stackedKeyData();
        setTimeout(() => {
            this._svg.remove();
            this._svg = null;
            this._calculateColors();
            this._renderSvg();
            this._chartService.miscLabel = this.miscLabel;
            this.createAddons(this.addonsContainer, this.addons);
            if (this.type === BAR_CHART_TYPE.VERTICAL) {
                this._renderData = this.dataSet;
            } else {
                this._renderData = this.dataSet.concat().reverse();
            }
            this._renderData = this.trimDataSet(this.dataSet, this.stackedKeys, this.type);
            this._renderSvgData();
            if (this._chartService.activeItem) {
                this._chartService.activeItem = null;
            }
            this._chartService.data = this._renderData;
            this.setSelectedItem(this._chartService.data);

            if ( this.type === BAR_CHART_TYPE.HORIZONTAL) {
                this._calculateHeight();
            }
        });
    }

    /**
     * Runs when window is resized and recalculates chart containers and triggers update
    */
   private _resize() {
    if ( this._svg) {
            this._renderSvgData();
            this._rotate();
            const margin: BarChartMargins = this._getMargins();
            this._width = this.element.nativeElement.offsetWidth - margin.left - margin.right;
            this._height = this.element.nativeElement.offsetHeight - margin.top - margin.bottom;
            this._svg.style('min-height', this.element.nativeElement.offsetHeight);
            this._renderSvgData();
            const stableSubscription = this._zone.onStable.asObservable().subscribe(() => {
            this._crop();
            this._updateLayout();
            stableSubscription.unsubscribe();
        });
    }

}

    /**
     * Trim the dataSet length based on BAR_CHART_TYPE.HORIZONTAL/BAR_CHART_TYPE.VERTICAL
     * Trim the dataset object to minimum BARCHARTCONFIG.MAXSTACKEDBARS, and
     * merge the extra values into one object and label it ”others” (miscLabel)
     * @param dataSet
     * @param stackedKeys
     * @param type
     * @return Array<any>
     */
    trimDataSet(data: Array<ChartData>, stackedKeys: Array<string>, type: BAR_CHART_TYPE ): any {
        // reduce the dataset length
        if (type === BAR_CHART_TYPE.HORIZONTAL && data.length > BARCHARTCONFIG.MAX_HORIZONTAL_BARS) {
            if (!this._didWarnAboutSetLength) {
                console.warn('Bar chart warning: Maximum number of bars is limited to ' + BARCHARTCONFIG.MAX_HORIZONTAL_BARS + '.');
                this._didWarnAboutSetLength = true;
            }
            data = data.slice(0, BARCHARTCONFIG.MAX_HORIZONTAL_BARS);
        }
        if (type === BAR_CHART_TYPE.VERTICAL && data.length > BARCHARTCONFIG.MAXBARS) {
            if (!this._didWarnAboutSetLength) {
                console.warn('Bar chart warning: Maximum number of bars is limited to ' + BARCHARTCONFIG.MAXBARS + '.');
                this._didWarnAboutSetLength = true;
            }
            data = data.slice(0, BARCHARTCONFIG.MAXBARS);
        }
        // trim the dataset object and group the extra values into 'others'
        data.map((d: ChartData) => {
            if (stackedKeys && stackedKeys.length > BARCHARTCONFIG.MAXSTACKEDBARS) {
                const _stackedKeys = stackedKeys;
                const extraStackedKeys = _stackedKeys.filter(key => (key !== 'label' && key !== 'value'));
                extraStackedKeys.splice(0, BARCHARTCONFIG.MAXSTACKEDBARS);
                d[this.miscLabel] =  _.sumBy(extraStackedKeys, (key) => {
                    return d[key];
                });
            }
        });
        return data;
    }

    /**
     * Limited the stackedkey based on BARCHARTCONFIG.MAXSTACKEDBARS
     */
    private _stackedKeyData(): void {
        this._stackedKeys = this.stackedKeys;
        if (this._stackedKeys && this._stackedKeys.length > BARCHARTCONFIG.MAXSTACKEDBARS) {
            this._stackedKeys = this._stackedKeys.slice(0, BARCHARTCONFIG.MAXSTACKEDBARS);
            this._stackedKeys.push(this.miscLabel);
            if (!this._didWarnAboutStackedKeys) {
                this._didWarnAboutStackedKeys = true;
                console.warn('Maximum number of Stacked Bar is limited to ' + BARCHARTCONFIG.MAXSTACKEDBARS
                    + '. The Stacked Bar has been sliced down and stored in ' + this.miscLabel);
            }

            this._stackedExtraKeys = this.stackedKeys;
            this._stackedExtraKeys = this._stackedExtraKeys.slice(BARCHARTCONFIG.MAXSTACKEDBARS);
            this._chartService.stackedExtraKeys = this._stackedExtraKeys;
        }
        this._chartService.stackedKeys = this._stackedKeys;
    }

    /**
     * Calculate color-offsets based on dataSet-length
     * 0 is ~17% color and 100 is ~83% color
     */
    private _calculateColors() {
        const _colorSet = [];
        if (this._stackedKeys && this._stackedKeys.length !== this.colorSet.length) {
            let i = 0;
            let index = 0;
            this._stackedKeys.map(() => {
                if (index > 0 && index % 2 === 0) {
                    i++;
                }
                const [color] = ColorHelper.stackedGraphColorByIndex(i, index % 2 === 0, this.colorSet);
                _colorSet.push([color]);
                index++;
            });
            this._chartService.colorSet = _colorSet;
        } else {
            this._chartService.colorSet = this.colorSet;
        }
    }

    /**
     * Update layout with recalculates values
     */
    private _updateLayout(): void {
        const margin = this._getMargins();
        this._svg
                .style('width', this._getWidth() + margin.left + margin.right)
                .style('height', this._getHeight() + margin.top + margin.bottom);
        let xAxisOffset =  this._getWidth();
        if ( this._xLabelsRotated) {
            xAxisOffset =   this._getWidth() + 32;
        }
        this.x.rangeRound([0,  this._getWidth() ]);
        this.y.rangeRound([this._getHeight(), 0], .1);

        this._svg.selectAll('.x--title')
            .attr('transform', 'translate(' + xAxisOffset + ',17)');
        this._svg.selectAll('.bar-clip-rect')
            .attr('width',  this._getWidth());
        this._svg.selectAll('.axis--bars')
            .attr('width', this._getWidth());

        if (this.type === BAR_CHART_TYPE.VERTICAL) {
            this._svg.selectAll('.axis--bars')
                .selectAll('.bar')
                .selectAll('rect')
                .attr('clip-path', 'url(#barcut' + this._clipID + ')')
                .attr('x', d => this.x(d.data.label) + this._findXposition())
                .attr('y', d => this.y(d[1]))
                .attr('height', d => (this.y(d[0]) ? this.y(d[0]) : 0) - (this.y(d[1]) ? this.y(d[1]) : 0))
                .attr('width', () => this._verticalBarWidth());
        } else {
            this._svg.selectAll('.axis--x')
            .attr('transform', 'translate(0,' + this._getHeight() + ')');
            this._svg.selectAll('.axis--bars')
                .selectAll('.bar')
                .selectAll('rect')
                .attr('clip-path', 'url(#barcut' + this._clipID + ')')
                .attr('y', (d) => this.y(d.data.label))
                .attr('x', d => this.x(d[0]) ? this.x(d[0]) : 0)
                .attr('height', () => this._horizontalBarHeight() )
                .attr('transform', () => {
                    const barOffset = this._horizontalBarOffset();
                    return 'translate(0, ' + barOffset
                    + ')';
                })
                .attr('width', d => (this.x(d[1]) ? this.x(d[1]) : 0) - (this.x(d[0]) ? this.x(d[0]) : 0));
                this.y.rangeRound([this._getHeight(), 0]);
                this._svg.selectAll('.bar-clip')
                    .selectAll('.bar-clip-rect')
                        .attr('height', this._getHeight());
                this._svg.selectAll('.axis--y').call(D3.axisLeft(this.y).ticks(this.ticks));
        }

    }
    /*
    *   Make sure width is number >= 0
    */
    private _getWidth() {
        if ( isNaN(this._width)) {
            return 0;
        }
        return Math.max(0, this._width);
    }
    /*
    *   Make sure height is number >= 0
    */
    private _getHeight() {
        if ( isNaN(this._height)) {
            return 0;
        }
        return Math.max(0, this._height);
    }

    /**
     * Return an BARCHARTCONFIG.MARGINS object
     * With manipulated values
     * calculated depending on chart type
     *
     * @returns {any}
     */
    private _getMargins(): any {
        const margin: any = _.cloneDeep(BARCHARTCONFIG.MARGINS);
        margin.bottom = this._xLabelsRotated ? margin.bottom + 30 : margin.bottom;
        margin.right += this.xTitle.length;
        margin.left += (this.yTitle.length + 5 );
        margin.top += (this.type === BAR_CHART_TYPE.HORIZONTAL) ? 10 : 0;

        return margin;
    }

    private _calculateBarPadding(): number {
        let padding: number;
        let barBaseWidth: number;
        if (this.type === BAR_CHART_TYPE.VERTICAL) {
            padding = 16;
            barBaseWidth =  this._getWidth() / BARCHARTCONFIG.MAXBARS - padding;
        } else {
            padding = 8;
            barBaseWidth = this._height / BARCHARTCONFIG.MAX_HORIZONTAL_BARS - padding;
        }
        return padding / (barBaseWidth + padding);
    }

    /**
     * Render component SVG to DOM
     */
    private _renderSvg(): any {
        const margin: any = this._getMargins();

        this._width = this.element.nativeElement.offsetWidth - margin.left - margin.right;
        this._height = this.element.nativeElement.offsetHeight - margin.top - margin.bottom;

        this._svg = D3.select(this.element.nativeElement)
            .append('svg')
            .style('width', '100%')
            .style('height', '100%');

        const g = this._svg.append('g')
            .attr('class', 'axis--wrapper')
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

        // Y-axis
        g.append('g')
            .attr('class', 'axis axis--y')
            .style('font-size', '11px')
            .style('fill', 'none')
            .style('stroke', 'none')
            .style('opacity', this._opacity)

            // Y-axis title
            .append('text')
            .text(this.yTitle)
            .attr('text-anchor', 'end')
            .attr('transform', 'translate(-10,-15)')
            .style('fill', '#000')
            .style('font-size', '9px')
            .style('opacity', this._axisTitleOpacity);

        // X-axis
        g.append('g')
            .attr('class', 'axis axis--x')
            .attr('transform', 'translate(0,' + this._getHeight() + ')')
            .style('width',  Math.max(0, this._width - 200))
            .style('font-size', '11px')
            .style('fill', 'none')
            .style('stroke', 'none')
            .style('opacity', this._opacity)

            // X-axis title
            .append('text')
            .attr('class', 'x--title')
            .text(this.xTitle)
            .attr('transform', 'translate(' + this._getWidth() + ',17)')
            .style('fill', '#000')
            .style('font-size', '9px')
            .style('opacity', this._axisTitleOpacity);

        // Bar container
        g.append('g')
            .style('width',  Math.max(0, this._width - 200))
            .style('height', '100%')
            .attr('class', 'axis--bars');

        this._svg.append('clipPath')
            .attr('id', 'barcut' + this._clipID)
            .attr('class', 'bar-clip')
            .append('rect')
            .attr('class', 'bar-clip-rect')
            .attr('x', 0)
            .attr('width', this._getWidth())
            .attr('y', 0)
            .attr('height', `${this._height}`);

    }

    private _renderSvgData() {
        const margin: any = this._getMargins();
        this._svg
            .style('width',  this._getWidth() + margin.left + margin.right)
            .style('height', this._height + margin.top + margin.bottom);

        this._renderData = this._renderData.map(v => {
            v.value = this._stackedKeys.map(key =>
                (!v[key] ? (v[key] = 0) : v[key])).reduce((a, b) => a + b, 0 );
            return v;
        });

        if (this.sorted) {
            this._renderData.sort((a: any, b: any) => b.value - a.value);
        }

        const padding: number = this._calculateBarPadding(),
            maxValue: any = D3.max(this._renderData, (d: any) => d.value),
            xLength: number = (this.type === BAR_CHART_TYPE.HORIZONTAL && this.xTitle.length)
                ?  this._getWidth() - (this.xTitle.length + 28) :  this._getWidth();

        if (this.type === BAR_CHART_TYPE.VERTICAL) {
            this.x = D3.scaleBand().rangeRound([0, xLength]).padding(padding);
            this.x.domain(this._renderData.map((d) => d.label));
            this.y = D3.scaleLinear().rangeRound([this._getHeight(), 0]);
            this.y.domain([0, maxValue]).nice();
        } else {
            this.x = D3.scaleLinear().rangeRound([0, xLength]);
            this.x.domain([0, maxValue]).nice();
            this.y = D3.scaleBand().rangeRound([this._getHeight(), 0]).padding(padding);
            this.y.domain(this._renderData.map((d) => d.label));
        }

        this.z = D3.scaleOrdinal().range(this._chartService.colorSet);
        this.z.domain(this._stackedKeys);

        if (!this.ticks) {
            this.ticks = BARCHARTCONFIG.DEFAULT_TICKS;
        }
        if (this.type === BAR_CHART_TYPE.VERTICAL) {
            this._svg.selectAll('.axis--x').call(D3.axisBottom(this.x));
            this._svg.selectAll('.axis--y').call(D3.axisLeft(this.y).ticks(this.ticks));
            this._svg.selectAll('.axis--y').selectAll('.tick')
                .selectAll('line')
                .remove();
            this._svg.selectAll('.axis--y').selectAll('.tick')
                .append('line')
                .attr('class', 'axis-y-line')
                .attr('x1', 0)
                .attr('y1', 0)
                .attr('x2', this._getWidth())
                .attr('y2', 0)
                .style('stroke', '#E5E6E6');
        } else {
            this._svg.selectAll('.axis--x').call(D3.axisBottom(this.x).ticks(this.ticks));
            this._svg.selectAll('.axis--y').call(D3.axisLeft(this.y));
            this._svg.selectAll('.axis--x').selectAll('.tick')
                .selectAll('line')
                .remove();
            this._svg.selectAll('.axis--x').selectAll('.tick')
                .append('line')
                .attr('class', 'axis-x-line')
                .attr('x1', 0)
                .attr('y1', 0)
                .attr('x2', 0)
                .attr('y2', `-${this._getHeight()}`)
                .style('stroke', '#E5E6E6');
        }

        const bars = this._svg.selectAll('.axis--bars')
            .selectAll('.bar')
            .data(D3.stack().keys(this._stackedKeys)(this._renderData));

        if (this.type === BAR_CHART_TYPE.VERTICAL) {
            bars.exit()
                .transition()
                .duration(BARCHARTCONFIG.DURATION)
                .attr('y', d => this.y(d[0]))
                .attr('height', d => this.y(d[0]) - this.y(d[1]))
                .style('fill-opacity', 1e-6)
                .remove();
        } else {
            bars.exit()
                .transition()
                .duration(BARCHARTCONFIG.DURATION)
                .attr('x', d => this.x(d[0]))
                .attr('width', d => this.x(d[0]) - this.x(d[1]))
                .style('fill-opacity', 1e-6)
                .remove();
        }

        if (this.type === BAR_CHART_TYPE.VERTICAL) {
            bars.enter().append('g')
                .attr('fill', d => this.z(d.key))
                .attr('class', 'bar bar--value')
                .selectAll('rect')
                .attr('class', '')
                .data(d => d)
                .enter().append('rect')
                .style('fill-opacity', 0.8)
                .attr('id', (d) => { return d.data.id; })
                .attr('x', d => this.x(d.data.label) + this._findXposition())
                .attr('y', d => this.y(d[1]))
                .attr('height', d => (this.y(d[0]) ? this.y(d[0]) : 0) - (this.y(d[1]) ? this.y(d[1]) : 0))
                .attr('width', () =>  this._verticalBarWidth());

        } else {
            this._calculateHeight();
            bars.enter().append('g')
                .attr('fill', d => this.z(d.key))
                .attr('class', 'bar bar--value')
                .selectAll('rect')
                .attr('class', '')
                .data(d => d)
                .enter().append('rect')
                .style('fill-opacity', 0.8)
                .attr('id', (d) => { return d.data.id; })
                .attr('y', (d) => this.y(d.data.label))
                .attr('x', d => this.x(d[0]) ? this.x(d[0]) : 0)
                .attr('height', () =>  {
                    const height = this._horizontalBarHeight();
                    return height;
                })
                .attr('transform', () => {
                    const barOffset = this._horizontalBarOffset();
                    return 'translate(0, ' + barOffset
                    + ')'; })
                .attr('width', d => (this.x(d[1]) ? this.x(d[1]) : 0) - (this.x(d[0]) ? this.x(d[0]) : 0));
        }

        this._highlightActive();
        this._bindBarEvents();
        // reset the previous bar select
        this.hideTooltip();
        this._svg.selectAll('rect')
            .classed('inactive', false);
    }

    private _calculateHeight(): void {
        const minHeight = 280;
        const padding = 8;
        const margins = this._getMargins();
        const totalHeight: number = ( (this._horizontalBarHeight() + padding) *  this.ticks );
        if ( totalHeight > this._height && totalHeight > minHeight) {
            this.height = totalHeight;
            this._height = totalHeight - margins.top - margins.bottom;
            this._updateLayout();
        }
    }

    /**
     * Find x-position for x-axix label based on max-width
     */
    private _findXposition (): number {
        if (this.x.bandwidth() < BARCHARTCONFIG.MAX_VERTICAL_BARWIDTH) {
            return 0;
        } else {
            return (this.x.bandwidth() / 2 - BARCHARTCONFIG.MAX_VERTICAL_BARWIDTH / 2);
        }
    }

    private _horizontalBarOffset(): number {
        if (this.y.bandwidth() > BARCHARTCONFIG.MAX_HORIZONTAL_BARWIDTH ) {
            return this.y.bandwidth() / 2 - BARCHARTCONFIG.MAX_HORIZONTAL_BARWIDTH / 2;
        } else if ( this.y.bandwidth() < BARCHARTCONFIG.MIN_HORIZONTAL_BARWIDTH ) {
            return this.y.bandwidth() / 2 - BARCHARTCONFIG.MIN_HORIZONTAL_BARWIDTH / 2;
        } else {
            return 0;
        }
    }
    private _horizontalBarHeight(): number {
        if (this.y.bandwidth() > BARCHARTCONFIG.MAX_HORIZONTAL_BARWIDTH ) {
           return BARCHARTCONFIG.MAX_HORIZONTAL_BARWIDTH;
        } else if (this.y.bandwidth() < BARCHARTCONFIG.MIN_HORIZONTAL_BARWIDTH) {
            return BARCHARTCONFIG.MIN_HORIZONTAL_BARWIDTH;
        }
        return this.y.bandwidth();
    }

    private _verticalBarWidth(): number {
        if (this.x.bandwidth() > BARCHARTCONFIG.MAX_VERTICAL_BARWIDTH ) {
           return BARCHARTCONFIG.MAX_VERTICAL_BARWIDTH;
        } else if (this.x.bandwidth() < BARCHARTCONFIG.MIN_VERTICAL_BARWIDTH) {
            return BARCHARTCONFIG.MIN_VERTICAL_BARWIDTH;
        }
        return this.x.bandwidth();
    }

    /**
     * Bind mouse click and hover events to bars
     */
    private _bindBarEvents(): void {
        const bars = this._svg.selectAll('.axis--bars')
            .selectAll('.bar');

        bars.on('mousemove', () => {
            const elements = document.querySelectorAll(':hover');
            let l = elements.length;
            l = l - 1;
            const element: any = elements[l];
            const itemData = element.__data__;
            let items: string = '';
            items += '<tbody>';
            if (itemData.data) {
                items += this._stackedKeys.map((key, index) => {
                    const innerValue = itemData.data[key] ? itemData.data[key] : 0;
                    const color = this._chartService.colorSet[index];

                    return `
                                <tr>
                                    <td> <em style='background-color: ${color};'></em></td>
                                    <td style='text-align: left; min-width: 80px; padding-left: 6px' >${key}</td>
                                    <td style='text-align: right;'>${innerValue}</td>
                                </tr>
                            `;
                }).join('\n');

                // ToDo Misc items
                /*let _stackedExtraKeys = _stackedKeys.slice(BARCHARTCONFIG.MAXSTACKEDBARS);
                if (_stackedExtraKeys.length > 0) {
                    items += _stackedExtraKeys.map((key) => {
                        const innerValue = d.data[key];
                        return `
                                <tr>
                                <td> </td>
                                    <td style='text-align: left; min-width: 100px;'>&bull; ${key}</td>
                                    <td style='text-align: right;'>${innerValue}</td>
                                </tr>
                            `
                    }).join('\n');
                }*/
            }

            items += '</tbody>';
            const dataTip: string = `
                        <table>
                            <thead  style='text-align: left'>
                            <tr style='height: 20px;'>
                            <td colspan='2'><h4>${itemData.data.label}</h4></td>
                            </tr>
                            <tr style='font-size: 14px; height: 20px'>
                            <td colspan='2'>${itemData.data.value}</td>
                            </tr><thead>
                            ${ items }
                        </table>`;

            this.showTooltip(dataTip, D3.event.pageX + 10, D3.event.pageY - 30, { id: this._clipID });
        })
            .on('mouseover', () => {
                const elements = document.querySelectorAll(':hover');
                let l = elements.length;
                l = l - 1;
                const element: any = elements[l];
                const itemData = element.__data__;

                this._chartService.hoverItem = this.dataSet.find((item) => {
                    return item.id === itemData.data.id;
                });
            })
            .on('mouseout', () => {
                this._chartService.hoverItem = null;
                this.hideTooltip();
            })
            .on('click', () => {
                const elements = document.querySelectorAll(':hover');
                let l = elements.length;
                l = l - 1;
                const element: any = elements[l];
                const itemData = element.__data__;
                // if we click the active item, toggle it and set activeItem = null
                // this will trigger the activeItem$.subscribe in the constructor()
                if (itemData.data === this._chartService.activeItem) {
                    this._chartService.activeItem = null;
                    this._chartService.data = this._renderData;
                } else {
                    this._chartService.activeItem = this._renderData.find((item) => {
                        return item.id === itemData.data.id;
                    });
                }
            });
    }
    private _crop() {
        const margin: BarChartMargins = this._getMargins();
        if (this.type === BAR_CHART_TYPE.VERTICAL) {
            this._svg = ChartHelper.cropBarChartLabel(this._svg.node(), this._xLabelsRotated, this.dataSet.length, margin.bottom);
            this._svg.style('min-height', this.element.nativeElement.offsetHeight);
            this._svg.selectAll('.axis--x')
                .attr('transform', 'translate(0,' + this._getHeight() + ')');
        }

    }
    private _rotate() {
        const shouldRotateLabels = this._shouldRotateLabels();
        if (this.type === BAR_CHART_TYPE.VERTICAL && shouldRotateLabels ) {
            this._rotateXAxis(true);
            this._xLabelsRotated = true;
        } else if ( !shouldRotateLabels ) {
            if ( this._xLabelsRotated) {
                this._xLabelsRotated = false;
                this._rotateXAxis(false);
            }
        }
        this._updateLayout();
    }
    private _rotateXAxis(rotate: boolean) {
        let rotationString = '';
        let xOffset = 0;
        if (rotate) {
             rotationString = 'rotate(-45)';
             xOffset = -32;
        }

        this._svg.selectAll('.axis--x')
            .selectAll('text')
            .attr('y', 0)
            .attr('x', xOffset)
            .attr('transform', rotationString);
    }


    /**
     * Higlight active bar
     * Or reset colors to all bars if no item is selected
     */
    private _highlightActive(): void {
        // Highlight new active Item

        if (this._chartService.activeItem) {
            this._svg.selectAll('rect')
                .classed('inactive', true);

            this._svg.selectAll('rect')
                .style('fill-opacity', 0.8);

            this._svg.selectAll('#' + this._chartService.activeItem.id)
                .classed('inactive', false);

            this._svg.selectAll('#' + this._chartService.activeItem.id)
                .style('fill-opacity', 1);

        } else {
            this._svg.selectAll('rect')
                .classed('inactive', false);

            this._svg.selectAll('rect')
                .style('fill-opacity', 0.8);

        }
    }
}
