import {
    Component,
    ComponentFactoryResolver,
    HostBinding,
    Input,
    OnChanges,
    OnInit,
    ViewEncapsulation,
    AfterViewInit
} from '@angular/core';
import * as D3 from 'd3';
import { clamp } from 'lodash';
import { ChartWithAddons } from '../chart-with-addons.class';
import { ChartService } from '../chart.service';
import { ChartData } from '../../../core/models/chart.model';
import { ColorHelper } from '../../../core/helpers/color.helper';
import { ChartHelper } from '../../../core/helpers/chart.helper';
import { RAINBOWCHART_CONFIG } from '../../../core/constants/rainbow-chart-config.constants';
import { WhitelabelService } from '../../../core/services/whitelabel.service';
import { COLORWHITELABEL } from '../../../core/constants/color.whitelabel';

@Component({
    selector: 'cui-rainbow-chart',
    templateUrl: 'rainbow-chart.component.html',
    styleUrls: ['../chart-base.scss', 'rainbow-chart.component.scss'],
    providers: [ChartService],
    encapsulation: ViewEncapsulation.None
})

export class RainbowChartComponent extends ChartWithAddons implements OnChanges, OnInit, AfterViewInit {
    @HostBinding('class.cui-rainbow-chart') addClass: boolean = true;

    @Input() title: string = '';
    @Input() dataSet: Array<ChartData> = [];
    @Input() diameter: number = 230;
    @Input() min: number = 0;
    @Input() max: number = 100;
    @Input() percent: boolean = false;
    @Input() set colorSet(colorSet: Array<string>) {
        if ( colorSet) {
            this._colorSet = colorSet;
        } else {
            this._setWhitelabelColor();
        }
    }
    get colorSet() {
        return this._colorSet;
    }

    private _colorSet: Array<string>;
    private _arcs: Array<any> = [];
    private _didWarnAboutDatasetLength: boolean = false;

    constructor(
        private _chartService: ChartService,
        componentFactoryResolver: ComponentFactoryResolver,
        private _whitelabelService: WhitelabelService
    ) {
        super(componentFactoryResolver, _chartService);
        this._chartService.isInteractive = true;
        this._chartService.addMiddleware((data: Array<ChartData>) => {
            if (!this._didWarnAboutDatasetLength && data.length > RAINBOWCHART_CONFIG.MAX_ITEMS) {
                this._didWarnAboutDatasetLength = true;
                console.warn(`Maximum number of gauges are limited to ${RAINBOWCHART_CONFIG.MAX_ITEMS}. The chart has been sliced down.`);
            }
            data = data.slice(0, RAINBOWCHART_CONFIG.MAX_ITEMS);

            // set '%' as a default unit if the data seems to be percent based
            data.forEach((chartData: ChartData) => {
                chartData.unit = this.percent ? '%' : chartData.unit;
            });
            return data;
        });

    }

    ngOnInit() {
        this._setWhitelabelColor();
        this._subscriptions.push(this._chartService.data$.subscribe((data) => {
            this.dataSet = data;
            if (this._arcs.length !== data.length) {
                this.initChart();
            } else {
                data.forEach((item, index) => this.setValue(index, item.value));
            }
        }));

        this._subscriptions.push(this._chartService.activeItem$.subscribe(this._setOpacity.bind(this)));
        this._subscriptions.push(this._chartService.hoverItem$.subscribe(this._setColors.bind(this)));
        // On whitelabel change
        this._subscriptions.push(this._whitelabelService._whitelabelingLoaded.subscribe(() => {
            this.reload();
        }));
        this.chartService.data = this.dataSet;
    }

    ngAfterViewInit() {
        super.ngAfterViewInit();
    }

    /**
     * When component created dynamically, it is not detecting ngOnChanges
     * so force call this reload function to set the data
     */
    reload(): void {
        this._setWhitelabelColor();
        this.chartService.data = this.dataSet;
        this.createAddons(this.addonsContainer, this.addons);
    }

    get range() {
        return Math.abs(this.min - this.max);
    }

    private _click(index): void {
        this._chartService.activeItem = this.dataSet[index];
    }

    private _mouseOver(index): void {
        this._chartService.hoverItem = this.dataSet[index];
    }

    private _mouseOut(): void {
        this._chartService.hoverItem = null;
        this.hideTooltip();
    }

    private _mouseMove(): void {
        const item = this._chartService.hoverItem;
        const value = Number(item.value) + (item.unit ? (item.unit === '%' ? '%' : ' ' + item.unit) : '');
        const label = `${item.label}<br />${value}`;
        this.showTooltip(label, D3.event.pageX + 10, D3.event.pageY - 25);
    }

    private _setWhitelabelColor() {
        if ( !this._colorSet ) {
            this._colorSet = this._whitelabelService.getBrandColors(false);
        }
    }

    private _setOpacity(item?: ChartData): void {
        this._arcs.forEach(arc => {
            const opacity = (item !== null && item !== arc.item) ? 0.2 : 1;
            arc.valueElement.transition('fade_opacity').duration(RAINBOWCHART_CONFIG.FADE_DURATION).style('opacity', opacity);
            if (!item) {
                arc.valueElement.transition('fade_opacity').duration(RAINBOWCHART_CONFIG.FADE_DURATION).style('opacity', 1);
            }
        });
    }

    private _setColors(): void {
        this._arcs.forEach((arc, index) => {
            const [tinted, base] = ColorHelper.graphColorByIndex(index, this.colorSet);
            const color = (this._chartService.hoverItem === arc.item || this._chartService.activeItem === arc.item)
                ? base : tinted;
            arc.valueElement.transition('fade_color').duration(RAINBOWCHART_CONFIG.FADE_DURATION).style('fill', color);
        });
    }

    private _getArcValue(value: number): number {
        const percent = clamp(value, this.min, this.max) / this.range;
        return RAINBOWCHART_CONFIG.START_ANGLE + ChartHelper.percentageToRadius(percent / 1.3333333);
    }

    public initChart(): void {
        this.createTooltip(D3.select('body'));
        const pi = Math.PI;
        const {outerRadius} = ChartHelper.createGaugeMeasurements(this.diameter);

        const svg = D3.select(this.element.nativeElement)
            .append('svg')
            .attr('width', '100%')
            .attr('height', '100%')
            .attr('viewBox', `0 0 ${this.diameter} ${this.diameter}`)
            .attr('preserveAspectRatio' , 'xMinYMin')
            .append('g')
            .attr('transform', () => 'translate(' + outerRadius + ',' + outerRadius + ')');

        if (this.dataSet.length < 2) {
            return;
        }
        const colors = [];
        this.dataSet.forEach((item, index) => {
            const [color] = ColorHelper.graphColorByIndex(index, this.colorSet);
            colors.push(color);

            const measurements = ChartHelper
                .createGaugeMeasurements(this.diameter - (index * 30));
            const arc = D3.arc()
                .outerRadius(measurements.outerRadius)
                .innerRadius(measurements.innerRadius)
                .startAngle(RAINBOWCHART_CONFIG.START_ANGLE)
                .cornerRadius(20);

            // Background arc
            svg
                .append('path')
                .datum({endAngle: 135 * (pi / 180)})
                .style('fill', this._whitelabelService.getPropertyValue(COLORWHITELABEL.BASE_COLOR_INVERTED))
                .style('opacity', '0.05')
                .attr('d', arc)
                .attr('class', 'path-arc')
                .on('click', () => this._click(index))
                .on('mousemove', () => this._mouseMove())
                .on('mouseover', () => this._mouseOver(index))
                .on('mouseout', () => this._mouseOut());

            // Actual value
            const valueElement = svg
                .append('path')
                .datum({endAngle: -90 * (pi / 180)})
                .style('fill', color)
                .style('pointer-events', 'none')
                .attr('class', 'value-arc')
                .attr('d', arc)
                .attr('data-value', item.value);

            this._arcs.push({ arc, valueElement, value: item.value, item });
            this.setValue(index, item.value);
        });
        this._chartService.colorSet = colors;
    }

    /**
     * Changes the value of a single gauge
     * @param {number} index Which gauge to change
     * @param {number} value
     */
    setValue(index: number, value: number): void {
        const element = this._arcs[index].valueElement;
        const arcValue = this._getArcValue(value);
        element.attr('data-value', value);
        element.transition('change_value').duration(RAINBOWCHART_CONFIG.TWEEN_DURATION).call((transition) => (
            this.arcTween(transition, arcValue, this._arcs[index].arc)
        ));
    }

    arcTween(transition, newAngle, arc): void {
        transition.attrTween('d', (d) => {
            const interpolate = D3.interpolate(d.endAngle, newAngle);
            return (t) => {
                d.endAngle = interpolate(t);
                return arc(d);
            };
        });
    }
}
