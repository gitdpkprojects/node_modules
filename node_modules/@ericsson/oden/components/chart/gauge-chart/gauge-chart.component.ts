import {
    AfterViewInit,
    Component,
    ComponentFactoryResolver,
    HostBinding,
    Input,
    OnChanges,
    ViewEncapsulation,
    OnInit
} from '@angular/core';

import * as D3 from 'd3';
import { Arc } from 'd3-shape';
import { ChartWithAddons } from '../chart-with-addons.class';
import { ChartService } from '../chart.service';
import { clamp } from 'lodash';
import { ChartHelper } from '../../../core/helpers/chart.helper';
import { WhitelabelService } from '../../../core/services/whitelabel.service';
import { COLORWHITELABEL } from '../../../core/constants/color.whitelabel';

const START_ANGLE: number = -135 * (Math.PI / 180);

@Component({
    selector: 'cui-gauge-chart',
    templateUrl: 'gauge-chart.component.html',
    styleUrls: ['../chart-base.scss', 'gauge-chart.component.scss'],
    providers: [ChartService],
    encapsulation: ViewEncapsulation.None
})

export class GaugeChartComponent extends ChartWithAddons implements AfterViewInit, OnChanges, OnInit {
    @HostBinding('class.cui-gauge-chart') addClass: boolean = true;

    @Input() title: string = '';
    @Input() set color(color: string) {
        if (color) {
            this._color = color;
        } else {
            this._setWhitelabelColor();
        }
    }
    get color() {
        return this._color;
    }
    @Input() min: number = 0;
    @Input() max: number = 150;
    @Input() currentValue: number = 100;
    @Input() unit: string = '';
    @Input() subtitle: string = '';
    @Input() maximumValuePrintOut: string;
    private _color: string;
    private _arc: Arc<any, any>;
    private _subtitleDisplayElement: any;
    private _valueDisplayElement: any;
    private _maxValueDisplayElement: any;
    private _unitDisplayElement: any;
    private _valueArcElement: any;

    constructor(_chartService: ChartService,
                componentFactoryResolver: ComponentFactoryResolver,
                private _whitelabelService: WhitelabelService) {
        super(componentFactoryResolver, _chartService);
    }

    ngOnInit() {
        this._setWhitelabelColor();
        // On whitelabel change
        this._subscriptions.push(this._whitelabelService._whitelabelingLoaded.subscribe(() => {
            this.reload();
        }));
    }

    ngAfterViewInit(): void {
        this.load();
        super.ngAfterViewInit();
    }

    ngOnChanges(changes): void {
        if (this._valueArcElement) {
            this.reload();
        }
        super.ngOnChanges(changes);
    }

    /**
     * Instantiates gauge chart
     */
    public load(): void {
        const diameter = 144;
        const { outerRadius, innerRadius } = ChartHelper.createGaugeMeasurements(diameter);

        this._arc = D3.arc()
            .outerRadius(outerRadius)
            .innerRadius(innerRadius)
            .startAngle(START_ANGLE)
            .cornerRadius(20); // Arc Defaults

        // SVG Dom element
        const svg = D3.select(this.element.nativeElement)
            .append('svg')
            .attr('width', '100%')
            .attr('height', '100%')
            .attr('viewBox', `0 0 ${diameter} ${diameter}`)
            .attr('preserveAspectRatio', 'xMinYMin')
            .append('g')
            .attr('transform', () => {
                return 'translate(' + outerRadius + ',' + outerRadius + ')';
            });

        // Background
        svg.append('path')
            .attr('class', 'arc')
            .datum({ endAngle: 135 * (Math.PI / 180) })
            .style('fill', this._whitelabelService.getPropertyValue(COLORWHITELABEL.BASE_COLOR_INVERTED))
            .style('opacity', '0.05')
            .attr('d', this._arc);

        // .this._arc to svg
        this._valueArcElement = svg
            .append('path')
            .attr('class', 'value-arc')
            .datum({ endAngle: -90 * (Math.PI / 180) })
            .style('fill', this.color)
            .attr('d', this._arc); // Append foreground this

        // Display subtitle
        this._subtitleDisplayElement = svg.append('text')
            .attr('transform', 'translate(0,20)')
            .attr('text-anchor', 'middle')
            .attr('class', 'current-value gauge-subtitle')
            .text(this.subtitle);

        this._valueDisplayElement = svg
            .append('text')
            .attr('text-anchor', 'middle')
            .attr('class', 'current-value gauge-value')
            .text(this.currentValue);

        this._unitDisplayElement = svg
            .append('text')
            .attr('class', 'gauge-unit')
            .text(this.unit);

        this._maxValueDisplayElement = svg
            .append('text')
            .attr('transform', 'translate(0,65)')
            .attr('text-anchor', 'middle')
            .attr('class', 'gauge-max-value')
            .text(this.maximumValuePrintOut ? this.maximumValuePrintOut : '');

        this.setValue(this.currentValue);
    }

    setTextTranslate(): void {
        const textTranslate = this.currentValue.toString().length * 4;
        this._valueDisplayElement
            .attr('transform', 'translate(-' + textTranslate + ',0)')
            .style('font-size', '24px');

        const unitTranslate = this.currentValue.toString().length * 5 + 1;
        this._unitDisplayElement
            .attr('transform', 'translate(' + unitTranslate + ',0)')
            .style('font-size', '13px')
            .style('font-weight', 'normal');
    }

    setValue(value: number): void {
        // Text transition for Value display
        this._valueDisplayElement.transition().text(value);
        this._subtitleDisplayElement.transition().text(this.subtitle);
        this._unitDisplayElement.transition().text(this.unit);

        if (this.maximumValuePrintOut) {
            this._maxValueDisplayElement.transition().text(this.maximumValuePrintOut);
        }

        this.setTextTranslate();

        const arcValue = this.getArcValue(value);
        this._valueArcElement.transition().duration(200).style('fill', this.color)
            .attr('data-value', value)
            .call((transition) => (
                this.arcTween(transition, arcValue, this._arc)
            ));
    }

    reload(): void {
        this._setWhitelabelColor();
        this.setValue(this.currentValue);
        this.createAddons(this.addonsContainer, this.addons);
    }

    getArcValue(_value: number): number {
        const value = clamp(_value, this.min, this.max);
        const percent = Math.max(value / this.max, 0.035);
        return START_ANGLE + ChartHelper.percentageToRadius(percent / 1.3333333);
    }

    arcTween(transition, newAngle, arc): void {
        transition.attrTween('d', (d) => {
            const interpolate = D3.interpolate(d.endAngle, newAngle);
            return (t) => {
                d.endAngle = interpolate(t);
                return arc(d);
            };
        });
    }

    private _setWhitelabelColor() {
        if (!this._color) {
            this._color = this._whitelabelService.getPropertyValue(COLORWHITELABEL.BRAND_PRIMARY);
        }
    }
}
