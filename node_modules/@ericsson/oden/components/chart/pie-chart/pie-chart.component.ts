import {
    Component,
    Input,
    Output,
    EventEmitter,
    HostBinding,
    ViewEncapsulation,
    ComponentFactoryResolver,
    OnChanges,
    SimpleChanges,
    OnInit,
    AfterViewInit
} from '@angular/core';
import * as D3 from 'd3';
import { PIECHARTCONFIG } from '../../../core/constants/pie-chart-config';
import { ChartData } from '../../../core/models/chart.model';
import { ColorHelper } from '../../../core/helpers/color.helper';
import { ChartWithAddons } from '../chart-with-addons.class';
import { ChartService } from '../chart.service';
import { AddonHelper } from '../addon/addon.helper';
import { TranslateService } from '@ngx-translate/core';
import { WhitelabelService } from '../../../core/services/whitelabel.service';
import { COLORWHITELABEL } from '../../../core/constants/color.whitelabel';

@Component({
    selector: 'cui-pie-chart',
    templateUrl: 'pie-chart.component.html',
    styleUrls: ['../chart-base.scss', 'pie-chart.component.scss'],
    providers: [ChartService],
    encapsulation: ViewEncapsulation.None
})

export class PieChartComponent extends ChartWithAddons implements OnInit, AfterViewInit, OnChanges {
    @Input() title?: string = '';
    @Input() dataSet: Array<ChartData> = [];
    @Input() set color(color: string) {
        if (color) {
            this._color = color;
        } else {
            this._setWhitelabelColor();
        }
    }
    get color() {
        return this._color;
    }
    @Input() colorSet?: Array<string>;
    @Input() percent: boolean = true;
    @Input() sorted: boolean = true;
    @Input() showAll: boolean = false;
    @Input() miscLabel: string = 'Other';
    // onSectorClick is deprecated since >0.5
    @Output() onSectorClick: EventEmitter<ChartData> = new EventEmitter<ChartData>();

    @HostBinding('class.cui-pie-chart') addClass: boolean = true;

    private _color: string;
    private _pie: any;
    private _host: any;
    private _svg: any;
    private _radius: number;
    private _diameter: number;
    private _colors: any;
    private _arcNormal: any;
    private _arcClick: any;
    private _arcHover: any;
    private _total: number;
    private _hoverSlice: any;
    private _didWarnAboutDatasetLength: boolean = false;
    chartSize: number = 12;

    constructor(chartService: ChartService,
                componentFactoryResolver: ComponentFactoryResolver,
                private _translateService: TranslateService,
                private _whitelabelService: WhitelabelService) {
        super(componentFactoryResolver, chartService);

        chartService.addMiddleware((data: Array<ChartData>) => {
            return this.trimDataSet(data);
        });

        this._subscriptions.push(chartService.data$.subscribe((data) => {
            if (this._svg) {
                this.calculateColors();
                chartService.colorSet = this._getColorSet();
                this.populatePieChart(data);
                this._svg.select('.slices').selectAll('path.slice').style('opacity', 1);
            }
        }));

        // Whenever an item becomes active or null
        this._subscriptions.push(chartService.hoverItem$.subscribe((item: ChartData) => {
            // hide the hover effect
            this._svg.select('.hovers').selectAll('path.hoverslices')
                .style('opacity', 0);

            if (item) {
                const hoverBorder = D3.selectAll('#border-' + item.id);
                hoverBorder.style('fill', this._whitelabelService.getPropertyValue(COLORWHITELABEL.BASE_COLOR_INVERTED,
                    {opacity: COLORWHITELABEL.OPAQUE_5}))
                .style('opacity', 1);
            }
        }));

        // Whenever an item becomes active or null
        this._subscriptions.push(chartService.activeItem$.subscribe((item: ChartData) => {
            // return all slices to normal state
            if (this._svg) {
                if (!chartService.lastActiveItem || (chartService.lastActiveItem && chartService.lastActiveItem !== item)) {
                    this._svg.select('.slices').selectAll('path.slice')
                        .transition().duration(PIECHARTCONFIG.TRANSISIONDURATION)
                        .attr('d', this._arcNormal);
                }

                this._svg.select('.hovers').selectAll('path.hoverslices')
                    .style('opacity', 0);

                if (item && (!chartService.lastActiveItem || item !== chartService.lastActiveItem)) {
                    // set the selected state
                    D3.select('#' + item.id).transition()
                        .duration(PIECHARTCONFIG.TRANSISIONDURATION)
                        .attr('d', this._arcClick);
                }
            }
        }));
        // On whitelabel change
        this._subscriptions.push(this._whitelabelService._whitelabelingLoaded.subscribe(() => {
            this.reload();
        }));

    }

    ngOnInit(): void {
        this._setWhitelabelColor();
        this.load();
        this.chartSize = this.hasAddons ? 7 : 12;
        this.chartService.data = this.dataSet;
        this.chartService.showAll = this.showAll;
        if (this.dataSet) {
            // data call only for empty charts
            if (this.dataSet.length === 0) {
                this.chartService.data = this.dataSet;
            }
        }
    }

    ngAfterViewInit() {
        this.chartService.showAll = this.showAll;
        super.ngAfterViewInit();
    }

    // Make sure the chartservice get the new data when the pie chart changes
    ngOnChanges(changes: SimpleChanges): void {
        super.ngOnChanges(changes);
        this.chartSize = this.hasAddons ? 7 : 12;
        if (changes['color'] && changes['color'].previousValue !== changes['color'].currentValue) {
            this.chartService.color = this.color;
        }
        if (changes['colorSet'] && changes['colorSet'].previousValue !== changes['colorSet'].currentValue) {
            this.chartService.colorSet = this._getColorSet();
        }
        if ( changes['colorSet'] && !changes['colorSet'].currentValue) {
            this._color = this._whitelabelService.getPropertyValue(COLORWHITELABEL.BRAND_PRIMARY);
        }
    }

    /**
     * Trim DataSet to max slices limit of 18
     * @param data
     */
    trimDataSet(data) {
        if (this.sorted) {
            data = this.chartService.reverseSort(data);
        }
        let maxPieSlices = PIECHARTCONFIG.MAX_SLICES;
        if (this.showAll) {
            maxPieSlices = PIECHARTCONFIG.ENHANCED_MAX_SLICES;
        }

        if (data.length > maxPieSlices) {
            if (!this._didWarnAboutDatasetLength && data.length > maxPieSlices) {
                this._didWarnAboutDatasetLength = true;
                console.warn(
                    `Maximum number of slices are limited to ${maxPieSlices}.
The chart has been sliced down and extra slices are grouped into "misc".`
                );
            }
            const firstPart = data.slice(0, maxPieSlices - 1);
            const otherItem: ChartData = new ChartData({
                label: this.miscLabel,
                value: AddonHelper.getSummarizedValue(data.slice(maxPieSlices - 1, data.length)),
                misc: data.slice(maxPieSlices - 1, data.length)
            });
            firstPart.push(otherItem);
            data = firstPart;
        }
        return data;
    }

    /**
     * Calculate colors
     */
    private calculateColors() {
        if (this.dataSet && this.dataSet.length > 0) {
            if (this.colorSet && this.colorSet.length > 0) {
                let colors = [];
                if (this.colorSet.length !== this.dataSet.length) {
                    colors = ColorHelper.donutChartColors(this.dataSet, this.colorSet);
                }
                this._colors = (index) => {
                    return colors[index];
                };
            } else {
                this._colors = D3.scaleLinear<string>()
                    .domain([0, this.dataSet.length])
                    .range([this.color, 'white'])
                    .interpolate(D3.interpolateRgb);
            }
        }
    }

    private _setWhitelabelColor() {
        if (!this._color) {
            this._color = this._whitelabelService.getPropertyValue(COLORWHITELABEL.BRAND_PRIMARY);
        }
    }

    /**
     * Get an indexed array of calculated colors for all slices in chart
     * @returns [string]
     */
    private _getColorSet(): Array<string> {
        if (this._colors && this.dataSet && this.dataSet.length > 0) {
            const colors = this.dataSet.map((d) => {
                return this._colors(this._getItemFillColorIndex(d));
            });
            return colors;
        } else {
            return [];
        }
    }

    /**
     * Get Fill-color for current item
     * @param d
     * @returns {number}
     */
    private _getItemFillColorIndex(d): number {
        return this.dataSet.findIndex(item => item.id === d.id);
    }

    createValueString(data: ChartData) {
        let unit = data.unit || '';
        unit = this.percent ? '%' : unit;

        let value;
        if (this.percent) {
            value = Math.round((data.value / this._total) * 100);
        } else {
            value = AddonHelper.getFormattedValue(data, this._translateService);
        }
        if (unit && unit !== '%') {
            unit = ' ' + unit;
        }
        return value + unit;
    }

    /**
     * Force reload when data changed, called from CUS
     */
    public reload(): void {
        this._setWhitelabelColor();
        this.createAddons(this.addonsContainer, this.addons);
        this.chartSize = this.hasAddons ? 7 : 12;
        this.chartService.data = this.dataSet;
        this.chartService.showAll = this.showAll;
        this.setSelectedItem(this.chartService.data);
    }

    load(): void {
        this._host = D3.select(this.element.nativeElement);
        this.setup();
        this.chartService.isInteractive = true;
    }

    /**
     * Set width, height and margin of piechart
     */
    setup(): void {
        const element = this.element.nativeElement;
        if (element.offsetWidth > element.offsetHeight) {
            this._diameter = element.offsetWidth;
        } else {
            this._diameter = element.offsetHeight;
        }

        this._radius = (this._diameter / 2) - (((this._diameter / 2) * PIECHARTCONFIG.RADIUSOVER) / 100);
        this._arcNormal = D3.arc()
            .outerRadius(this._radius)
            .innerRadius((this._radius * PIECHARTCONFIG.INNERRADIUS) / 100);

        this._arcClick = D3.arc()
            .outerRadius(this._radius + ((this._radius * PIECHARTCONFIG.RADIUSOVER) / 100))
            .innerRadius((this._radius * PIECHARTCONFIG.INNERRADIUS) / 100);

        this._arcHover = D3.arc()
            .outerRadius(this._radius + ((this._radius * PIECHARTCONFIG.RADIUSOVER) / 100))
            .innerRadius(this._radius + ((this._radius * PIECHARTCONFIG.RADIUSOVER) / 100) / 3)
            .padAngle(PIECHARTCONFIG.PADANGLE);

        // declare value and sort
        this._pie = D3.pie()
            .value(d => d['value']) // Binding each value to the pie
            .sort(null);

        this._svg = this._host.append('svg')
            .attr('width', '100%')
            .attr('height', '100%')
            .attr('viewBox', '0 0 ' + this._diameter + ' ' + this._diameter)
            .attr('preserveAspectRatio', 'xMinYMin')
            .append('g')
            .attr('transform', () => {
                return 'translate(' + this._diameter / 2 + ',' + this._diameter / 2 + ')';
            });

        this._svg.append('g')
            .attr('class', 'slices');

        this._svg.append('g')
            .attr('class', 'hovers');

        this.createTooltip(D3.select('body'));
    }

    /**
     * To Merges the two arrays into a single array.
     * @param Array<any>, Array<any>
     * @returns Array
     */
    mergeWithFirstEqualZero(first: Array<any>, second: Array<any>): Array<any> {
        const secondSet = D3.set();
        second.forEach((d) => { secondSet.add(d.label); });
        const onlyFirst = first
            .filter((d) => { return !secondSet.has(d.label); })
            .map((d) => { return { label: d.label, value: 0 }; });
        let data = [];
        if (this.sorted) {
            data = D3.merge([second, onlyFirst])
                .sort((a, b) => {
                    return D3.ascending(a['value'], b['value']);
                });
        } else {
            data = D3.merge([second, onlyFirst]);
        }
        return data;
    }

    /**
     * To populate the piechart with given property and dataset using D3 lib
     * @param Array<ChartData>
     */
    populatePieChart(data: Array<ChartData>): void {
        // check for nodata
        this._total = D3.sum(data, d => d.value);
        if (data.length < 1 || this._total === 0) {
            data = [new ChartData({ value: 1, label: 'nodata', id: 'null' })];
            this._hoverSlice = this._svg.select('.hovers').selectAll('path.hoverslices').remove();
            this._colors = D3.scaleLinear<string>()
                .domain([0, data.length])
                .range([
                    this._whitelabelService.getPropertyValue(COLORWHITELABEL.BASE_COLOR,
                        {opacity: COLORWHITELABEL.OPAQUE_5, toRgb: true}),
                        'white'])
                .interpolate(D3.interpolateRgb);

        }

        const __this = this;
        let data0 = this._svg.select('.slices').selectAll('path.slice')
            .data().map(d => d.data);
        if (data0.length === 0) { data0 = data; }
        const oldData = this.mergeWithFirstEqualZero(data, data0);
        const newData = this.mergeWithFirstEqualZero(data0, data);
        const key = (d) => { return d.data.label; };
        /* ------- SLICE ARCS -------*/
        // select paths, use arc generator to draw
        let slice: any = this._svg.select('.slices').selectAll('path.slice')
            .data(this._pie(oldData), key);

        slice.enter()
            .insert('path')
            .attr('class', 'slice');

        slice = this._svg.select('.slices').selectAll('path.slice')
            .data(this._pie(newData), key);

        slice
            .transition()
            .duration(0)
            .attrTween('d', function (d) {
                this._current = this._current || d;
                const interpolate = D3.interpolate(this._current, d);
                this._current = interpolate(0);
                let arc = __this._arcNormal;
                if (d.data === __this.chartService.activeItem) {
                    arc = __this._arcClick;
                }
                return function (t) {
                    return arc(interpolate(t));
                };
            });

        slice = this._svg.select('.slices').selectAll('path.slice')
            .data(this._pie(data), key)
            .attr('fill', (_d, i) => {
                    if (_d.data['color'] ) {
                        return _d.data['color'];
                    } else {
                        return this._colors(i);
                    }
                })
            .attr('data-value', (d) => { return d.data['value']; })
            .attr('id', (d) => { return d.data['id']; })
            .style('opacity', 0);

        this._hoverSlice = this._svg.select('.hovers').selectAll('path.hoverslices')
            .style('opacity', 0);

        if (data.length > 0 && this._total > 0) {
            // hover effect arc...
            this._hoverSlice = this._svg.select('.hovers').selectAll('path.hoverslices')
                .data(this._pie(oldData), key).enter()
                .insert('path')
                .attr('class', 'hoverslices')
                .attr('fill', this._whitelabelService.getPropertyValue(COLORWHITELABEL.BASE_COLOR_INVERTED,
                    {opacity: COLORWHITELABEL.OPAQUE_5}))
                .style('opacity', 0);

            this._hoverSlice = this._svg.select('.hovers').selectAll('path.hoverslices')
                .data(this._pie(newData), key)
                .each(function (d) { this._current = d; })
                .attr('id', (d) => { return 'border-' + d.data['id']; });

            this._hoverSlice
                .transition().duration(PIECHARTCONFIG.TRANSISIONDURATION)
                .attrTween('d', function (d) {
                    this._current = this._current || d;
                    const interpolate = D3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    const arc = __this._arcHover;
                    return function (t) {
                        return arc(interpolate(t));
                    };
                });

            this._hoverSlice = this._svg.select('.hovers').selectAll('path.hoverslices')
                .data(this._pie(data), key)
                .exit()
                .remove();

            // mouse events for arc...
            slice
                .on('mousemove', ({ data: itemData }) => {
                    const value = this.createValueString(itemData);
                    let miscItems: string = '';
                    if (itemData.misc) {
                        miscItems += '<tbody>';
                        miscItems += itemData.misc.map(miscItemData => {
                            const innerValue = this.createValueString(miscItemData);
                            return `
                                <tr>
                                    <td style="text-align: left; padding-right: 10px" >&bull; ${miscItemData.label}</td>
                                    <td style="text-align: right;">${innerValue}</td>
                                </tr>
                            `;
                        }).join('\n');
                        miscItems += '</tbody>';
                    }
                    const dataTip: string = `
                        <table>
                            <thead><tr style='font-size: 12px; height: 20px'><td colspan="2">${itemData.label} (${value})</td></tr><thead>
                            ${miscItems}
                        </table>`;

                    this.showTooltip(dataTip, D3.event.pageX + 10, D3.event.pageY - 25, {
                        leftAlign: true
                    });
                })
                .on('mouseover', (d: ChartData) => {
                    // show the hover effect
                    if (this.chartService.activeItem !== d.data) {
                        this.chartService.hoverItem = d.data;
                    } else {
                        this.chartService.hoverItem = null;
                    }
                })
                .on('mouseout', () => {
                    // hide the hover effect and tooltip
                    this.chartService.hoverItem = null;
                    this.hideTooltip();
                })
                .on('click', d => {
                    // if we click the active item, toggle it and set activeItem = null
                    // this will trigger the activeItem$.subscribe in the constructor()
                    if (d.data === this.chartService.activeItem) {
                        this.chartService.activeItem = null;
                    } else {
                        this.chartService.activeItem = d.data;
                    }
                });
        }
        slice
            .exit().transition().delay(PIECHARTCONFIG.TRANSISIONDURATION).duration(0)
            .remove();
    }
}
