import { TileGroupService } from './tile-group.service';
import { NumberHelper } from './../../core/helpers/number.helper';
import {
    AfterViewInit,
    Component,
    ContentChildren, ElementRef,
    EventEmitter,
    forwardRef,
    HostBinding,
    Input,
    OnDestroy, OnInit,
    Output,
    QueryList,
    Renderer2,
    ViewEncapsulation
} from '@angular/core';
import { ApplicationStorageHelper } from '../../core/helpers/application-storage.helper';
import { KEYBOARD } from '../../core/constants/keyboard.constants';
import { DOMHelper } from '../../core/helpers/dom.helper';
import { TILES } from '../../core/constants/tiles.constants';
import { TileItemComponent } from './tile-item/tile-item.component';
import { TableRowData } from '../../core/models/table-row-data.model';
import { TableHeaderItem } from '../../core/models/table-header-item.model';
import { FIELD_TYPE } from '../../core/constants/field-type.constants';
import { ALIGNMENT } from '../../core/constants/alignment.constants';
import { ORDER } from '../../core/constants/order.constants';
import { STATE } from '../../core/constants/state.constants';
import { TableOrderEvent } from '../../core/models/table-order.event';
import * as _ from 'lodash';
import { TranslateService } from '@ngx-translate/core';
import { UnSub } from '../../core/classes/subscription.decorator';
import { Subscription } from 'rxjs/Subscription';
import { SIZING } from '../../core/constants/sizing.constants';
import { ActionItem, Divider, EntityVersion, TableAction } from '../../core/models';
import { DateHelper } from '../../core/helpers/date.helper';
import { StringHelper } from '../../core/helpers';
import { Subject, Observable } from 'rxjs';
import { TableRowComponent } from '../table/table-row/table-row.component';
import { ResizeService } from '../../core/services';
@Component({
    selector: 'cui-tile-group',
    templateUrl: 'tile-group.component.html',
    styleUrls: ['tile-group.component.scss'],
    encapsulation: ViewEncapsulation.None
})
@UnSub()
export class TileGroupComponent implements OnInit, OnDestroy, AfterViewInit {
    @HostBinding('class.cui-tile-group') addClass: boolean = true;
    @HostBinding('class.has-modified-date') get containsModifiedDate(): boolean {
        return this.items.toArray().some((item: TileItemComponent) => {
            return !item.fullSized && DateHelper.isDateObj(item.tileData.modifiedDate);
        });
    }
    @HostBinding('class.has-description') get containsDescription(): boolean {
        return this.items.toArray().some((item: TileItemComponent) => {
            return !item.fullSized && item.tileData.text && item.tileData.text !== '';
        });
    }
    @HostBinding('class.has-meta') get containsMeta(): boolean {
        return this.items.toArray().some((item: TileItemComponent) => {
            return !item.fullSized && item.hasMeta;
        });
    }
    @HostBinding('class.has-content') get containsContent(): boolean {
        return this.items.toArray().some((item: TileItemComponent) => {
            return item.fullSized || item.hasMeta ||
                (typeof item.tileData.text === 'string' && item.tileData.text !== '')
                || item.tileData.modifiedDate instanceof Date;
        });
    }
    @HostBinding('class.has-image') get containsImage(): boolean {
        return this.items.toArray().some((item: TileItemComponent) => {
            return !item.fullSized && item.tileData.image && item.tileData.image !== '';
        });
    }
    @HostBinding('class.is-selectable') @Input() selectable: boolean = false;

    @Input() label: string;

    private _layout$: Subject<string> = new Subject<string>();
    public layoutStream$: Observable<string> = this._layout$.asObservable();

    _layout: string;
    get layout(): string {
        return this._layout;
    }
    @Input('layout')
    set layout(value: string) {
        if (this._layout !== value) {
            this._layout = value;
            this._layout$.next(value);
        }
    }

    @Input() showLayouts: boolean = true;
    @Input() showTable: boolean = true;
    @Input() showLandscape: boolean = true;
    @Input() batchActions: Array<ActionItem> = [];
    @Output() onBatchClick: EventEmitter<ActionItem> = new EventEmitter<ActionItem>();

    @ContentChildren(forwardRef(() => TileItemComponent)) items: QueryList<TileItemComponent>;
    tiles = TILES;
    private _keydownListener: Function;
    private _lastLayout: string;
    tableData: { header: TableHeaderItem[], data: TableRowData[] } = { header: [], data: [] };
    displayTableData: TableRowData[];
    hideLandscape: boolean = false;
    gridIcon: string = 'grid-view';
    size: string = 'medium';
    validColumn: TableHeaderItem;
    discontinuedColumn: TableHeaderItem;
    relationColumn: TableHeaderItem;
    private _subscriptions: Array<Subscription> = [];
    private _translations: Array<String> = [];

    constructor(private _renderer: Renderer2,
        translate: TranslateService,
        public elementRef: ElementRef,
        private _tileGroupService: TileGroupService,
        private _resizeService: ResizeService) {
        this._keydownListener = this._renderer.listen(window, 'keydown', e => this.bindKeyboardShortcuts(e));
        translate.stream([
            'ODEN.COMMON.NAME',
            'ODEN.COMMON.TYPE',
            'ODEN.COMMON.SUBTITLE',
            'ODEN.COMMON.STATE',
            'ODEN.COMMON.DESCRIPTION',
            'ODEN.COMPONENTS.ENTITY_VERSION.VALID',
            'ODEN.COMPONENTS.ENTITY_VERSION.COMMERCIAL_AVAILABLITY',
            'ODEN.COMPONENTS.TILE.MODIFIED_DATE',
            'ODEN.COMPONENTS.TILE.ENTITY_RELATION_TYPE'
        ]).subscribe((res: Array<String>) => {
            this._translations = res;
        });
        this._subscriptions.push(this._tileGroupService.onSelectTile.subscribe((id: string) => {
            this.selectTile(id);
        }));
        this._subscriptions.push(this._tileGroupService.onFocusTile.subscribe((id: string) => {
            this.focusTile(id);
        }));
        this._subscriptions.push(this.layoutStream$.subscribe(() => {
            if (this.items) {
                setTimeout(() => {
                    this.items.toArray().forEach((item: TileItemComponent) => {
                        item.onResize();
                    });
                });
            }
        }));
    }

    /**
     * Fix layout based on input or cookie
     */
    ngOnInit(): void {
        const cookie = ApplicationStorageHelper.getCookie('ODEN.TILES.LAYOUT');
        if (cookie && this.showLayouts) {
            this.layout = cookie;
        } else if (!this.layout) {
            this.layout = TILES.LANDSCAPE;
        }
        if (this.layout === TILES.TABLE && !this.showTable) {
            this.layout = TILES.LANDSCAPE;
        }
        if (this.layout === TILES.LANDSCAPE && !this.showLandscape) {
            this.layout = TILES.PORTRAIT;
        }
        if (this.items) {
            this.hideLandscapeOrNot();
        }
    }

    /**
     * Sets an item to selected and scrolls the viewport to it.
     * @param {string} id
     */
    selectTile(id: string): void {
        if (id) {
            const item = this.items.toArray().filter((_item: TileItemComponent) => _item.tileData.id === id);
            const element = document.getElementById(id);
            if (element && item.length) {
                setTimeout(() => {
                    item[0].tileData.selected = true;
                    item[0].onTileSelection.emit(item[0].tileData);
                    element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 300);
            }
            this._tileGroupService.selected = null;
        }
    }

    /**
     * Sets an tile to focused and scrolls the viewport to it.
     * @param {string} id
     */
    focusTile(id: string): void {
        if (id) {
            const item = this.items.toArray().filter((_item: TileItemComponent) => _item.tileData.id === id);
            const element = document.getElementById(id);
            if (element && item.length) {
                setTimeout(() => {
                    this._renderer.addClass(element, 'focus');
                    element.focus();
                    setTimeout(() => {
                        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    });
                }, 300);
            }
            this._tileGroupService.focused = null;
        }
    }

    createTableHeaders(): void {
        this.tableData.header = [
            new TableHeaderItem({
                label: this._translations['ODEN.COMMON.NAME'],
                order: ORDER.NONE,
                sortOrders: [ORDER.NONE],
                field: 'title', width: '200px'
            }),
            new TableHeaderItem({
                label: this._translations['ODEN.COMMON.SUBTITLE'],
                order: ORDER.NONE,
                sortOrders: [ORDER.NONE],
                field: 'subtitle', width: '150px'
            }),
            new TableHeaderItem({
                label: this._translations['ODEN.COMMON.TYPE'],
                order: ORDER.NONE,
                sortOrders: [ORDER.NONE],
                field: 'type', width: '150px'
            }),
            new TableHeaderItem({
                label: this._translations['ODEN.COMMON.STATE'], order: ORDER.NONE, field: 'state',
                width: '200px', fieldType: FIELD_TYPE.STATE, sortOrders: [ORDER.NONE]
            }),
            new TableHeaderItem({
                label: this._translations['ODEN.COMMON.DESCRIPTION'],
                field: 'description',
                sortOrders: [ORDER.NONE]
            }),
            new TableHeaderItem({
                label: this._translations['ODEN.COMPONENTS.TILE.MODIFIED_DATE'],
                width: '150px',
                field: 'date',
                align: ALIGNMENT.RIGHT,
                sortOrders: [ORDER.NONE]
            })
        ];
        // add a Discontinued column if one or more tiles are discontinued
        this.discontinuedColumn = null;
        if (this.items.toArray().some((item: TileItemComponent) => item.isDiscontinued)) {
            this.discontinuedColumn = new TableHeaderItem({
                label: this._translations['ODEN.COMPONENTS.ENTITY_VERSION.COMMERCIAL_AVAILABLITY'],
                order: ORDER.NONE,
                sortOrders: [ORDER.NONE],
                field: 'discontinued', width: '175px'
            });
            this.tableData.header.splice(3, 0, this.discontinuedColumn);
        }
        // add a Valid column in case where looking a single version entity
        this.validColumn = null;
        if (this.items.toArray().some((item: TileItemComponent) => item.nmbOfVersions === 1)) {
            this.validColumn = new TableHeaderItem({
                label: this._translations['ODEN.COMPONENTS.ENTITY_VERSION.VALID'],
                order: ORDER.NONE,
                sortOrders: [ORDER.NONE],
                field: 'valid', width: '250px'
            });
            this.tableData.header.splice((this.discontinuedColumn ? 5 : 4), 0, this.validColumn);
        }

        // add a relation column in if one or more tiles has a relation specified
        this.relationColumn = null;
        if (this.items.toArray().some((item: TileItemComponent) => item.entityRelationType !== undefined)) {
            this.relationColumn = new TableHeaderItem({
                label: this._translations['ODEN.COMPONENTS.TILE.ENTITY_RELATION_TYPE'],
                field: 'relation',
                order: ORDER.NONE,
                sortOrders: [ORDER.NONE]
            });
            this.tableData.header.splice(this.tableData.header.length - 1, 0, this.relationColumn);
        }
    }

    bindKeyboardShortcuts(e: KeyboardEvent) {
        if (e.keyCode === KEYBOARD.TAB) {
            setTimeout(() => {
                if (DOMHelper.closestParent(document.activeElement, 'tiles-views')) {
                    this._renderer.addClass(document.activeElement, 'tabbed');
                }
            });
        } else if ((e.keyCode === KEYBOARD.ENTER || e.keyCode === KEYBOARD.SPACE) &&
            DOMHelper.closestParent(document.activeElement, 'tiles-views')) {
            e.preventDefault();
            (<HTMLElement>document.activeElement).click();
        }
    }

    onSelectRow(rows: Array<TileRowData>): void {
        this.items.toArray().forEach((tile: TileItemComponent) => {
            tile.tileData.selected = rows.some((row: TileRowData) => row.id === tile.tileData.id);
        });
    }

    removeTabbed(): void {
        Array.from(document.querySelectorAll('.tiles-views .cui-icon.tabbed')).forEach((el: HTMLElement) => {
            this._renderer.removeClass(el, 'tabbed');
        });
    }

    ngAfterViewInit(): void {
        Promise.resolve().then(() => {
            this._subscriptions.push(
                this._resizeService.resize$.subscribe(() => this.onResize())
            );
            this.items.toArray().forEach((item: TileItemComponent) => {
                item.layout = this.layout;
            });
            this.makeTable();
            this._subscriptions.push(this.items.changes.subscribe(() => {
                this.makeTable();
            }));
            this.selectTile(this._tileGroupService.selected);
            this.focusTile(this._tileGroupService.focused);
        });
    }

    /**
     * We only show the landscape layout option if one or more tiles have sections in them
     */
    hideLandscapeOrNot(): void {
        if (this.layout === TILES.TABLE) {
            // TODO: This check will return incorrectly if no items have tileData.sections BUT ng-content cui-sections
            // (only outputted in the DOM when the layout is landscape or portrait)
            this.hideLandscape = !this.items.toArray().some((item: TileItemComponent) => item.tileData.sections.length > 0)
                && !this.items.toArray().some((item: TileItemComponent) => item.fullSized);
        } else {
            this.hideLandscape = !(this.elementRef.nativeElement.querySelectorAll('.cui-tile-section').length >=
                this.items.toArray().length && this.size !== 'tiny') &&
                !this.items.toArray().some((item: TileItemComponent) => item.fullSized);
        }
        // Force portrait mode if we have landscape but it's not supposed to be chosen.
        if (this.layout === TILES.LANDSCAPE && this.hideLandscape) {
            this._lastLayout = this.layout;
            this.layout = TILES.PORTRAIT;
            this.items.toArray().forEach((item: TileItemComponent) => {
                item.layout = this.layout;
            });
        }
    }

    /**
     * Change layout and make items hidden temporarely in order to resize them without it looking ugly.
     */
    changeLayout(layout: string): void {
        this.items.toArray().forEach((item: TileItemComponent) => {
            item.hidden = true;
        });
        setTimeout(() => {
            // make sure the `selected` flag becomes the same as the row's `selected` flag
            if (this.layout === TILES.TABLE) {
                this.displayTableData.forEach((row: TileRowData) => {
                    const findTile = this.items.toArray().filter((tile: TileItemComponent) => tile.tileData.id === row.id);
                    if (findTile.length > 0) {
                        findTile[0].tileData.selected = row.selected;
                    }
                });
            }
            if (layout === TILES.TABLE) {
                this.makeTable();
            }
            this.layout = layout;
            this.items.toArray().forEach((item: TileItemComponent) => {
                item.layout = layout;
                item.hidden = true;
            });
            setTimeout(() => {
                // trigger onReSize for each item
                this.items.toArray().forEach((item: TileItemComponent) => {
                    item.onResize();
                });
            });
            ApplicationStorageHelper.setCookie('ODEN.TILES.LAYOUT', layout, 30);
        }, 300);
    }

    /**
     * When we resize the window we make sure the layout options (and icons) look as they should.
     */
    onResize(): void {
        // get width from tile-group element rather than window. adding 32 pixels because of cui-containers padding.
        const width = this.elementRef.nativeElement.offsetWidth + 32;
        if (width <= SIZING.MEDIUM_SCREEN) {
            this.size = 'tiny';
            this.gridIcon = 'tile-view';
        } else if (width > SIZING.MEDIUM_SCREEN) {
            if (width >= SIZING.PAGE_MAX_WIDTH) {
                this.size = 'xlarge';
                this.gridIcon = 'grid-view-small';
            } else if (width >= 1366) {
                this.size = 'large';
                this.gridIcon = 'grid-view-small';
            } else if (width >= 1024) {
                this.size = 'medium';
                this.gridIcon = 'grid-view';
            } else {
                this.size = 'small';
                this.gridIcon = 'grid-view-big';
            }
            if (this._lastLayout && this.layout === TILES.PORTRAIT) {
                this.layout = this._lastLayout;
                this._lastLayout = null;
                this.items.toArray().forEach((item: TileItemComponent) => {
                    item.layout = this.layout;
                });
            }
        }
        this.hideLandscapeOrNot();
    }
    makeTable(): void {
        this.createTableHeaders();
        const rows: Array<TableRowData> = [];
        this.items.toArray().forEach((item: TileItemComponent) => {
            const validString = item.versionValidString();
            const newRow = new TileRowData({
                id: item.tileData.id,
                title: item.tileData.label,
                subtitle: item.tileData.subtitle,
                type: item.tileData.subtype,
                valid: validString ? StringHelper.removeTags(validString) : '',
                state: item.tileData.state,
                relation: item.tileData.entityRelationType,
                date: item.tileData.modifiedDate,
                description: item.tileData.text,
                versions: item.tileData.versions,
                draftFromTileData: item.draftFromTileData,
                nonDraftFromTileData: item.nonDraftFromTileData,
                rowActions: item.tileActions,
                timelineTooltip: item.timelineTooltip,
                versionsTooltip: item.tileData.versionsTooltip,
                draftTooltip: item.draftTooltip,
                discontinued: item.tileData.discontinued,
                path: item.tileData.path
            });
            // assigning here because of QuickAssign model bug
            newRow.selected = item.tileData.selected;
            rows.push(newRow);
        });
        this.tableData.data = rows;
        this.displayTableData = _.cloneDeep(this.tableData.data);
    }

    isNumber(variable: any): boolean {
        return NumberHelper.isNumber(variable);
    }

    /**
     * An event bound to table component. Gets triggered when user changes order
     * @param item:TableOrderEvent
     */
    tableOrderChanged(item: TableOrderEvent): void {
        if (item.order === ORDER.NONE) {
            return;
        }
        this.tableData.header.forEach((i) => i.order = i.field === item.field ? item.order : ORDER.NONE);
        // Treat as a string
        this.displayTableData = this.tableData.data.sort((a, b) => {
            if (item.order === ORDER.DESCENDING) {
                [a, b] = [b, a]; // Reverse order
            }
            return a[item.field].toString().localeCompare(b[item.field].toString());
        });
    }

    get selectedItems(): Array<TileItemComponent> {
        return this.items.toArray().length > 0 ? this.items.toArray().filter((i) => {
            return i.tileData.selected;
        }) : [];
    }

    get actions(): Array<ActionItem | Divider> {
        return this.items.toArray().length > 0 ? this.items.toArray()[0].actions : [];
    }

    /**
     * batchClick EventEmitter. Sends TableAction to EventEmitter.
     * @param action
     */
    batchClick(action: ActionItem): void {
        const _action = new ActionItem(action);
        _action.items = this.selectedItems.map((tileItem: TileItemComponent) => tileItem.tileData);
        this.onBatchClick.emit(_action);
    }

    /**
     * Find the right tile and emit it's onActionClick
     * @param {TableAction} action
     */
    onRowActionClick(action: TableAction): void {
        if (action.items.length) {
            const findTile = this.items.filter((tile: TileItemComponent) => (<TileRowData>action.items[0]).id === tile.tileData.id);
            if (findTile.length) {
                findTile[0].actionClick(action);
            }
        }
    }

    /**
     * Find the right tile and emit it's onTileClick
     */
    tableRowClick(rowItem: { data: TileRowData, component: TableRowComponent }): void {
        if (rowItem.data.id) {
            const items: TileItemComponent[] = this.items.toArray().filter(item => item.id === rowItem.data.id);
            if (items.length) {
                items[0].onTileClick.emit(rowItem.component);
            }
        }
    }

    /**
     * Deselect all selected items
     */
    deselectAllItems(): void {
        this.items.forEach((i) => {
            i.tileData.selected = false;
        });
    }

    ngOnDestroy(): void {
        if (typeof (this._keydownListener) !== 'undefined') {
            this._keydownListener();
        }
        this._subscriptions.forEach((s) => s.unsubscribe());
    }
}

export class TileRowData extends TableRowData {
    id: string;
    title: string;
    subtitle: string;
    type: string;
    valid: string;
    date: Date;
    state: STATE;
    description: string;
    relation: string;
    versions: number | Array<EntityVersion>;
    nonDraftFromTileData: EntityVersion;
    draftFromTileData: EntityVersion;
    selected: boolean;
    timelineTooltip: string;
    draftTooltip: string;
    versionsTooltip: string;
    discontinued: boolean;
}
