import {
    AfterViewInit,
    Component,
    ElementRef,
    EventEmitter,
    forwardRef,
    Host,
    HostBinding,
    HostListener,
    Inject,
    Input,
    OnChanges,
    OnDestroy,
    Optional,
    Output,
    Renderer2,
    SimpleChanges,
    TemplateRef,
    ViewEncapsulation
} from '@angular/core';
import { TranslateService } from '@ngx-translate/core';
import * as _ from 'lodash';
import * as moment from 'moment';
import 'moment/locale/en-gb';
import { KEYBOARD, ORDER, STATE, TAGTYPE } from '../../../core/constants';
import { ELEMENT_OVERLAY_STATE } from '../../../core/constants/element-overlay-state.constants';
import { TILES } from '../../../core/constants/tiles.constants';
import { OrderHelper } from '../../../core/helpers/order.helper';
import { StringHelper } from '../../../core/helpers/string.helper';
import { ActionItem, Divider, EntityVersion, Tag } from '../../../core/models';
import { ElementOverlayConfig } from '../../../core/models/element-overlay-config.model';
import { TileData } from '../../../core/models/tile-data.model';
import { TileSection } from '../../../core/models/tile-section.model';
import { ApplicationService } from '../../../core/services/application.service';
import { VersionsService } from '../../../core/services/versions.service';
import { IFocusShiftBlock } from '../../modal/focus-shift/focus-shift-block.interface';
import { TileGroupComponent } from '../tile-group.component';
import { NumberHelper } from './../../../core/helpers/number.helper';
import { TableRowComponent } from '../../table/table-row/table-row.component';

const momentInstance =
    typeof moment === 'object' ? (<any>moment).default : moment;

@Component({
    selector: 'cui-tile-item',
    templateUrl: 'tile-item.component.html',
    styleUrls: ['tile-item.component.scss'],
    encapsulation: ViewEncapsulation.None
})
export class TileItemComponent
    implements IFocusShiftBlock, OnChanges, AfterViewInit, OnDestroy {
    @HostBinding('class.cui-tile-item')
    addClass: boolean = true;
    @HostBinding('class.fullsized')
    @Input()
    fullSized: boolean = false;
    @HostBinding('class.clickable')
    get isClickable(): boolean {
        return (
            (this.tileData.path !== undefined && this.tileData.path !== null) ||
            this.onTileClick.observers.length > 0
        );
    }
    @HostBinding('class.selected')
    get isSelected(): boolean {
        return this.tileData.selected;
    }
    @HostBinding('class.discontinued')
    get isDiscontinued(): boolean {
        return this.tileData.discontinued;
    }
    @HostBinding('class.hidden')
    hidden: boolean = true;
    @HostBinding('attr.tabindex')
    get _tabIndex(): number {
        return this.isClickable ? this.tabIndex : null;
    }
    @HostBinding('class.focus')
    focused: boolean = false;
    @HostBinding('attr.id')
    get id(): string {
        return this.tileData.id ? this.tileData.id : null;
    }
    @Input()
    tabIndex: number = 0;
    @Input()
    tileData: TileData;
    @Input()
    actions: Array<ActionItem | Divider> = [];
    @Input()
    titleTooltipTemplate: TemplateRef<any>;
    @Input()
    descriptionTemplate: TemplateRef<any>;
    @Input()
    customDraftTooltip: string = '';
    @Output()
    onActionClick: EventEmitter<ActionItem> = new EventEmitter<ActionItem>();
    @Output()
    onTileClick: EventEmitter<TileItemComponent | TableRowComponent> = new EventEmitter<TileItemComponent | TableRowComponent>();
    @Output()
    onTileSelection: EventEmitter<TileData> = new EventEmitter<TileData>();
    maxDataRowsInSection: number = 4;
    elementRef: ElementRef;
    titleTooltip: string = '';
    timelineTooltip: string = '';
    draftTooltip: string = '';
    layout: string = TILES.LANDSCAPE;
    currentSection: number = 0;
    sections: Array<HTMLElement> = [];
    tileActions: Array<ActionItem | Divider> = [];
    overlayConfig: ElementOverlayConfig;
    entityRelationType: Tag;
    private _resizeListener: Function;
    private _isMouseDown: boolean = false;

    constructor(
        @Optional()
        @Host()
        @Inject(forwardRef(() => TileGroupComponent))
        public group: TileGroupComponent,
        private _renderer: Renderer2,
        private _applicationService: ApplicationService,
        public _element: ElementRef,
        private _translate: TranslateService,
        private _versionsService: VersionsService
    ) {
        this.elementRef = _element;
        this._resizeListener = this._renderer.listen(window, 'resize', () =>
            this.onResize()
        );
        if (this.group) {
            this.layout = this.group.layout;
        }
        this.overlayConfig = new ElementOverlayConfig({
            state: ELEMENT_OVERLAY_STATE.NOTICE,
            label: 'Discontinued'
        });
    }

    @HostListener('keydown', ['$event'])
    enterPress(event: KeyboardEvent): void {
        if (
            this._element.nativeElement === document.activeElement &&
            (event.keyCode === KEYBOARD.ENTER ||
                event.keyCode === KEYBOARD.SPACE)
        ) {
            this.onTileClick.emit(this);
            if (this.tileData.path !== undefined && this.tileData.path) {
                this._applicationService.navigateToPath(this.tileData.path);
            }
            event.preventDefault();
        }
    }

    @HostListener('focus', ['$event'])
    onFocus(): void {
        this.focused = !this._isMouseDown;
    }

    @HostListener('blur', ['$event'])
    onBlur(): void {
        this.focused = false;
    }

    /**
     * We only *show* the focus style when focus has come to the element via the keyboard.
     * We make this work with the _isMouseDown variable.
     */
    @HostListener('mousedown')
    public onMouseDown(): void {
        this._isMouseDown = true;
        this.focused = false;
        setTimeout(() => {
            this._isMouseDown = false;
        }, 100);
    }

    /**
     * Displays proper date and formats it if tileData.activeDate is Date object (used to be string only)
     * @returns {string}
     */
    get displayDate(): string {
        const { activeDate: date, dateFormat } = this.tileData;
        if (date instanceof Date) {
            return momentInstance(date).format(dateFormat);
        }
        return date;
    }

    get draftFromTileData(): EntityVersion {
        let version: EntityVersion = null;
        if (this.tileData.versions instanceof Array) {
            this.tileData.versions.forEach((_version: EntityVersion) => {
                if (_version.state === STATE.DRAFT) {
                    version = _version;
                }
            });
        }
        return version;
    }

    get nonDraftFromTileData(): EntityVersion {
        let version: EntityVersion = null;
        if (this.tileData.versions instanceof Array) {
            const nonDrafts = this.tileData.versions.filter(
                (v: EntityVersion) => v.state !== STATE.DRAFT
            );
            this.tileData.versions.forEach((_version: EntityVersion) => {
                if (_version.state !== STATE.DRAFT && !version) {
                    _version.extra = nonDrafts.length;
                    version = _version;
                }
            });
        }
        return version;
    }

    /**
     * Return YYYY-MM-DD to YYYY-MM-DD string from given version (or from the only version if not supplied)
     * @param {EntityVersion} version
     * @returns {string}
     */
    versionValidString(version?: EntityVersion): string {
        if (this.nmbOfVersions === 1 || version) {
            if (!version) {
                version = this.tileData.versions[0];
            }
            let string = '';
            const validFrom:
                | string
                | null = this._versionsService.entityDateToString(
                    version.validFrom
                );
            if (validFrom) {
                string = `<em>${this._versionsService.entityDateToString(
                    version.validFrom
                )}</em> `;
            }
            const to: string | null = this._versionsService.entityDateToString(
                version.validTo
            );
            if (to) {
                string +=
                    this._translate.instant('ODEN.COMMON.TO').toLowerCase() +
                    ` <em>${to}</em>`;
            }
            return string;
        }
        return '';
    }

    get nmbOfVersions(): number {
        if (this.tileData.versions instanceof Array) {
            return this.tileData.versions.length;
        }
        return 0;
    }

    /**
     * Create tileActions and/or warn about activeDate being a string
     * @param {SimpleChanges} changes
     */
    ngOnChanges(changes: SimpleChanges) {
        if (changes['tileData']) {
            // Warn developer to change activeDate from string to Date if necessary
            if (typeof changes['tileData'].currentValue.activeDate === 'string') {
                console.warn('Please change tileData.activeDate from string to Date');
            }
            if (changes['tileData'].currentValue.entityRelationType) {
                this.entityRelationType = new Tag({
                    value: changes['tileData'].currentValue.entityRelationType,
                    type: TAGTYPE.EntityRelation
                });
            }
            if (this.tileData.versions instanceof Array && this.tileData.versions.length > 1) {
                let actions: Array<ActionItem | Divider> = [];
                const versions = _.cloneDeep(this.tileData.versions);
                OrderHelper.orderByDate(
                    versions,
                    'validFrom',
                    ORDER.DESCENDING
                );
                versions.forEach((v: EntityVersion) => {
                    actions.push(
                        new ActionItem({
                            label:
                                (v.state === STATE.DRAFT
                                    ? `${this._translate.instant(
                                        'ODEN.COMMON.STATES.DRAFT'
                                    )} (`
                                    : '') +
                                StringHelper.removeTags(
                                    this.versionValidString(v)
                                ) +
                                (v.state === STATE.DRAFT ? ')' : ''),
                            action: 'version',
                            data: v
                        })
                    );
                });
                // show max 10 versions
                actions = actions.splice(0, 10);
                actions.push(new Divider());
                this.tileActions = actions.concat(this.actions);
            } else {
                this.tileActions = this.actions;
            }
            if (!changes['tileData'].firstChange) {
                this.group.makeTable();
            }
        }
        Promise.resolve().then(() => {
            const titleTooltip = this.elementRef.nativeElement.querySelector(
                '.title-tooltip'
            );
            this.titleTooltip = titleTooltip ? titleTooltip.innerHTML : null;
            const timelineTooltip = this.elementRef.nativeElement.querySelector(
                '.timeline-tooltip'
            );
            this.timelineTooltip = timelineTooltip
                ? timelineTooltip.innerHTML
                : null;
            const draftTooltip = this.elementRef.nativeElement.querySelector(
                '.draft-tooltip'
            );
            this.draftTooltip = draftTooltip ? draftTooltip.innerHTML : null;
        });
    }

    ngAfterViewInit(): void {
        if (this.layout !== TILES.TABLE) {
            this.setSectionsSize(
                Array.from(
                    this.elementRef.nativeElement.querySelectorAll(
                        '.cui-tile-section'
                    )
                ),
                false
            );
            setTimeout(() => {
                this.onResize();
            });
        }
    }

    isNumber(variable: any): boolean {
        return NumberHelper.isNumber(variable);
    }

    get hasMeta(): boolean {
        return (
            this.versionsInArray > 0 ||
            (this.isNumber(this.tileData.versions) &&
                (this.isNumber(this.tileData.state) ||
                    this.tileData.activeDate instanceof Date ||
                    this.tileData.versions > 0))
        );
    }

    get versionsInArray(): number {
        return this.tileData.versions instanceof Array
            ? this.tileData.versions.length
            : 0;
    }

    get numberOfVersions(): number {
        return this.tileData.versions instanceof Array
            ? this.tileData.versions.length
            : this.isNumber(this.tileData.versions)
                ? this.tileData.versions
                : 0;
    }

    setImages(): void {
        const image = this.elementRef.nativeElement.querySelector(
            '.image [data-image]'
        );
        if (image && image.classList.contains('loading')) {
            const img = document.createElement('img');
            img.src = image.getAttribute('data-image');
            img.onload = () => {
                this._renderer.removeClass(image, 'loading');
                this._renderer.setStyle(
                    image,
                    'background-image',
                    `url('${img.src}')`
                );
            };
        }
    }

    setSectionsSize(
        elements: Array<HTMLElement>,
        positionSections: boolean = true
    ): void {
        if (this.layout === TILES.PORTRAIT) {
            if (positionSections) {
                this.positionSections();
            }
            this._renderer.removeStyle(this.elementRef.nativeElement, 'height');
            this._renderer.addClass(this.elementRef.nativeElement, 'static');
        }
        elements.forEach((element: HTMLElement) => {
            if (this.layout === TILES.PORTRAIT) {
                this._renderer.setStyle(
                    element,
                    'width',
                    this.elementRef.nativeElement.offsetWidth - 32 + 'px'
                );
            } else {
                this._renderer.removeStyle(element, 'width');
            }
        });
        if (this.layout === TILES.PORTRAIT) {
            setTimeout(() => {
                this._renderer.setStyle(
                    this.elementRef.nativeElement,
                    'height',
                    this.elementRef.nativeElement.offsetHeight + 'px'
                );
                this._renderer.removeClass(
                    this.elementRef.nativeElement,
                    'static'
                );
            });
        }
    }

    shouldShowDraftTooltip(version: EntityVersion): boolean {
        if (!version) {
            return false;
        }
        if (
            typeof version.validFrom === 'undefined' &&
            typeof version.validTo === 'undefined'
        ) {
            return false;
        }
        return true;
    }

    onResize(): void {
        if (this.layout === TILES.TABLE) {
            return;
        }
        this.sections = Array.from(
            this.elementRef.nativeElement.querySelectorAll('.cui-tile-section')
        );
        this.setSectionsSize(this.sections);
        const p = this.elementRef.nativeElement.querySelector('p.description');
        if (p) {
            if (!this.tileData.text || this.tileData.text === '') {
                p.innerHTML = '-';
            } else {
                p.innerHTML = this.tileData.text;
                const container = this.elementRef.nativeElement.querySelector(
                    'div.description-wrapper'
                );
                const divh = container.clientHeight;
                while (p.offsetHeight > divh) {
                    // Check if the paragraph's height is taller than the container's height. If it is:
                    p.textContent = p.textContent.replace(/\W*\s(\S)*$/, '...'); // add an ellipsis at the last shown space
                    if (p.offsetHeight <= divh) {
                        // cut last line in half
                        p.textContent =
                            p.textContent.substr(
                                0,
                                p.textContent.length - p.textContent.length / 6
                            ) + '...';
                    }
                }
            }
        }
        this.setImages();
        setTimeout(() => {
            this.hidden = false;
        });
    }

    /**
     * Action dispatcher for onActionClick
     * @param actionItem
     */
    actionClick(actionItem: ActionItem): void {
        this.onActionClick.emit(actionItem);
    }

    /**
     * Gets the section data that should be displayed, ignoring rows that surpasses maxDataRowsInSection
     * @param section:TileSection
     * @returns {Array<string>}
     */
    getSectionDisplayData(section: TileSection): Array<string> {
        let returnSections: Array<string> = [];
        if (this.maxDataRowsInSection < section.data.length) {
            returnSections = section.data.slice(
                0,
                this.maxDataRowsInSection - 1
            );
        } else {
            returnSections = section.data;
        }
        return returnSections;
    }

    /**
     * When a checkbox is changed, we update the tile data and emits an event
     * @param event
     * @param tileData
     */
    onTileSelect(event: Event, tileData: TileData): void {
        tileData.selected = event.target['checked'];
        this.onTileSelection.emit(tileData);
    }

    /**
     * Gets the extra section data that surpasses maxDataRowsInSection
     * and returns it as string with row breaks for the tooltip
     * @param section:TileSection
     * @returns string
     */
    getSectionTooltip(section: TileSection): string {
        let returnSections: Array<string> = [];
        if (this.maxDataRowsInSection < section.data.length) {
            returnSections = this.getExtraSectionDisplayData(section);
        }
        let tooltip = '';
        returnSections.forEach(row => {
            tooltip += row + '\n\r';
        });
        return tooltip;
    }

    /**
     * Gets the extra section data that surpasses maxDataRowsInSection
     * @param section:TileSection
     * @returns {Array<string>}
     */
    getExtraSectionDisplayData(section: TileSection): Array<string> {
        return section.data.slice(this.maxDataRowsInSection - 1);
    }

    /**
     * itemClick EventEmitter
     */
    itemClick(event: Event): void {
        if (
            (<HTMLElement>event.target).getAttribute('for') !==
            `select-${this.tileData.uuid}` &&
            (<HTMLElement>event.target).getAttribute('id') !==
            `select-${this.tileData.uuid}`
        ) {
            this.onTileClick.emit(this);
            if (this.tileData.path !== undefined && this.tileData.path) {
                this._applicationService.navigateToPath(this.tileData.path);
            }
        }
    }

    /**
     * Go to previous column set
     */
    prevSection(event: Event): void {
        event.stopImmediatePropagation();
        this.changeSection(event, this.currentSection - 1);
    }

    /**
     * Go to next column set
     */
    nextSection(event: Event): void {
        event.stopImmediatePropagation();
        this.changeSection(event, this.currentSection + 1);
    }

    /**
     * Change to the new column set index
     * @param index
     */
    changeSection(event: Event, index: number): void {
        event.stopImmediatePropagation();
        if (this.sections[index]) {
            this.currentSection = index;
        }
        this.positionSections();
    }

    /**
     * Position sections based on if they are located before or after the active section
     */
    positionSections(): void {
        this.sections.forEach((element: HTMLElement, i: number) => {
            if (i < this.currentSection) {
                this._renderer.removeClass(element, 'active');
                this._renderer.removeClass(element, 'right');
                this._renderer.addClass(element, 'left');
            } else if (i > this.currentSection) {
                this._renderer.removeClass(element, 'active');
                this._renderer.removeClass(element, 'left');
                this._renderer.addClass(element, 'right');
            } else {
                this._renderer.removeClass(element, 'right');
                this._renderer.removeClass(element, 'left');
                this._renderer.addClass(element, 'active');
            }
        });
    }

    ngOnDestroy(): void {
        if (typeof this._resizeListener !== 'undefined') {
            this._resizeListener();
        }
    }
}
