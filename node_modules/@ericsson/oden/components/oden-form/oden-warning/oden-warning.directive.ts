import {
    Directive, ElementRef, OnDestroy, HostListener, Input, Renderer2, OnChanges, SimpleChanges, HostBinding, AfterViewInit
} from '@angular/core';
import { DOMHelper } from '../../../core/helpers/dom.helper';
import { Subject, Subscription } from 'rxjs';
import { debounceTime, throttleTime } from 'rxjs/operators';

@Directive({
    selector: 'label[warning][oden-label], label[warning][oden-form-header]'
})
export class OdenWarningDirective implements AfterViewInit, OnChanges, OnDestroy {
    private _subscriptions: Subscription[] = [];
    private _container: HTMLDivElement;
    private _shouldShow: Subject<void> = new Subject();
    private _shouldHide: Subject<void> = new Subject();
    private _show: boolean = false;
    @HostBinding('class.oden-warning') _hasOdenWarningClass: boolean = false;
    @HostListener('mousemove', ['$event']) onMouseEnter(event): void {
        if ((event.target.offsetWidth - 30) < event.layerX) {
            this._shouldShow.next();
        } else if (this._show) {
            this._shouldHide.next();
        }
    }
    @HostListener('mouseleave') onMouseLeave(): void {
        this._shouldHide.next();
    }
    @Input() warning: string;
    @Input() cuiTooltipOnOverflow: boolean = false;

    constructor(private _element: ElementRef, private _renderer: Renderer2) { }

    ngAfterViewInit(): void {
        this._subscriptions.push(this._shouldShow.pipe(throttleTime(200)).subscribe(() => this._showElement()));
        this._subscriptions.push(this._shouldHide.pipe(debounceTime(200)).subscribe(() => this._hideElement()));
    }

    ngOnChanges(changes: SimpleChanges): void {
        if (changes['warning'] && changes['warning'].currentValue !== changes['warning'].previousValue) {
            this._hasOdenWarningClass = !!this.warning && this.warning.length > 0;
            if (this._container && this._show) {
                this._showElement(true);
            }
        }
    }

    ngOnDestroy(): void {
        if (this._container && this._container.parentElement && document.body.contains(this._container)) {
            document.body.removeChild(this._container);
        }
        this._subscriptions.forEach((s) => s.unsubscribe());
    }

    private _showElement(forceRender: boolean = false): void {
        if (forceRender) {
            this._clearContainerFromDOM();
            this._container = null;
        }
        if (!forceRender && (!this.warning || this._show)) {
            return;
        }
        this._show = true;
        if (!this._container) {
            this._createContainer();
            this._addContainerToDOM();
        }
        this._setPosition();
        this._renderer.addClass(this._container, 'active');
    }

    private _hideElement(): void {
        if (!this._container || !this._show) {
            return;
        }
        this._show = false;
        this._renderer.removeClass(this._container, 'active');
    }

    private _createContainer(): void {
        this._container = document.createElement('div');
        this._container.className = 'cui-tooltip cui-tooltip-directive cui-tooltip-top';
        const tooltipTextContainer = document.createElement('div');
        tooltipTextContainer.className = 'cui-tooltip-text';
        tooltipTextContainer.innerHTML = /<[a-z][\s\S]*>/i.test(this.warning) ? this.warning : DOMHelper.nl2br(this.warning);
        this._container.appendChild(tooltipTextContainer);
    }

    private _addContainerToDOM(): void {
        if (this._container && this.warning && this.warning.length) {
            document.body.appendChild(this._container);
        }
    }

    private _clearContainerFromDOM(): void {
        document.body.removeChild(this._container);
    }

    /**
     * Calculates and sets the absolute position on the screen
     */
    private _setPosition(): void {
        if (!this._container) {
            return;
        }

        const rect = this._element.nativeElement.getBoundingClientRect();
        const targetTop = rect.top + document.body.scrollTop;
        const targetLeft = rect.left + document.body.scrollLeft;
        const bodyWidth = document.body.offsetWidth;
        const currentElLeft = this._container.style.left;
        const warningElWidth = DOMHelper.getOuterWidth(this._container);
        const nativeElWidth = DOMHelper.getOuterWidth(this._element.nativeElement);

        if (currentElLeft) {
            this._renderer.addClass(this._container, 'no-transition');
            this._container.style.left = '0px';
        }

        let left = targetLeft + nativeElWidth - (warningElWidth + 38) / 2;
        if (left + warningElWidth - 19 > bodyWidth) {
            left -= (left + warningElWidth - 19) - bodyWidth;
        }

        const top = targetTop - DOMHelper.getOuterHeight(this._container);

        if (currentElLeft) {
            this._container.style.left = currentElLeft;
            this._container.style.left = left + 'px';
            this._container.style.top = top + 'px';
            setTimeout(() => {
                this._renderer.removeClass(this._container, 'no-transition');
            }, 1);
        } else {
            this._container.style.top = top + 'px';
            this._container.style.left = left + 'px';
        }
    }
}
