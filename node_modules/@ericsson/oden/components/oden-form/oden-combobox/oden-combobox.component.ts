/* tslint:disable:directive-selector-name */
import {
    ChangeDetectorRef, Component, ContentChildren, ViewChild, ElementRef, EventEmitter, forwardRef, HostBinding, Input, OnDestroy,
    OnInit, Output, QueryList, Renderer2, ViewEncapsulation, AfterViewInit, Injector
} from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR, NgControl, AbstractControl } from '@angular/forms';
import { Subscription } from 'rxjs';
import { Observable } from 'rxjs/Observable';
import { Subject } from 'rxjs/Subject';
import { OdenOptionComponent } from './oden-option/oden-option.component';
import { debounceTime } from 'rxjs/operators';
import { UUID } from '../../../core/helpers/uuid.class';
import { TranslateService } from '@ngx-translate/core';
import { OdenErrorComponent } from '../oden-error/oden-error.component';

@Component({
    selector: 'oden-combobox',
    templateUrl: 'oden-combobox.component.html',
    providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => OdenComboboxComponent),
        multi: true
    }],
    styleUrls: ['oden-combobox.component.scss'],
    encapsulation: ViewEncapsulation.None
})
export class OdenComboboxComponent implements OnInit, AfterViewInit, OnDestroy, ControlValueAccessor {
    private _value: any;
    // @ts-ignore
    private _onMultipleChanged$: Subject<boolean> = new Subject<boolean>();
    private _setDisplayValue$ = new Subject<null>();
    private _clickListner?: Function;
    private _subscriptions: Array<Subscription> = [];
    private _ngControl: NgControl;
    private _clearInvisibleSearchTimout: any;
    private _invisibleSearchStr: string = '';
    // @ts-ignore
    private _noneLabel: string = '';
    public _hasRequiredValidator: boolean = false;
    public _tabindex: number = 0;
    public _showDefaultOption: boolean = false;
    public _multiple: boolean = false;
    public _displayValue: string;
    public _onMultipleChanged: Observable<boolean> = this._onMultipleChanged$.asObservable();
    public open = false;
    @HostBinding('class.oden-combobox') _hasOdenComboboxClass: boolean = true;
    @HostBinding('style.width') @Input() width: string = '100%';
    @HostBinding('tabindex') @Input() tabindex: number = -1;
    @HostBinding('attr.id') @Input() id: string = UUID.create();
    @HostBinding('attr.disabled') _disabled: boolean = false;
    @HostBinding('attr.readonly') _readonly: boolean = false;
    @ViewChild('input') private _inputRef: ElementRef;
    @ViewChild('comboboxMenu') private _menuRef: ElementRef;
    @ViewChild(forwardRef(() => OdenOptionComponent)) private _viewOptionRef: OdenOptionComponent;
    @ContentChildren(OdenErrorComponent) private _errorComponentsRef: QueryList<OdenErrorComponent>;
    @ContentChildren(forwardRef(() => OdenOptionComponent)) private _contentOptionsRef: QueryList<OdenOptionComponent>;
    @Input() label: string = '';
    @Input() warning: string = '';
    @Input() placeholder: string = '';
    @Input() noneLabel: string = '';
    @Input() showNoneIfNull: boolean = false;
    @Input() set disabled(disabled: boolean) {
        if (this._disabled !== disabled) {
            this._disabled = disabled;
            this._toggleTabindex();
        }
    }
    @Input() set readonly(readonly: boolean) {
        if (this._readonly !== readonly) {
            this._readonly = readonly !== false;
            this._toggleTabindex();
        }
    }
    @Input() set multiple(multiple: boolean) {
        if (this._multiple !== multiple) {
            this._multiple = multiple;
            this._onMultipleChanged$.next(multiple);
        }
    }
    @Input() set value(value: any) {
        if (this._value !== value) {
            this._value = value;
            this._setSelectedOptionsFromValue();
        }
    } get value (): any {
        return this._value;
    }
    @Output() valueChange: EventEmitter<any> = new EventEmitter<any>();
    @Output() onChange: EventEmitter<any> = new EventEmitter<any>();

    constructor(
        private _injector: Injector,
        private _changeDetectorRef: ChangeDetectorRef,
        private _renderer: Renderer2,
        private _elementRef: ElementRef,
        public _translate: TranslateService
    ) { }

    ngOnInit(): void {
        this._subscriptions.push(this._translate.stream('ODEN.COMPONENTS.ODEN_FORM.NONE').subscribe((text) => {
            this._noneLabel = text;
        }));
        this._subscriptions.push(this._setDisplayValue$.asObservable().pipe(debounceTime(1)).subscribe(() => this._setDisplayValue()));
    }

    ngAfterViewInit(): void {
        // Checks if control has required validator
        this._ngControl = this._injector.get(NgControl, null);
        if (!!this._ngControl && !!this._ngControl.control.validator) {
            const validator = this._ngControl.control.validator({} as AbstractControl);
            this._hasRequiredValidator = validator && validator.required;
            this._subscriptions.push(this._ngControl.statusChanges.subscribe(() => {
                if (!!this._errorComponentsRef && !!this._errorComponentsRef.first) {
                    this._errorComponentsRef.forEach((errorComp) => errorComp._setHasError(this._ngControl.control));
                }
            }));
            this._changeDetectorRef.detectChanges();
        }
        // Insert default option and select it if not multiselect and not required
        if (!this._multiple && !!this._viewOptionRef && !this._hasRequiredValidator) {
            this._viewOptionRef.selected = [null, undefined, ''].indexOf(this._value) > -1;
            this._setDisplayValue();
            this._changeDetectorRef.detectChanges();
        }
    }

    ngOnDestroy(): void {
        if (this._clickListner) {
            this._clickListner();
        }
        this._subscriptions.forEach((s) => s.unsubscribe());
    }

    private _onTouchedCallback: (any: any) => void = () => { };
    private _onChangeCallback: (_: any) => void = () => { };

    /**
     * Returns both view options and content options
     */
    private get _options(): OdenOptionComponent[] {
        const _contentOptions = !!this._contentOptionsRef ? this._contentOptionsRef.toArray() : [];
        return !!this._viewOptionRef ? [this._viewOptionRef].concat(_contentOptions) : _contentOptions;
    }

    private _setSelectedOptionsFromValue(): void {
        if (!this._options) {
            return;
        }
        // Set value to null if value is set to undefined or empty string. This will set default option to selected.
        if ([undefined, ''].indexOf(this._value) > -1) {
            this._value = null;
        }
        this._options.forEach((option: OdenOptionComponent) => option.selected = this._isOptionValueInSelectValue(option));
        this._setDisplayValue();
    }

    private _setDisplayValue(): void {
        if (this._options && this._options.length > 0) {
            const selectedOptions = this._options.filter((option: OdenOptionComponent) => option.selected);
            this._displayValue = selectedOptions.map((option: OdenOptionComponent) => option._label).join(', ');
        }
        this._changeDetectorRef.detectChanges();
    }

    private _updateValue(value: any, shouldEmitChange: boolean = false): void {
        this._value = value;
        if (shouldEmitChange) {
            this.onChange.emit(this._value);
            this.valueChange.emit(this._value);
            this._onChangeCallback(this._value);
        }
        this._setDisplayValue();
    }

    private _toggleTabindex(): void {
        this._tabindex = this._disabled || this._readonly ? -1 : 0;
    }

    private _clearInvisibleSearch(): any {
        return setTimeout(() => {
            this._clearInvisibleSearchTimout = undefined;
            this._invisibleSearchStr = '';
        }, 2000);
    }

    /**
     * Invisible search function similar to filtering but sets focus on best matching element. If spamming first letter the it loops all
     * options beginning with that letter
     * @param {KeyboardEvent} event KeyboardEvent that containes key that is used for search
     */
    private _invisibleSearch(event: KeyboardEvent): void {
        let shouldChange: boolean = false;
        if (this._invisibleSearchStr.length === 0 || !(this._invisibleSearchStr === event.key && this._invisibleSearchStr.length === 1)) {
            shouldChange = true;
            this._invisibleSearchStr += event.key;
        } else if (this._invisibleSearchStr === event.key && this._invisibleSearchStr.length === 1) {
            shouldChange = true;
        }

        if (!shouldChange) {
            return;
        }

        const regex = new RegExp(`^${this._invisibleSearchStr.toLowerCase()}`);
        const options: OdenOptionComponent[] = this._options.filter((option) => regex.test(option._label.toLowerCase()));
        const selectedIndex: number = options.map((option) => option._hasFocus).indexOf(true);

        if (options.length > 0) {
            if (selectedIndex === -1 || selectedIndex + 1 === options.length || this._invisibleSearchStr.length > 1) {
                options[0]._setFocus();
            } else {
                options[selectedIndex + 1]._setFocus();
            }
        }

        if (this._clearInvisibleSearchTimout) {
            clearTimeout(this._clearInvisibleSearchTimout);
        }
        this._clearInvisibleSearchTimout = this._clearInvisibleSearch();
    }

    /**
     * Prevents user from writing in input field
     * @param {KeyboardEvent} event KeyboardEvent that triggered function
     */
    public _onKeydownInput(event: KeyboardEvent): void {
        if ('Escape' === event.code) {
            this._closeMenu(event);
        } else if ('Tab' === event.code) {
            if (this.open) {
                const firstSelectedOption = this._options.find((option) => option.selected);
                if (firstSelectedOption) {
                    firstSelectedOption._setFocus();
                } else if (this._options[0]) {
                    this._options[0]._setFocus();
                }
            } else {
                this._closeMenu(event);
            }
        } else if ('Enter' === event.code) {
            this._openMenu();
            const firstSelectedOption = this._options.find((option) => option.selected);
            if (firstSelectedOption) {
                firstSelectedOption._setFocus();
            } else if (this._options[0]) {
                this._options[0]._setFocus();
            }
        } else {
            event.preventDefault();
        }
    }

    /**
     * Enables user to search, close and select with keyboard in combobox menu
     * @param {KeyboardEvent} event KeyboardEvent that triggered function
     */
    public _onKeydownList(event: KeyboardEvent): void {
        if (['Tab', 'Escape', 'ShiftLeft', 'Space', 'ArrowDown', 'ArrowUp', 'Enter'].indexOf(event.code) === -1) {
            /**
             * If value is selected through enter the loop can still continue,
             * if enter would be passed that would be inserted into _invisibleSearchStr
             */
            if (event.code !== 'Enter') {
                this._invisibleSearch(event);
            }
            event.preventDefault();
        }
        if ('Escape' === event.code) {
            this._closeMenu(event);
        }
        if ('Enter' === event.code) {
            for (const option of this._options) {
                if (option._hasFocus) {
                    option._toggleSelected();
                    break;
                }
            }
        }
    }

    public _queSetDisplayValue(): void {
        this._setDisplayValue$.next();
    }

    public _toggleMenu(event?: Event): void {
        this.open ? this._closeMenu(event) : this._openMenu();
    }

    public _openMenu(): void  {
        if (this.open) {
            return;
        }
        this._options.forEach((option) => option._toggleTabindex());
        this._renderer.removeClass(this._menuRef.nativeElement, 'hidden');
        this._clickListner = this._renderer.listen('document', 'click', (event: Event) => {
            if ((!this._elementRef.nativeElement.contains(event.target) || this._elementRef.nativeElement === event.target) && this.open) {
                this._closeMenu(event, false);
            }
        });
        this._menuRef.nativeElement.focus();
        this.open = true;
    }

    /**
     * Closes the combobox menu
     * @param {Event} event Optional, event that triggered function to be called. Will be emitted through callback
     * @param {boolean} setFocus True if close should set focus on related input element
     */
    public _closeMenu(event?: Event, setFocus: boolean = true): void {
        if (!this.open) {
            return;
        }
        this._options.forEach((option) => option._toggleTabindex(true));
        this.open = false;
        this._onTouchedCallback(event);
        this._changeDetectorRef.detectChanges();
        if (setFocus) {
            this._inputRef.nativeElement.focus();
        }
        if (this._ngControl) {
            this._ngControl.control.updateValueAndValidity();
        }
        if (this._clickListner) {
            this._clickListner();
        }
    }

    /**
     * Evaluates what value should be passed further
     * @param {OdenOptionComponent} changedOption Option that triggered function
     * @param {boolean} shouldEmitChange True if change should trigger emit
     */
    public _optionChanged(changedOption: OdenOptionComponent, shouldEmitChange: boolean = true): void {
        let value;
        if (this._multiple) {
            if (!Array.isArray(this.value)) {
                this._value = [];
            }
            value = this._options
                .filter((option: OdenOptionComponent) => option.selected)
                .map((option: OdenOptionComponent) => option.value);
        } else {
            this._closeMenu();
            if (changedOption.selected) {
                value = changedOption.value;
                this._options.forEach((option: OdenOptionComponent) => {
                    if (option.selected && option !== changedOption) {
                        option.selected = false;
                    }
                });
            }
        }
        this._updateValue(value, shouldEmitChange);
    }

    /**
     * Evaluates if passed option exists within value
     * @param {OdenOptionComponent} option Option to be evaluted if exists in value
     */
    public _isOptionValueInSelectValue(option: OdenOptionComponent): boolean {
        if (typeof (this._value) === 'undefined' || typeof (option.value) === 'undefined') {
            return false;
        }
        if (this._multiple) {
            return Array.isArray(this._value) && this._value.indexOf(option.value) > -1;
        } else if (this._value === null && !this._multiple && this._hasRequiredValidator) {
            return false;
        } else {
            return this._value === option.value;
        }
    }

    /**
     * ControlValueAccessor implentations
     * This function is only to be called via NG_VALUE_ACCESSOR
     */
    writeValue(value: any): void {
        this._value = value;
        this._setSelectedOptionsFromValue();
    }

    /**
     * ControlValueAccessor implentations
     * This function is only to be called via NG_VALUE_ACCESSOR
     */
    registerOnChange(fn: any): void {
        this._onChangeCallback = fn;
    }

    /**
     * ControlValueAccessor implentations
     * This function is only to be called via NG_VALUE_ACCESSOR
     */
    registerOnTouched(fn: any): void {
        this._onTouchedCallback = fn;
    }

    /**
     * ControlValueAccessor implentations
     * This function is only to be called via NG_VALUE_ACCESSOR
     */
    setDisabledState(isDisabled: boolean): void {
        this.disabled = isDisabled;
    }
}
