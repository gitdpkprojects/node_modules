import {
    Component, OnDestroy, HostBinding, ContentChildren, ChangeDetectorRef,
    QueryList, SkipSelf, Host, Optional, ViewEncapsulation, AfterViewInit, ContentChild, Input
} from '@angular/core';
import { Subscription } from 'rxjs';
import { OdenFormService, FocusType, FOCUS_SOURCE, INPUT_TYPE } from '../../../core/services/oden-form.service';
import { OdenSwitchDirective } from '../oden-switch/oden-switch.directive';
import { OdenLabelDirective } from '../oden-label/oden-label.directive';

export type ODEN_FORM_FIELD_JUSTIFY_CONTENT = 'flex-start' | 'flex-end' | 'center' | 'space-between' | 'space-around';

@Component({
    selector: 'oden-form-field',
    templateUrl: 'oden-form-field.component.html',
    encapsulation: ViewEncapsulation.None,
    providers: [OdenFormService],
    styleUrls: ['./oden-form-field.component.scss']
})
export class OdenFormFieldComponent implements AfterViewInit, OnDestroy {
    private _subscriptions: Subscription[] = [];
    @HostBinding('class.oden-form-field') _hasOdenFormFieldClass: boolean = true;
    @HostBinding('class.label-on-both-sides') _hasLabelOnBothSides: boolean = false;
    @HostBinding('class.remove-padding-bottom') _hasRemovePaddingBottom: boolean = false;
    @HostBinding('style.justify-content') @Input() justifyContent: ODEN_FORM_FIELD_JUSTIFY_CONTENT;
    @ContentChild(OdenSwitchDirective) _odenSwitchDirective: OdenSwitchDirective;
    @ContentChildren(OdenLabelDirective) _labelsQueryList: QueryList<OdenLabelDirective>;
    public _inputValue: string | boolean;
    public _maxLength: number = -1;
    public _on: string;
    public _off: string;

    constructor(
        private _changeDetectorRef: ChangeDetectorRef,
        private _formService: OdenFormService,
        @SkipSelf() @Host() @Optional() public _parent: OdenFormFieldComponent
    ) { }

    ngAfterViewInit(): void {
        // If component is child of another oden-form-field then setup parent/child relations
        if (this._parent) {
            this._parent._formService._isParent.next(true);
            this._formService._isChild.next(true);
            // Retrive focus signal from parent
            this._subscriptions.push(this._parent._formService._onFocus.subscribe((focus: FocusType) => {
                if (focus[0] === FOCUS_SOURCE.PARENT) {
                    this._formService.setFocus(focus[0]);
                }
            }));
        }

        // If switch the setup listener to on/off texts
        if (this._odenSwitchDirective) {
            this._subscriptions.push(this._formService._switchOnText.subscribe((text: string) => {
                this._on = text;
            }));
            this._subscriptions.push(this._formService._switchOffText.subscribe((text: string) => {
                this._off = text;
            }));
        }
        // This is removing the padding bottom for checkboxes and radio buttons
        this._subscriptions.push(this._formService._inputType.subscribe((type: INPUT_TYPE) => {
            this._hasRemovePaddingBottom = [INPUT_TYPE.CHECKBOX, INPUT_TYPE.RADIO_BUTTON].indexOf(type) > -1;
        }));
        this._subscriptions.push(this._formService._maxLength.subscribe((maxLength) => {
            this._maxLength = maxLength;
        }));
        this._subscriptions.push(this._formService._inputValue.subscribe((inputValue: string | boolean) => {
            // If value becomes longer then call focus to the parent (checkbox/radio will be selected)
            if (this._parent && typeof this._inputValue === 'string' && typeof inputValue === 'string'
                && this._inputValue.length < inputValue.length) {
                this._parent._formService.setFocus(FOCUS_SOURCE.CHILD);
            }
            this._inputValue = inputValue;
        }));
        this._changeDetectorRef.detectChanges();
        this._setHasLabelOnBothSides();
    }

    ngOnDestroy(): void {
        this._subscriptions.forEach((subscription) => subscription.unsubscribe());
    }

    private _setHasLabelOnBothSides() {
        const labels = this._labelsQueryList.toArray();
        const hasLabelOnLeftSide: boolean = !!labels.find((label) => label.labelPosition === 'left');
        const hasLabelOnRightSide: boolean = !!labels.find((label) => label.labelPosition === 'right');
        this._hasLabelOnBothSides = hasLabelOnLeftSide && hasLabelOnRightSide;
    }
}
