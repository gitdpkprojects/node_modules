import { Ref, RelationGraphNode } from '../relation-graph.model';
import { RelationGraphComponentRoot } from './root';
import { RelationGraphComponentType } from './type';
import { RelationGraphComponentRelation } from './relation';
import { RelationGraphComponentPosition } from './position';
import { RelationGraphComponentDimensions } from './dimensions';
import { D3Group, D3Text } from './types';
import { RelationGraphComponentState } from './state';
import { RelationGraphComponentConstants as Constants } from './constants';
import * as D3 from 'd3';
import { RelationGraphComponentUtil } from './util';
import { RelationGraphComponentTraversable } from './traversable';
import { RelationGraphComponentTag } from './tag';
import * as _ from 'lodash';
import { RelationGraphComponentDownstreamDepthControl, RelationGraphComponentUpstreamDepthControl } from './depth-control';

export class RelationGraphComponentVerdict {
    hide: boolean = false;
    fade: boolean = false;
    highlight: boolean = false;

    reset(): void {
        this.hide = false;
        this.fade = false;
        this.highlight = false;
    }
}

export abstract class RelationGraphComponentNode extends RelationGraphComponentState {
    readonly verdict: RelationGraphComponentVerdict = new RelationGraphComponentVerdict();
    readonly position: RelationGraphComponentPosition = { x: 0, y: 0 };
    readonly scaledPosition: RelationGraphComponentPosition = { x: 0, y: 0 };
    relationsFrom: Array<RelationGraphComponentRelation> = [];
    relationsTo: Array<RelationGraphComponentRelation> = [];

    depth: number = null;
    dirty: boolean = true;
    reposition: boolean = true;

    protected _type: RelationGraphComponentType = null;
    protected _relationSourcePosition: RelationGraphComponentPosition = { x: 0, y: 0 };
    protected _relationTargetPosition: RelationGraphComponentPosition = { x: 0, y: 0 };
    protected _tag: RelationGraphComponentTag;
    protected _parents: Array<RelationGraphComponentNode> = null;
    protected _children: Array<RelationGraphComponentNode> = null;
    protected _g: D3Group;
    protected _linkAway: D3Group;
    protected _maxDepth: number = null;
    protected _transform: string = 'translate(0, 0)';
    protected _focused: boolean = false;

    constructor(
        public readonly ref: Ref,
        protected _root: RelationGraphComponentRoot,
        public readonly node: RelationGraphNode,
        public readonly dimensions: RelationGraphComponentDimensions,
        baseClass: string = 'node') {
        super(baseClass);
    }

    get name(): string {
        return this.node.name;
    }

    get type(): RelationGraphComponentType {
        if (this._type === null) {
            this._type = this._root.findType(this.node.typeRef);
        }
        return this._type;
    }

    get isLinkAway(): boolean {
        return !!this.node.linkAway;
    }

    get relationSourcePosition(): RelationGraphComponentPosition {
        this._relationSourcePosition.x = this.scaledPosition.x + this.dimensions.width * 0.5;
        this._relationSourcePosition.y = this.scaledPosition.y;
        return this._relationSourcePosition;
    }

    get relationTargetPosition(): RelationGraphComponentPosition {
        this._relationTargetPosition.x = this.scaledPosition.x - this.dimensions.width * 0.5;
        this._relationTargetPosition.y = this.scaledPosition.y;
        return this._relationTargetPosition;
    }

    get tag(): RelationGraphComponentTag {
        return this._tag;
    }

    get parents(): RelationGraphComponentTraversable<RelationGraphComponentNode> {
        return new RelationGraphComponentTraversable<RelationGraphComponentNode>(this, n => n.resolveParents(), n => n.isRoot);
    }

    get children(): RelationGraphComponentTraversable<RelationGraphComponentNode> {
        return new RelationGraphComponentTraversable<RelationGraphComponentNode>(this, n => n.resolveChildren(), n => n.isLeaf);
    }

    abstract get isLeaf(): boolean;

    abstract get isRoot(): boolean;

    abstract get isDownstream(): boolean;

    abstract get isUpstream(): boolean;

    abstract distribute(minDepth: number): void;

    abstract get direction(): number;

    get maxDepth(): number {
        if (this._maxDepth === null) {
            this._maxDepth = this._root.maxDepth;
        }
        return this._maxDepth;
    }

    appendTo(parent: D3Group): void {
        this._g = <D3Group>parent.append('g');
        this._g.attr('data-id', `${this.type.name}#${this.node.id}`);
        this._g.attr('class', this.class);
        this._g.attr('opacity', this.visible ? 1 : 0);

        if (this.isRoot) {
            this._tag = new RelationGraphComponentTag(Constants.ROOT_NODE.TAG.ALIGN, Constants.ROOT_NODE.TAG.DX);
            this._tag.appendTo(this._g);
        } else {
            this._g.append('use')
                .attr('xlink:href', this.isLeaf ? (this.isDownstream ? '#dl' : '#ul') : '#n');

            this._g.append('text')
                .attr('class', 'acronym')
                .attr('dy', '.35em')
                .text(this.text);

            this._g.append('foreignObject')
                .attr('x', 0)
                .attr('y', -8)
                .attr('width', 0)
                .attr('height', 18)
                .append('xhtml:div')
                .attr('class', this.isDownstream ? (this.isLeaf ? 'name align-left' : 'name') : (this.isLeaf ? 'name' : 'name align-left'))
                .append('span')
                .html(_.escape(this.name));

            if (this.isLinkAway) {
                this.appendLinkAway();
            }

            this._tag = new RelationGraphComponentTag();
            this._tag.appendTo(this._g);

            this._g.on('mouseover', this.mouseoverEventHandler.bind(this));
            this._g.on('mouseout', this.mouseoutEventHandler.bind(this));
            this._g.on('mousedown', this.ignoredEventHandler.bind(this));
            this._g.on('mouseup', this.ignoredEventHandler.bind(this));
            this._g.on('click', this.clickEventHandler.bind(this));
            this._g.on('dblclick', this.ignoredEventHandler.bind(this));
        }
    }

    raise(): void {
        this._g.raise();
    }

    update(): void {
        this.updateName();
        const css = this.class;
        if (this._g.attr('class') !== css) {
            this._g.attr('class', css);
        }
        this._g.attr('opacity', this.visible ? 1 : 0);
        if (this.dirty) {
            this._g.attr('transform', this._transform);
            this.dirty = false;
        }
        if (this._tag) {
            this._tag.update();
        }
    }

    animate(): void {
        this.updateName();
        const transition = this._g.transition().duration(Constants.TRANSITION.DURATION);
        const css = this.class;
        if (this._g.attr('class') !== css) {
            transition.attr('class', css);
        }
        transition.attr('opacity', this.visible ? 1 : 0);
        if (this.dirty) {
            transition.attr('transform', this._transform);
            this.dirty = false;
        }
        if (this._tag) {
            this._tag.animate();
        }
    }

    scalePosition(): void {
        const direction = this.direction;
        const grid = this._root.grid;
        const dx = direction * (Constants.ROOT_NODE.WIDTH + Constants.ROOT_NODE.PADDING) * 0.5;
        const x = Math.round(dx + this.position.x * direction * grid.width * grid.scale);
        const y = Math.round(this.position.y * grid.height * grid.scale);
        if (Math.abs(x - this.scaledPosition.x) > 0.5 || Math.abs(y - this.scaledPosition.y) > 0.5) {
            this.scaledPosition.x = x;
            this.scaledPosition.y = y;
            this._transform = `translate(${x}, ${y})`;
            this.dirty = true;
        }
    }

    cleanup(): void {
        this._type = null;
        this.relationsFrom = null;
        this.relationsTo = null;
        if (this._tag) {
            this._tag.cleanup();
            this._tag = null;
        }
        this._parents = null;
        this._children = null;
        if (this._linkAway) {
            this._linkAway.on('click', null);
            this._linkAway.on('mousedown', null);
            this._linkAway.on('dblclick', null);
            this._linkAway = null;
        }
        this._g.on('mouseover', null);
        this._g.on('mouseout', null);
        this._g.on('mousedown', null);
        this._g.on('mouseup', null);
        this._g.on('click', null);
        this._g.on('dblclick', null);
        this._g = null;
        this._root = null;
    }

    computeMaxDepth(): number {
        const childAtMaxDepth = this.children.reduce((match, child) => {
            if (match) {
                return !child.hidden && child.depth > match.depth ? child : match;
            } else {
                return !child.hidden ? child : null;
            }
        }, null);
        return childAtMaxDepth ? childAtMaxDepth.depth : 0;
    }

    protected abstract get text(): string;

    protected abstract resolveParents(): Array<RelationGraphComponentNode>;

    protected abstract resolveChildren(): Array<RelationGraphComponentNode>;

    protected mouseoverEventHandler(): void {
        D3.event.stopPropagation();
        D3.event.preventDefault();
        this.onFocus();
    }

    protected mouseoutEventHandler(): void {
        D3.event.stopPropagation();
        D3.event.preventDefault();
        this.onBlur();
    }

    protected clickEventHandler(): void {
        D3.event.stopPropagation();
        D3.event.preventDefault();
        this.onClick();
    }

    protected ignoredEventHandler(): void {
        D3.event.stopPropagation();
        D3.event.preventDefault();
    }

    protected onFocus(): void {
        if (!this._focused) {
            this._focused = true;
            this._root.onFocus(this);
        }
    }

    protected onBlur(): void {
        this._focused = false;
        this._root.onBlur();
    }

    protected onClick(): void {
        this._root.onClick(this);
    }

    private appendLinkAway(): void {
        const r = Constants.NODE.LINK_AWAY.RADIUS;
        const a = Constants.NODE.LINK_AWAY.ARROW;
        const dx = Constants.NODE.LINK_AWAY.DX;
        const dy = Constants.NODE.LINK_AWAY.DY;

        this._linkAway = <D3Group>this._g.append('g')
            .attr('class', 'link-away')
            .attr('transform', `translate(${this.dimensions.width * 0.5 + dx}, ${-this.dimensions.height * 0.5 + dy})`);

        this._linkAway.append('circle')
            .attr('cx', 0)
            .attr('cy', 0)
            .attr('r', r);

        this._linkAway.append('line')
            .attr('x1', -a).attr('y1', a)
            .attr('x2', a).attr('y2', -a);

        this._linkAway.append('line')
            .attr('x1', -a + 1).attr('y1', -a)
            .attr('x2', a).attr('y2', -a);

        this._linkAway.append('line')
            .attr('x1', a).attr('y1', -a)
            .attr('x2', a).attr('y2', a - 1);

        this._linkAway.on('click', this.clickEventHandler.bind(this));
        this._linkAway.on('mousedown', this.ignoredEventHandler.bind(this));
        this._linkAway.on('dblclick', this.ignoredEventHandler.bind(this));
    }

    private updateName(): void {
        if (!this.isRoot) {
            const { width } = this.dimensions;
            const grid = this._root.grid;
            const maxWidth = this.depth === 1 && this.depth !== this.maxDepth && !this.isLeaf ?
                (Constants.ROOT_NODE.WIDTH + Constants.ROOT_NODE.PADDING) * grid.scale - width * 0.5 :
                grid.width * (this.depth === this.maxDepth ? 4 : grid.scale) - width - Constants.NODE.NAME.MARGIN * 2;
            const dx = this.isLeaf ? (width * 0.5 + Constants.NODE.NAME.MARGIN) * this.direction :
                (-width * 0.5 - Constants.NODE.NAME.MARGIN) * this.direction;
            this._g.select('foreignObject')
                .attr('x', dx + (this.isDownstream ? (this.isLeaf ? 0 : -maxWidth) : (this.isLeaf ? -maxWidth : 0)))
                .attr('width', maxWidth)
                .select('span')
                .attr('style', `max-width: ${maxWidth - Constants.NODE.NAME.MARGIN * 2}px;`);
        }
    }
}

export class RelationGraphComponentDownstreamNode extends RelationGraphComponentNode {
    constructor(
        ref: Ref,
        root: RelationGraphComponentRoot,
        node: RelationGraphNode,
        dimensions: RelationGraphComponentDimensions = { width: Constants.NODE.WIDTH, height: Constants.NODE.HEIGHT }) {
        super(ref, root, node, dimensions);
    }

    get isLeaf(): boolean { return !this.relationsFrom.length; }

    get isRoot(): boolean { return !this.relationsTo.length; }

    get isDownstream(): boolean { return true; }

    get isUpstream(): boolean { return false; }

    get direction(): number { return 1; }

    distribute(minDepth: number): void {
        if (this.depth === null || this.depth < minDepth) {
            this.depth = minDepth;
            this.relationsFrom.forEach(relation => relation.target.distribute(this.depth + 1));
        }
    }

    protected get text(): string { return this._type.acronym; }

    protected resolveParents(): Array<RelationGraphComponentNode> {
        if (this._parents === null) {
            this._parents = this.relationsTo.map(rel => rel.source);
        }
        return this._parents;
    }

    protected resolveChildren(): Array<RelationGraphComponentNode> {
        if (this._children === null) {
            this._children = this.relationsFrom.map(rel => rel.target);
        }
        return this._children;
    }
}

export class RelationGraphComponentUpstreamNode extends RelationGraphComponentNode {
    constructor(
        ref: Ref,
        root: RelationGraphComponentRoot,
        node: RelationGraphNode,
        dimensions: RelationGraphComponentDimensions = { width: Constants.NODE.WIDTH, height: Constants.NODE.HEIGHT }) {
        super(ref, root, node, dimensions);
    }

    get isLeaf(): boolean { return !this.relationsTo.length; }

    get isRoot(): boolean { return !this.relationsFrom.length; }

    get isDownstream(): boolean { return false; }

    get isUpstream(): boolean { return true; }

    get direction(): number { return -1; }

    distribute(minDepth: number): void {
        this.depth = Math.max(this.depth, minDepth);
        this.relationsTo.forEach(relation => relation.source.distribute(this.depth + 1));
    }

    protected get text(): string {
        return this._type.acronym;
    }

    protected resolveParents(): Array<RelationGraphComponentNode> {
        if (this._parents === null) {
            this._parents = this.relationsFrom.map(rel => rel.target);
        }
        return this._parents;
    }

    protected resolveChildren(): Array<RelationGraphComponentNode> {
        if (this._children === null) {
            this._children = this.relationsTo.map(rel => rel.source);
        }
        return this._children;
    }
}

export class RelationGraphComponentRootNode extends RelationGraphComponentNode {
    private static EMPTY_NODES: Array<RelationGraphComponentNode> = [];
    private _upstreamDepthControl: RelationGraphComponentUpstreamDepthControl;
    private _downstreamDepthControl: RelationGraphComponentDownstreamDepthControl;

    constructor(ref: Ref, root: RelationGraphComponentRoot, node: RelationGraphNode) {
        super(ref, root, node, { width: 0, height: 0 }, 'root');
        this._upstreamDepthControl = new RelationGraphComponentUpstreamDepthControl(this._root, 0);
        this._downstreamDepthControl = new RelationGraphComponentDownstreamDepthControl(this._root, 0);
    }

    appendTo(parent: D3Group): void {
        this._g = <D3Group>parent.append('g')
            .attr('class', this.class);

        const width = Constants.ROOT_NODE.WIDTH + Constants.ROOT_NODE.PADDING;
        const height = Constants.ROOT_NODE.HEIGHT;

        const path =
            `M ${height * 0.5},0 ` +
            `L ${width - 12},0 ` +
            `A ${height * 0.5},${height * 0.5} 0,0,1 ${width - 12},${height} ` +
            `L ${height * 0.5},${height} A ${height * 0.5},${height * 0.5} 0,0,1 ${height * 0.5},0`;

        this._g.append('path')
            .attr('d', path)
            .attr('transform', `translate(${-width * 0.5}, ${-height * 0.5})`);

        const text = `${this.type.acronym} ${this.name}`;

        const name = <D3Text>this._g.append('text')
            .attr('class', 'name')
            .attr('dy', '.35em')
            .text(text);

        RelationGraphComponentUtil.trim(name, width - Constants.ROOT_NODE.PADDING * 2);

        this._g.on('mouseover', this.mouseoverEventHandler.bind(this));
        this._g.on('mouseout', this.mouseoutEventHandler.bind(this));
        this._g.on('mousedown', this.ignoredEventHandler.bind(this));
        this._g.on('mouseup', this.ignoredEventHandler.bind(this));
        this._g.on('click', this.clickEventHandler.bind(this));
        this._g.on('dblclick', this.ignoredEventHandler.bind(this));

        this._upstreamDepthControl.appendTo(this._g);
        this._upstreamDepthControl.position.x = -Constants.ROOT_NODE.WIDTH * 0.5;
        this._upstreamDepthControl.update();

        this._downstreamDepthControl.appendTo(this._g);
        this._downstreamDepthControl.position.x = Constants.ROOT_NODE.WIDTH * 0.5;
        this._downstreamDepthControl.update();
    }

    get isLeaf(): boolean { return false; }

    get isRoot(): boolean { return true; }

    get isDownstream(): boolean { return false; }

    get isUpstream(): boolean { return false; }

    get direction(): number { return 0; }

    get maxDepth(): number { return 0; }

    get upstreamDepthControl(): RelationGraphComponentUpstreamDepthControl { return this._upstreamDepthControl; }

    get downstreamDepthControl(): RelationGraphComponentDownstreamDepthControl { return this._downstreamDepthControl; }

    distribute(_minDepth: number): void { }

    protected get path(): string { return null; }

    protected get text(): string { return null; }

    protected resolveParents(): Array<RelationGraphComponentNode> {
        return RelationGraphComponentRootNode.EMPTY_NODES;
    }

    protected resolveChildren(): Array<RelationGraphComponentNode> {
        return RelationGraphComponentRootNode.EMPTY_NODES;
    }
}

export class RelationGraphComponentDownstreamRootNode extends RelationGraphComponentDownstreamNode {
    constructor(ref: Ref, root: RelationGraphComponentRoot, node: RelationGraphNode) {
        super(ref, root, node, { width: 0, height: 0 });
    }
}

export class RelationGraphComponentUpstreamRootNode extends RelationGraphComponentUpstreamNode {
    constructor(ref: Ref, root: RelationGraphComponentRoot, node: RelationGraphNode) {
        super(ref, root, node, { width: 0, height: 0 });
    }
}
