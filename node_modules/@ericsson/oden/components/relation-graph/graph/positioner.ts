import { RelationGraphComponentNode } from './node';
import { RelationGraphComponentType } from './type';

export abstract class RelationGraphComponentPositioner {
    constructor(protected _nodes: Array<RelationGraphComponentNode>, protected _maxDepth: number) { }

    abstract reposition(): void;

    cleanup(): void {
        this._nodes = null;
    }
}

export class DefaultRelationGraphComponentPositioner extends RelationGraphComponentPositioner {
    private _nodesAtDepth: Array<Array<RelationGraphComponentNode>> = [];

    constructor(nodes: Array<RelationGraphComponentNode>, maxDepth: number) {
        super(nodes, maxDepth);
        for (let depth = 0; depth <= this._maxDepth; ++depth) {
            this._nodesAtDepth.push(nodes.filter(node => node.depth === depth));
        }
    }

    reposition(): void {
        this._nodes.forEach(node => {
            node.position.y = 0;
            node.position.x = node.depth;
        });
        let leafs: Array<RelationGraphComponentNode> = [];
        for (let depth = 1; depth <= this._maxDepth; ++depth) {
            const nodesAtDepth = this.nodesAtDepth(depth);
            this.positionNodes(nodesAtDepth, leafs);

            leafs = nodesAtDepth.filter(node => {
                return node.isLeaf;
            });
        }
        this.repositionInvisibleNodes();
    }

    cleanup(): void {
        super.cleanup();
        this._nodesAtDepth = null;
    }

    private positionNodes(nodes: Array<RelationGraphComponentNode>, leafs: Array<RelationGraphComponentNode>): void {
        let currentPosition = 0;
        const groups: Map<RelationGraphComponentType, Array<RelationGraphComponentNode>> = new Map();
        nodes.forEach(node => {
            if (!groups.get(node.type)) {
                groups.set(node.type, []);
            }
            groups.get(node.type).push(node);
        });

        const sortedGroups = this.sortGroups(Array.from(groups.values()));

        sortedGroups.forEach(g => {
            this.sortNodes(g);
        });

        // Calculate column size without leaf displacement
        let totalHeight: number = sortedGroups.length - 1;
        sortedGroups.forEach(groupNodes => {
            totalHeight += groupNodes.length;
        });

        currentPosition = this.calculateHeightWithLeaves(totalHeight, sortedGroups, leafs);
        sortedGroups.forEach(groupNodes => {
            let leafIndex = 0;
            let nodeIndex = 0;
            while (groupNodes[nodeIndex]) {
                while (leafs[leafIndex] && !groupNodes[nodeIndex].isLeaf) {
                    if (leafs[leafIndex].position.y === currentPosition - nodeIndex) {
                        currentPosition--;
                        nodeIndex = -1;
                        break;
                    }
                    leafIndex++;
                }
                leafIndex = 0;
                nodeIndex++;
            }

            groupNodes.forEach(groupNode => {
                groupNode.position.y = currentPosition;
                currentPosition--;
            });
            currentPosition--;
        });
    }

    private sortGroups(groups: Array<Array<RelationGraphComponentNode>>): Array<Array<RelationGraphComponentNode>> {
        return groups.sort((g1, g2) => {
            const group1AvgPos = this.calculateAverageParentHeightForGroup(g1);
            const group2AvgPos = this.calculateAverageParentHeightForGroup(g2);

            if (group1AvgPos > group2AvgPos) {
                return -1;
            } else if (group1AvgPos === group2AvgPos) {
                return 0;
            } else {
                return 1;
            }
        });
    }

    private sortNodes(g: Array<RelationGraphComponentNode>): Array<RelationGraphComponentNode> {
        return g.sort((n1, n2) => {
            const node1AvgPos = this.calculateAverageParentHeightForNode(n1);
            const node2AvgPos = this.calculateAverageParentHeightForNode(n2);

            if (node1AvgPos > node2AvgPos) {
                return -1;
            } else if (node1AvgPos === node2AvgPos) {
                return 0;
            } else {
                return 1;
            }
        });
    }

    private calculateHeightWithLeaves(originalHeight: number,
        groups: Array<Array<RelationGraphComponentNode>>, leafs: Array<RelationGraphComponentNode>): number {
        // Calculate starting position
        const tempStartPosition = Math.floor(originalHeight * 0.5);
        let tempCurrentPosition = tempStartPosition;

        groups.forEach(groupNodes => {
            let leafIndex = 0;
            let nodeIndex = 0;
            let displaced = false;
            while (groupNodes[nodeIndex]) {
                while (leafs[leafIndex] && !groupNodes[nodeIndex].isLeaf) {
                    if (leafs[leafIndex].position.y === tempCurrentPosition - nodeIndex) {
                        tempCurrentPosition -= (nodeIndex + 1);
                        nodeIndex = -1;
                        displaced = true;
                        break;
                    }
                    leafIndex++;
                }
                leafIndex = 0;
                nodeIndex++;
            }

            tempCurrentPosition -= groupNodes.length;
            // If the group has been displaced already, don't offset it anymore
            if (!displaced) {
                tempCurrentPosition--;
            }
        });
        tempCurrentPosition++;
        return Math.floor((tempStartPosition - tempCurrentPosition) * 0.5);
    }

    private calculateAverageParentHeightForGroup(g: Array<RelationGraphComponentNode>): number {
        let groupParents = 0;
        let groupTotal = 0;
        g.forEach(n => {
            n.parents.first.forEach(p => {
                groupTotal += p.position.y;
                groupParents++;
            });
        });
        return groupTotal / groupParents;
    }

    private calculateAverageParentHeightForNode(node: RelationGraphComponentNode): number {
        let groupParents = 0;
        let groupTotal = 0;
        node.parents.first.forEach(p => {
            groupTotal += p.position.y;
            groupParents++;
        });
        return groupTotal / groupParents;
    }

    private repositionInvisibleNodes(): void {
        this._nodes.forEach(node => {
            if (!node.visible) {
                const parent = node.parents.reduce((m, p) => {
                    if (m) {
                        return p.visible && p.depth > m.depth ? p : m;
                    } else {
                        return p.visible ? p : null;
                    }
                }, null);
                node.position.x = parent ? parent.position.x : 0;
                node.position.y = parent ? parent.position.y : 0;
            }
        });
    }

    private nodesAtDepth(depth: number): Array<RelationGraphComponentNode> {
        return this._nodesAtDepth[depth].filter(node => !node.hidden);
    }
}
