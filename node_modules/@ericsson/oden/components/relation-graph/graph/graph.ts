import { Ref, RelationGraph, RelationGraphRelation, RelationGraphPredicate } from '../relation-graph.model';
import { RelationGraphComponentType } from './type';
import { RelationGraphComponentRoot } from './root';
import {
    RelationGraphComponentNode,
    RelationGraphComponentUpstreamRootNode,
    RelationGraphComponentDownstreamRootNode,
    RelationGraphComponentUpstreamNode,
    RelationGraphComponentDownstreamNode,
    RelationGraphComponentRootNode
} from './node';
import { RelationGraphComponentRelation } from './relation';
import { ElementRef } from '@angular/core';
import * as D3 from 'd3';
import { D3Element, D3Group, D3Zoom, D3Defs } from './types';
import { RelationGraphComponentConstants as Constants } from './constants';
import { RelationGraphComponentGrid } from './grid';
import { Subject, Observable, Subscription } from 'rxjs';
import { RelationGraphComponentPosition } from './position';
import { RelationGraphComponentDepthController } from './depth-controller';
import { RelationGraphComponentValidator } from './validator';
import { RelationGraphComponentPositioner, DefaultRelationGraphComponentPositioner } from './positioner';

export class RelationGraphComponentGraph {
    private _rootNode: RelationGraphComponentRootNode;
    private _upstreamRoot: RelationGraphComponentRoot;
    private _downstreamRoot: RelationGraphComponentRoot;
    private _downstreamRootNode: RelationGraphComponentDownstreamRootNode = null;
    private _upstreamRootNode: RelationGraphComponentUpstreamRootNode = null;
    private _types: Array<RelationGraphComponentType>;
    private _downstreamNodes: Array<RelationGraphComponentDownstreamNode> = [];
    private _downstreamNodeMap: Array<RelationGraphComponentDownstreamNode> = [];
    private _upstreamNodes: Array<RelationGraphComponentUpstreamNode> = [];
    private _upstreamNodeMap: Array<RelationGraphComponentUpstreamNode> = [];
    private _downstreamRelations: Array<RelationGraphComponentRelation> = [];
    private _upstreamRelations: Array<RelationGraphComponentRelation> = [];
    private _downstreamPositioner: RelationGraphComponentPositioner = null;
    private _upstreamPositioner: RelationGraphComponentPositioner = null;
    private _nodes: Array<RelationGraphComponentNode> = [];
    private _relations: Array<RelationGraphComponentRelation> = [];
    private _svg: D3Element;
    private _g: D3Group;
    private _zoom: D3Zoom;
    private _grid: RelationGraphComponentGrid = { scale: 1, width: Constants.GRID.SIZE.WIDTH, height: Constants.GRID.SIZE.HEIGHT };
    private _depthController: RelationGraphComponentDepthController;
    private _focusDelay = Constants.FOCUS.DELAY;
    private _focusTimeout = null;
    private _onPreFocusSubject: Subject<RelationGraphComponentNode> = new Subject();
    private _onPreFocusObservable = this._onPreFocusSubject.asObservable();
    private _onFocusSubject: Subject<RelationGraphComponentNode> = new Subject();
    private _onFocusObservable = this._onFocusSubject.asObservable();
    private _onBlurSubject: Subject<void> = new Subject();
    private _onBlurObservable = this._onBlurSubject.asObservable();
    private _onSelectSubject: Subject<RelationGraphComponentNode> = new Subject();
    private _onSelectObservable = this._onSelectSubject.asObservable();
    private _onScaleSubject: Subject<number> = new Subject();
    private _onScaleObservable = this._onScaleSubject.asObservable();
    private _translate: RelationGraphComponentPosition = { x: 0, y: 0 };
    private _focused: RelationGraphComponentNode = null;
    private _selected: RelationGraphComponentNode = null;
    private _filter: RelationGraphPredicate = null;
    private _find: RelationGraphPredicate = null;
    private _filterDelay = Constants.FILTER.DELAY;
    private _filterTimeout = null;
    private _downstreamMaxDepth: number = 0;
    private _upstreamMaxDepth: number = 0;
    private _subscriptions: Array<Subscription> = [];
    private _raiseTimeout = null;

    static create(graph: RelationGraph): RelationGraphComponentGraph {
        const validator = new RelationGraphComponentValidator();
        validator.validate(graph);
        return new RelationGraphComponentGraph(graph);
    }

    private constructor(private _graph: RelationGraph) {
        this.createDownstreamRoot();
        this.createUpstreamRoot();
        this.createTypes();
        this.createRootNode();
        this.createDownstreamRootNode();
        this.createDownstreamNodesAndRelations();
        this.createUpstreamRootNode();
        this.createUpstreamNodesAndRelations();
        this.distributeDownstreamNodes();
        this.distributeUpstreamNodes();
        this.createDepthController();
        this.createDownstreamPositioner();
        this.createUpstreamPositioner();
        this._nodes = [].concat(this._downstreamNodes).concat(this._upstreamNodes);
        this._relations = [].concat(this._downstreamRelations).concat(this._upstreamRelations);
    }

    get upstreamRootNode(): RelationGraphComponentNode {
        return this._upstreamRootNode;
    }

    get downstreamRootNode(): RelationGraphComponentNode {
        return this._downstreamRootNode;
    }

    get upstreamNodes(): Array<RelationGraphComponentNode> {
        return this._upstreamNodes;
    }

    get downstreamNodes(): Array<RelationGraphComponentNode> {
        return this._downstreamNodes;
    }

    get upstreamRelations(): Array<RelationGraphComponentRelation> {
        return this._upstreamRelations;
    }

    get downstreamRelations(): Array<RelationGraphComponentRelation> {
        return this._downstreamRelations;
    }

    get onPreFocus(): Observable<RelationGraphComponentNode> {
        return this._onPreFocusObservable;
    }

    get onFocus(): Observable<RelationGraphComponentNode> {
        return this._onFocusObservable;
    }

    get onBlur(): Observable<void> {
        return this._onBlurObservable;
    }

    get onSelect(): Observable<RelationGraphComponentNode> {
        return this._onSelectObservable;
    }

    get scale(): number {
        return this._grid.scale;
    }

    set scale(scale: number) {
        if (Math.abs(this._grid.scale - scale) > 0.01) {
            const { width, height } = this._svg.node().parentElement.getBoundingClientRect();
            this.rescale(width * 0.5, height * 0.5, scale);
        }
    }

    get onScale(): Observable<number> {
        return this._onScaleObservable;
    }

    set filter(filter: RelationGraphPredicate) {
        if (!this._filter && !filter) {
            return;
        }
        this._filter = filter;
        this.filterAndFindNodes();
    }

    set find(find: RelationGraphPredicate) {
        if (!this._find && !find) {
            return;
        }
        this._find = find;
        this.filterAndFindNodes();
    }

    set collapsedUpstreamDepth(depth: number) {
        this._depthController.collapseUpstream(depth);
    }

    set collapsedDownstreamDepth(depth: number) {
        this._depthController.collapseDownstream(depth);
    }

    get translate(): RelationGraphComponentPosition {
        return this._translate;
    }

    appendTo(elementRef: ElementRef): void {
        this._svg = <D3Element>D3.select(elementRef.nativeElement).append('svg');
        this._svg.style('width', '100%')
            .style('height', '100%')
            .style('opacity', '0');

        this.appendDefs();

        this._g = <D3Group>this._svg.append('g')
            .attr('class', 'relation-graph');

        this._zoom = D3.zoom()
            .scaleExtent([Constants.GRID.SCALE.MIN, Constants.GRID.SCALE.MAX])
            .on('zoom', () => {
                this._translate.x = D3.event.transform.x;
                this._translate.y = D3.event.transform.y;
                this._g.attr('transform', `translate(${D3.event.transform.x}, ${D3.event.transform.y})`);
                const scale = D3.event.transform.k;
                if (Math.abs(this._grid.scale - scale) > 0.01) {
                    this._grid.scale = scale;
                    this.scalePositions();
                    this.updateStates();
                    this.update();
                    this._onScaleSubject.next(this._grid.scale);
                }
                if (this._depthController) {
                    this._depthController.updatePositions();
                }
            });
        this._svg.call(this._zoom);
        this._svg.on('click', () => {
            D3.event.stopPropagation();
            D3.event.preventDefault();
            this.unselect();
            this.unfocus();
            this.updateStates();
            this.update();
            this.thenRaise();
        });
        this._svg.on('dblclick.zoom', null);
        this._svg.on('wheel.zoom', null);
        this._svg.on('mousewheel.zoom', null);
        this._svg.on('wheel', () => {
            D3.event.stopPropagation();
            D3.event.preventDefault();
            const { left, top } = this._svg.node().parentElement.getBoundingClientRect();
            this.rescale(D3.event.clientX - left, D3.event.clientY - top,
                this.scale + Constants.GRID.SCALE.STEP * (D3.event.deltaY >= 0 ? -1 : 1));
        });
        this._svg.on('dblclick', null);

        this._relations.forEach(relation => {
            relation.appendTo(this._g);
        });
        this._nodes.forEach(node => {
            node.appendTo(this._g);
        });

        this._rootNode.appendTo(this._g);

        this.updateNodeVerdicts();
        this.updateStates();
        this.reposition();
        this.update();

        this.resetPositionAndScale();

        this._depthController.appendTo(this._svg);
        this._depthController.upstreamMaxDepth = this._upstreamRootNode.computeMaxDepth();
        this._depthController.downstreamMaxDepth = this._downstreamRootNode.computeMaxDepth();
        this._depthController.update();

        this._subscriptions.push(this._depthController.onChange.subscribe(() => {
            this.updateAfterDepthChange();
            this.updateRootNodeDepthControls();
        }));

        this._subscriptions.push(this._rootNode.upstreamDepthControl.onChange.subscribe(() => {
            this._depthController.upstreamRootControl.collapsed = this._rootNode.upstreamDepthControl.collapsed;
            this._depthController.update();
            this.updateAfterDepthChange();
        }));

        this._subscriptions.push(this._rootNode.downstreamDepthControl.onChange.subscribe(() => {
            this._depthController.downstreamRootControl.collapsed = this._rootNode.downstreamDepthControl.collapsed;
            this._depthController.update();
            this.updateAfterDepthChange();
        }));

        this.updateRootNodeDepthControls();
    }

    remove(): void {
        this._svg.remove();
    }

    cleanup(): void {
        if (this._filterTimeout !== null) {
            clearTimeout(this._filterTimeout);
            this._filterTimeout = null;
        }
        if (this._focusTimeout !== null) {
            clearTimeout(this._focusTimeout);
            this._focusTimeout = null;
        }
        this._onPreFocusSubject.complete();
        this._onFocusSubject.complete();
        this._onBlurSubject.complete();
        this._onSelectSubject.complete();
        this._onScaleSubject.complete();
        this._subscriptions.forEach(subscription => subscription.unsubscribe());
        this._subscriptions = [];
        this._downstreamPositioner.cleanup();
        this._downstreamPositioner = null;
        this._upstreamPositioner.cleanup();
        this._upstreamPositioner = null;
        this._depthController.cleanup();
        this._nodes.forEach(node => node.cleanup());
        this._relations.forEach(relation => relation.cleanup());
        this._graph = null;
        this._rootNode.cleanup();
        this._rootNode = null;
        this._upstreamRoot = null;
        this._downstreamRoot = null;
        this._downstreamRootNode = null;
        this._upstreamRootNode = null;
        this._types = null;
        this._downstreamNodes = null;
        this._downstreamNodeMap = null;
        this._upstreamNodes = null;
        this._upstreamNodeMap = null;
        this._downstreamRelations = null;
        this._upstreamRelations = null;
        this._nodes = null;
        this._relations = null;
        this._svg.on('click', null);
        this._svg.on('wheel', null);
        this._svg.on('dblclick', null);
        this._svg = null;
        this._g = null;
        this._zoom.on('zoom', null);
        this._zoom = null;
        this._grid = null;
        this._depthController = null;
        this._focused = null;
        this._selected = null;
        this._filter = null;
        this._find = null;
    }

    private appendDefs(): void {
        const defs = <D3Defs>this._svg.append('defs');
        const width = Constants.NODE.WIDTH;
        const height = Constants.NODE.HEIGHT;
        defs.append('path')
            .attr('id', 'n')
            .attr('d', `M ${height * 0.5},0 ` +
                `L ${width - 12},0 ` +
                `A ${height * 0.5},${height * 0.5} 0,0,1 ${width - 12},${height} ` +
                `L ${height * 0.5},${height} ` +
                `A ${height * 0.5},${height * 0.5} 0,0,1 ${height * 0.5},0`)
            .attr('transform', `translate(${-width * 0.5}, ${-height * 0.5})`);

        defs.append('path')
            .attr('id', 'dl')
            .attr('d', `M ${height * 0.5},0 ` +
                `L ${width - 4},0 ` +
                `A 4,4 0,0,1 ${width},4 ` +
                `L ${width},${height - 4} ` +
                `A 4,4 0,0,1 ${width - 4},${height} ` +
                `L ${height * 0.5},${height} ` +
                `A ${height * 0.5},${height * 0.5} 0,0,1 ${height * 0.5},0`)
            .attr('transform', `translate(${-width * 0.5}, ${-height * 0.5})`);

        defs.append('path')
            .attr('id', 'ul')
            .attr('d', `M 4,0 ` +
                `L ${width - height * 0.5},0 ` +
                `A ${height * 0.5},${height * 0.5} 0,0,1 ${width},${height * 0.5} ` +
                `A ${height * 0.5},${height * 0.5} 0,0,1 ${width - 12},${height} ` +
                `L 4,${height} ` +
                `A 4,4 0,0,1 0,${height - 4} ` +
                `L 0,4 ` +
                `A 4,4 0,0,1 4,0`)
            .attr('transform', `translate(${-width * 0.5}, ${-height * 0.5})`);
    }

    private rescale(x: number, y: number, scale: number): void {
        const s = Math.min(Constants.GRID.SCALE.MAX, Math.max(Constants.GRID.SCALE.MIN, scale));
        const mx = x - this._translate.x;
        const my = y - this._translate.y;
        const tx = (Constants.ROOT_NODE.WIDTH + Constants.ROOT_NODE.PADDING) * 0.5 * (mx >= 0 ? 1 : -1);
        const ty = 0;
        const sx = tx + Math.round((mx - tx) / (this._grid.width * this._grid.scale)) * (this._grid.width * this._grid.scale);
        const sy = ty + Math.round((my - ty) / (this._grid.height * this._grid.scale)) * (this._grid.height * this._grid.scale);
        const t = Math.abs(mx - sx) <= (Constants.NODE.WIDTH * 0.5) && Math.abs(my - sy) <= (Constants.NODE.HEIGHT * 0.5);
        const ox = Math.round(t ? sx : mx);
        const oy = t ? sy : my;
        const dy = Math.round(ty + ((oy - ty) / (this._grid.height * this._grid.scale)) * (this._grid.height * s) - oy);
        const dx = Math.abs(ox) > Math.abs(tx) ?
            Math.round(tx + ((ox - tx) / (this._grid.width * this._grid.scale)) * (this._grid.width * s) - ox) :
            0;
        this._svg.call(this._zoom.transform, D3.zoomIdentity.translate(this._translate.x - dx, this._translate.y - dy).scale(s));
    }

    private reposition(): void {
        this._downstreamPositioner.reposition();
        this._upstreamPositioner.reposition();
        this.scalePositions();
    }

    private scalePositions(): void {
        this._nodes.forEach(node => node.scalePosition());
    }

    private updateStates(): void {
        this.updateNodeStates();
        this.updateRelationStates();
    }

    private filterAndFindNodes(): void {
        if (this._filterTimeout !== null) {
            clearTimeout(this._filterTimeout);
            this._filterTimeout = null;
        }

        this._filterTimeout = setTimeout(() => {
            this._filterTimeout = null;
            if (this._g) {
                this.updateNodeVerdicts();
                this.updateStates();
                let reposition = this._nodes.some(node => node.reposition);
                if (this._selected && this._selected.hidden) {
                    this.unselect();
                    this.updateStates();
                    reposition = reposition || this._nodes.some(node => node.reposition);
                }
                this._depthController.upstreamMaxDepth = this._upstreamRootNode.computeMaxDepth();
                this._depthController.downstreamMaxDepth = this._downstreamRootNode.computeMaxDepth();

                this._depthController.update();

                this.animateRootNodeDepthControls();

                if (reposition) {
                    this.reposition();
                }
                this.raise();
                this.animate();
            }
        }, this._filterDelay);
    }

    private updateNodeVerdicts(): void {
        this.resetNodeVerdicts();
        this.filterNodes();
        this.findNodes();
        this.postProcessNodeVerdicts();
    }

    private resetNodeVerdicts(): void {
        this._nodes.forEach(node => node.verdict.reset());
    }

    private filterNodes(): void {
        if (this._filter) {
            this._nodes.forEach(node => {
                if (!node.isRoot) {
                    node.verdict.hide = !this._filter(node.node, node.type.type);
                }
            });
            this._nodes.forEach(node => {
                if (!node.verdict.hide) {
                    node.parents.forEach(parent => {
                        if (parent.verdict.hide) {
                            parent.verdict.hide = false;
                            parent.verdict.fade = true;
                        }
                    });
                }
            });
        }
    }

    private findNodes(): void {
        if (this._find) {
            this._nodes.forEach(node => {
                if (!node.isRoot && (!node.verdict.hide || node.verdict.fade)) {
                    if (this._find(node.node, node.type.type)) {
                        node.verdict.highlight = true;
                        node.verdict.fade = false;
                    } else {
                        node.verdict.fade = true;
                    }
                }
            });
            this._nodes.forEach(node => {
                if (node.verdict.highlight && !node.verdict.fade) {
                    node.parents.forEach(parent => {
                        if (!parent.verdict.hide) {
                            parent.verdict.fade = false;
                        }
                    });
                }
            });
        }
    }

    private postProcessNodeVerdicts(): void {
        if (this._filter || this._find) {
            this._nodes.forEach(node => {
                if (node.verdict.fade || node.verdict.highlight) {
                    node.verdict.hide = false;
                }
            });
        }
    }

    private updateNodeStates(): void {
        const focusedRoot = this._focused && this._focused.isRoot;
        const selectedRoot = this._selected && this._selected.isRoot;

        this._nodes.forEach(node => {
            node.faded = node.verdict.fade ||
                ((!!this._focused || !!this._selected) && !focusedRoot && !(selectedRoot && !this._focused));
            node.highlighted = node.verdict.highlight;
            node.lit = false;
            const hidden = node.hidden;
            const collapsed = node.collapsed;
            node.hidden = node.verdict.hide;
            node.collapsed = this._depthController.isCollapsed(node);
            node.reposition = node.hidden !== hidden || node.collapsed !== collapsed;
            node.tag.hide();
        });

        if (this._selected) {
            this._selected.faded = false;
            this._selected.lit = true;
            if (!selectedRoot) {
                this._selected.parents.forEach(parent => {
                    parent.faded = false;
                    parent.lit = true;
                });
                this._selected.children.forEach(child => {
                    child.faded = false;
                    child.lit = true;
                });
            }
            this._selected.relationsTo.forEach(relation => {
                if (relation.type) {
                    relation.source.tag.text = relation.type.name;
                }
            });
        }

        if (this._focused) {
            this._focused.faded = false;
            this._focused.parents.forEach(parent => {
                parent.faded = false;
            });
            this._focused.children.forEach(child => {
                child.faded = false;
            });
        }
    }

    private updateRelationStates(): void {
        this._relations.forEach(relation => {
            relation.faded = relation.source.faded || relation.target.faded;
            relation.lit = relation.source.lit && relation.target.lit;
            relation.hidden = !relation.source.visible || !relation.target.visible;
            relation.collapsed = relation.source.collapsed && relation.target.collapsed;
        });
    }

    private update(): void {
        this._relations.forEach(relation => relation.update());
        this._nodes.forEach(node => node.update());
    }

    private animate(): void {
        this._relations.forEach(relation => relation.animate());
        this._nodes.forEach(node => node.animate());
    }

    private thenRaise(): void {
        if (this._raiseTimeout !== null) {
            clearTimeout(this._raiseTimeout);
            this._raiseTimeout = null;
        }
        this._raiseTimeout = setTimeout(() => {
            this.raise();
            this._raiseTimeout = null;
        }, Constants.TRANSITION.DURATION);
    }

    private raise(): void {
        this._nodes.forEach(node => {
            node.raise();
        });
        this._relations.forEach(relation => {
            if (relation.lit) {
                relation.raise();
            }
        });
        if (this._selected && this._selected.lit) {
            this._selected.raise();
        }
        this._rootNode.raise();
        this._nodes.forEach(node => {
            if ((node.lit && !node.selected) || (node.tag && !node.tag.hidden)) {
                node.raise();
            }
        });
    }

    private updateAfterDepthChange(): void {
        this.updateStates();
        this.reposition();
        this.animate();
    }

    private updateRootNodeDepthControls(): void {
        this.updateRootNodeDepthControlStates();
        this._rootNode.upstreamDepthControl.updateState();
        this._rootNode.downstreamDepthControl.updateState();
    }

    private animateRootNodeDepthControls(): void {
        this.updateRootNodeDepthControlStates();
        this._rootNode.upstreamDepthControl.animateState();
        this._rootNode.downstreamDepthControl.animateState();
    }

    private updateRootNodeDepthControlStates(): void {
        this._rootNode.upstreamDepthControl.hidden = !this._depthController.upstreamRootControl ||
            this._depthController.upstreamRootControl.hidden || this._depthController.upstreamRootControl.overflowed;
        this._rootNode.upstreamDepthControl.collapsed = this._depthController.upstreamRootControl &&
            this._depthController.upstreamRootControl.collapsed;
        this._rootNode.downstreamDepthControl.hidden = !this._depthController.downstreamRootControl ||
            this._depthController.downstreamRootControl.hidden || this._depthController.downstreamRootControl.overflowed;
        this._rootNode.downstreamDepthControl.collapsed = this._depthController.downstreamRootControl &&
            this._depthController.downstreamRootControl.collapsed;
    }

    private resetPositionAndScale(): void {
        setTimeout(() => {
            const { height: parentHeight } = this._svg.node().parentElement.getBoundingClientRect();
            const { height: graphHeight } = this._g.node().getBBox();
            const dy = this._nodes.reduce((y, node) => Math.max(y, node.scaledPosition.y + node.dimensions.height * 0.5), 0);
            const h = (parentHeight - graphHeight) * 0.5;
            const tx = Constants.ROOT_NODE.WIDTH;
            const ty = Math.min(Math.max(Constants.ROOT_NODE.HEIGHT, h + graphHeight - dy), parentHeight - Constants.ROOT_NODE.HEIGHT);
            this._svg.call(this._zoom.transform, D3.zoomIdentity.translate(tx, ty).scale(1));
            this._svg.style('opacity', null);
        });
    }

    private focus(node: RelationGraphComponentNode): void {
        if (this._focusTimeout !== null) {
            clearTimeout(this._focusTimeout);
            this._focusTimeout = null;
        }
        this._focusTimeout = setTimeout(() => {
            this._focused = node.isRoot ? this._upstreamRootNode : node;

            this.updateStates();
            this.update();

            this._focusTimeout = null;
            this._onFocusSubject.next(node);
        }, this._focusDelay);

        this._onPreFocusSubject.next(node);
    }

    private blur(): void {
        if (this._focusTimeout !== null) {
            clearTimeout(this._focusTimeout);
            this._focusTimeout = null;
        }

        this._focused = null;
        this.updateStates();
        this.update();
        this._onBlurSubject.next();
    }

    private unfocus(): void {
        if (this._focusTimeout !== null) {
            clearTimeout(this._focusTimeout);
            this._focusTimeout = null;
        }
        this._focused = null;
        this._onBlurSubject.next();
    }

    private click(node: RelationGraphComponentNode): void {
        this.unfocus();
        this.select(node);
        this.updateStates();
        this.raise();
        this.animate();
    }

    private select(node: RelationGraphComponentNode): void {
        this._nodes.forEach(n => n.selected = false);
        this._selected = node.isRoot ? this._upstreamRootNode : node;
        this._selected.selected = true;
        this._onSelectSubject.next(this._selected.isRoot ? null : this._selected);
    }

    private unselect(): void {
        this._nodes.forEach(node => node.selected = false);
        this._selected = null;
        this._onSelectSubject.next(null);
    }

    private findType(ref: Ref): RelationGraphComponentType {
        return this._types[ref];
    }

    private findNode(nodeMap: Array<RelationGraphComponentNode>, ref: Ref): RelationGraphComponentNode {
        return nodeMap[ref];
    }

    private createDepthController(): void {
        this._depthController = new RelationGraphComponentDepthController(this._upstreamRoot, this._downstreamRoot);
    }

    private createDownstreamPositioner(): void {
        this._downstreamPositioner = new DefaultRelationGraphComponentPositioner(this._downstreamNodes, this._downstreamRootNode.maxDepth);
    }

    private createUpstreamPositioner(): void {
        this._upstreamPositioner = new DefaultRelationGraphComponentPositioner(this._upstreamNodes, this._upstreamRootNode.maxDepth);
    }

    private createTypes(): void {
        this._types = (this._graph.types || []).map((type, ref) => new RelationGraphComponentType(ref, type));
    }

    private createDownstreamRoot(): void {
        this._downstreamRoot = this.createRoot(
            () => this._downstreamRootNode,
            () => this._downstreamNodeMap,
            () => this._downstreamMaxDepth);
    }

    private createUpstreamRoot(): void {
        this._upstreamRoot = this.createRoot(
            () => this._upstreamRootNode,
            () => this._upstreamNodeMap,
            () => this._upstreamMaxDepth);
    }

    private createRoot<N extends RelationGraphComponentNode>(
        rootNode: () => RelationGraphComponentNode,
        nodeMap: () => Array<N>,
        maxDepth: () => number): RelationGraphComponentRoot {
        const self = this;
        return {
            get translate(): RelationGraphComponentPosition { return self._translate; },
            get grid(): RelationGraphComponentGrid { return self._grid; },
            get rootNode(): RelationGraphComponentNode { return rootNode(); },
            get maxDepth(): number { return maxDepth(); },
            findType(ref: Ref): RelationGraphComponentType { return self.findType(ref); },
            findNode(ref: Ref): RelationGraphComponentNode { return self.findNode(nodeMap(), ref); },
            onFocus(node: RelationGraphComponentNode): void { self.focus(node); },
            onBlur(): void { self.blur(); },
            onClick(node: RelationGraphComponentNode): void { self.click(node); }
        };
    }

    private createRootNode(): void {
        const rootRef = this._graph.rootRef;
        const rootNode = this._graph.nodes[rootRef];
        this._rootNode = new RelationGraphComponentRootNode(this._graph.rootRef, this._downstreamRoot, rootNode);
    }

    private createDownstreamRootNode(): void {
        const rootRef = this._graph.rootRef;
        const rootNode = this._graph.nodes[rootRef];
        this._downstreamRootNode = new RelationGraphComponentDownstreamRootNode(rootRef, this._downstreamRoot, rootNode);
    }

    private createDownstreamNodesAndRelations(): void {
        const relations = this.findRelations((ref, relation) => relation.sourceRef === ref, rel => rel.targetRef);
        this._downstreamNodes = [this._downstreamRootNode];
        this._downstreamRelations = [];
        this._downstreamNodeMap = new Array(this._graph.nodes.length);
        this._downstreamNodeMap[this._downstreamRootNode.ref] = this._downstreamRootNode;
        relations.forEach(relation => {
            if (relation) {
                const ref = relation.targetRef;
                if (!this._downstreamNodeMap[ref]) {
                    const node = new RelationGraphComponentDownstreamNode(ref, this._downstreamRoot, this._graph.nodes[ref]);
                    this._downstreamNodes.push(node);
                    this._downstreamNodeMap[ref] = node;
                }
                this._downstreamRelations.push(new RelationGraphComponentRelation(this._downstreamRoot, relation));
            }
        });
        this._downstreamRelations.forEach(relation => {
            this._downstreamNodeMap[relation.sourceRef].relationsFrom.push(relation);
            this._downstreamNodeMap[relation.targetRef].relationsTo.push(relation);
        });
    }

    private createUpstreamRootNode(): void {
        const rootRef = this._graph.rootRef;
        const rootNode = this._graph.nodes[rootRef];
        this._upstreamRootNode = new RelationGraphComponentUpstreamRootNode(rootRef, this._upstreamRoot, rootNode);
    }

    private createUpstreamNodesAndRelations(): void {
        const relations = this.findRelations((ref, relation) => relation.targetRef === ref, rel => rel.sourceRef);
        this._upstreamNodes = [this._upstreamRootNode];
        this._upstreamRelations = [];
        this._upstreamNodeMap = new Array(this._graph.nodes.length);
        this._upstreamNodeMap[this._upstreamRootNode.ref] = this._upstreamRootNode;
        relations.forEach(relation => {
            if (relation) {
                const ref = relation.sourceRef;
                if (!this._upstreamNodeMap[ref]) {
                    const node = new RelationGraphComponentUpstreamNode(ref, this._upstreamRoot, this._graph.nodes[ref]);
                    this._upstreamNodes.push(node);
                    this._upstreamNodeMap[ref] = node;
                }
                this._upstreamRelations.push(new RelationGraphComponentRelation(this._upstreamRoot, relation));
            }
        });
        this._upstreamRelations.forEach(relation => {
            this._upstreamNodeMap[relation.sourceRef].relationsFrom.push(relation);
            this._upstreamNodeMap[relation.targetRef].relationsTo.push(relation);
        });
    }

    private distributeDownstreamNodes(): void {
        this._downstreamRootNode.distribute(0);
        this._downstreamMaxDepth = this._downstreamNodes.reduce((depth, node) => Math.max(depth, node.depth), 0);
    }

    private distributeUpstreamNodes(): void {
        this._upstreamRootNode.distribute(0);
        this._upstreamMaxDepth = this._upstreamNodes.reduce((depth, node) => Math.max(depth, node.depth), 0);
    }

    private findRelations(
        filter: (parentRef: Ref, relation: RelationGraphRelation) => boolean,
        nextNodeRef: (relation: RelationGraphRelation) => Ref
    ): Array<RelationGraphRelation> {
        const rootRef = this._graph.rootRef;
        const visitedNodes = new Array(this._graph.nodes.length);
        const visitedRelations = new Array(this._graph.relations.length);
        const relations: Array<RelationGraphRelation> = new Array(this._graph.relations.length);
        this.findChildRelations(rootRef, filter, nextNodeRef, visitedNodes, visitedRelations, relations);
        return relations;
    }

    private findChildRelations(parentRef: Ref,
        filter: (parentRef: Ref, relation: RelationGraphRelation) => boolean,
        nextNodeRef: (relation: RelationGraphRelation) => Ref,
        visitedNodes: Array<boolean>,
        visitedRelations: Array<boolean>,
        childRelations: Array<RelationGraphRelation>
    ): void {
        visitedNodes[parentRef] = true;
        try {
            this._graph.relations.forEach((relation, relRef) => {
                if (filter(parentRef, relation)) {
                    const childRef = nextNodeRef(relation);
                    if (!visitedNodes[childRef]) {
                        if (!visitedRelations[relRef]) {
                            childRelations[relRef] = relation;
                            visitedRelations[relRef] = true;
                            this.findChildRelations(childRef, filter, nextNodeRef, visitedNodes, visitedRelations, childRelations);
                        }
                    } else {
                        childRelations[relRef] = null;
                        visitedRelations[relRef] = true;
                    }
                }
            });
        } finally {
            visitedNodes[parentRef] = false;
        }
    }
}
