import { D3Group, D3Element } from './types';
import { RelationGraphComponentConstants as Constants } from './constants';
import { RelationGraphComponentRoot } from './root';
import {
    RelationGraphComponentDepthControl,
    RelationGraphComponentUpstreamDepthControl,
    RelationGraphComponentDownstreamDepthControl
} from './depth-control';
import { Subject, Observable, Subscription } from 'rxjs';
import { RelationGraphComponentNode } from './node';

export class RelationGraphComponentDepthController {
    upstreamMaxDepth: number;
    downstreamMaxDepth: number;
    private _upstreamControls: Array<RelationGraphComponentUpstreamDepthControl> = [];
    private _downstreamControls: Array<RelationGraphComponentDownstreamDepthControl> = [];
    private _onChangeSubject: Subject<void> = new Subject();
    private _onChangeObservable = this._onChangeSubject.asObservable();
    private _g: D3Group;
    private _subscriptions: Array<Subscription> = [];

    constructor(private _upstreamRoot: RelationGraphComponentRoot, private _downstreamRoot: RelationGraphComponentRoot) {
        this.upstreamMaxDepth = this._upstreamRoot.maxDepth;
        this.downstreamMaxDepth = this._downstreamRoot.maxDepth;
        this.createControls(() => this.upstreamMaxDepth, this._upstreamControls,
            depth => new RelationGraphComponentUpstreamDepthControl(this._upstreamRoot, depth));
        this.createControls(() => this.downstreamMaxDepth, this._downstreamControls,
            depth => new RelationGraphComponentDownstreamDepthControl(this._downstreamRoot, depth));
    }

    get onChange(): Observable<void> {
        return this._onChangeObservable;
    }

    get upstreamRootControl(): RelationGraphComponentUpstreamDepthControl {
        return this._upstreamControls.length ? this._upstreamControls[0] : null;
    }

    get downstreamRootControl(): RelationGraphComponentDownstreamDepthControl {
        return this._downstreamControls.length ? this._downstreamControls[0] : null;
    }

    collapseUpstream(depth: number): void {
        if (depth !== null && depth !== undefined && depth >= 0 && depth < this._upstreamControls.length) {
            this._upstreamControls[depth].collapsed = true;
            this.updateControls(this._upstreamControls, this.upstreamMaxDepth);
            this._onChangeSubject.next();
        }
    }

    collapseDownstream(depth: number): void {
        if (depth !== null && depth !== undefined && depth >= 0 && depth < this._downstreamControls.length) {
            this._downstreamControls[depth].collapsed = true;
            this.updateControls(this._downstreamControls, this.downstreamMaxDepth);
            this._onChangeSubject.next();
        }
    }

    appendTo(parent: D3Element): void {
        this._g = <D3Group>parent.append('g');
        this._g.attr('class', 'depth-controller');
        this._g.append('rect')
            .attr('class', 'background')
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', Constants.DEPTH_CONTROLLER.WIDTH)
            .attr('height', Constants.DEPTH_CONTROLLER.HEIGHT);
        this.appendControls(this._upstreamControls);
        this.appendControls(this._downstreamControls);
    }

    update(): void {
        if (this._g) {
            this.updateControls(this._upstreamControls, this.upstreamMaxDepth);
            this.updateControls(this._downstreamControls, this.downstreamMaxDepth);
        }
    }

    updatePositions(): void {
        this._upstreamControls.forEach(control => control.updatePosition());
        this._downstreamControls.forEach(control => control.updatePosition());
    }

    cleanup(): void {
        this._onChangeSubject.complete();
        this._subscriptions.forEach(subscription => subscription.unsubscribe());
        this._subscriptions = [];
        this._upstreamControls.forEach(control => control.cleanup());
        this._downstreamControls.forEach(control => control.cleanup());
        this._upstreamControls = null;
        this._downstreamControls = null;
        this._g = null;
        this._upstreamRoot = null;
        this._downstreamRoot = null;
    }

    isCollapsed(node: RelationGraphComponentNode): boolean {
        if (node.isRoot) {
            return false;
        } else if (node.isUpstream) {
            return this.isDepthCollapsed(node.depth, this._upstreamControls);
        } else if (node.isDownstream) {
            return this.isDepthCollapsed(node.depth, this._downstreamControls);
        } else {
            return false;
        }
    }

    private isDepthCollapsed(depth: number, controls: Array<RelationGraphComponentDepthControl>): boolean {
        if (depth < controls.length) {
            return controls[depth].hidden;
        } else {
            const lastControl = controls[controls.length - 1];
            return lastControl.collapsed || lastControl.hidden;
        }
    }

    private createControls<T extends RelationGraphComponentDepthControl>(
        maxDepth: () => number, controls: Array<T>, factory: (depth: number) => T): void {
        for (let depth = 0; depth < maxDepth(); ++depth) {
            const control = factory(depth);
            this._subscriptions.push(control.onChange.subscribe(() => {
                this.updateControls(controls, maxDepth());
                this._onChangeSubject.next();
            }));
            controls.push(control);
        }
    }

    private appendControls(controls: Array<RelationGraphComponentDepthControl>): void {
        controls.forEach(control => {
            control.appendTo(this._g);
        });
    }

    private updateControls(controls: Array<RelationGraphComponentDepthControl>, maxDepth: number): void {
        let hidden = false;
        controls.forEach(control => {
            control.hidden = hidden;
            control.overflowed = control.depth >= maxDepth;
            control.updatePosition();
            control.animateState();
            hidden = hidden || control.collapsed;
        });
    }
}
