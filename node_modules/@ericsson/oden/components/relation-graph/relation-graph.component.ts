import {
    Component,
    ViewEncapsulation,
    HostBinding,
    Input,
    ElementRef,
    OnChanges,
    SimpleChanges,
    OnInit,
    OnDestroy,
    Output,
    EventEmitter,
    ViewChild,
    NgZone
} from '@angular/core';
import { RelationGraphComponentGraph } from './graph/graph';
import { RelationGraphComponentConstants as Constants } from './graph/constants';
import { SliderChange } from '../form';
import { RelationGraph, RelationGraphEvent, RelationGraphPredicate } from './relation-graph.model';
import { RelationGraphComponentNode } from './graph/node';
import { Subscription } from 'rxjs';

@Component({
    selector: 'cui-relation-graph',
    templateUrl: 'relation-graph.component.html',
    styleUrls: ['relation-graph.component.scss'],
    encapsulation: ViewEncapsulation.None
})

/**
 * Relation graph component, used to visualize relations between nodes.
 */
export class RelationGraphComponent implements OnInit, OnDestroy, OnChanges {
    @HostBinding('class.cui-relation-graph') addClass: boolean = true;
    @Input() graph: RelationGraph;
    @Input() collapsedUpstreamDepth: number = null;
    @Input() collapsedDownstreamDepth: number = null;
    @Input() filter: RelationGraphPredicate = null;
    @Input() find: RelationGraphPredicate = null;
    @Output() onSelect: EventEmitter<RelationGraphEvent> = new EventEmitter();
    @Output() onUnselect: EventEmitter<void> = new EventEmitter();
    @ViewChild('details') _detailsElement: ElementRef;
    @ViewChild('nodeHelper') _nodeHelperElement: ElementRef;
    _constants = Constants;
    _detailsVisible: boolean = false;
    _detailsLeft: string = '0';
    _detailsTop: string = '0';
    _detailsTitle: string = '';
    _detailsBody: string = '';
    _scale: number = 1;
    private _graph: RelationGraphComponentGraph;
    private _detailsDelay = Constants.FOCUS.TIMEOUT;
    private _detailsTimeout = null;
    private _subscriptions: Array<Subscription> = [];

    constructor(private _elementRef: ElementRef, private _zone: NgZone) { }

    ngOnInit(): void {
        this._createGraph();
    }

    ngOnDestroy(): void {
        this._hideDetails();
        this._unsubscribe();
        this._cleanup();
        this.filter = null;
        this.find = null;
    }

    ngOnChanges(changes: SimpleChanges): void {
        if (changes.graph && !changes.graph.isFirstChange()) {
            this._destroyGraph();
            this._createGraph();
        }
        if (changes.filter && this._graph) {
            this._graph.filter = this.filter;
        }
        if (changes.find && this._graph) {
            this._graph.find = this.find;
        }
    }

    _onScaleChange(sliderChange: SliderChange): void {
        this._scale = sliderChange.value;
        this._graph.scale = this._scale;
    }

    private _createGraph(): void {
        if (this._elementRef && this.graph && !this._graph) {
            this._graph = RelationGraphComponentGraph.create(this.graph);
            this._graph.collapsedUpstreamDepth = this.collapsedUpstreamDepth;
            this._graph.collapsedDownstreamDepth = this.collapsedDownstreamDepth;
            this._subscriptions.push(this._graph.onPreFocus.subscribe(() => this._hideDetails()));
            this._subscriptions.push(this._graph.onFocus.subscribe(node => this._showDetails(node)));
            this._subscriptions.push(this._graph.onBlur.subscribe(() => this._hideDetails()));
            this._subscriptions.push(this._graph.onSelect.subscribe(node => {
                this._hideDetails();
                if (node) {
                    this._positionNodeHelper(node);
                    this.onSelect.emit({
                        node: node.node,
                        type: node.type,
                        elementRef: this._nodeHelperElement
                    });
                } else {
                    this.onUnselect.emit();
                }
            }));
            this._subscriptions.push(this._graph.onScale.subscribe(scale => {
                this._scale = scale;
            }));
            this._graph.filter = this.filter;
            this._graph.find = this.find;
            this._graph.appendTo(this._elementRef);
        }
    }

    private _destroyGraph(): void {
        this._scale = 1;
        this._unsubscribe();
        if (this._graph) {
            this._graph.remove();
            this._graph.cleanup();
            this._graph = null;
        }
    }

    private _cleanup(): void {
        if (this._graph) {
            this._graph.cleanup();
            this._graph = null;
        }
    }

    private _unsubscribe(): void {
        this._subscriptions.forEach(subscription => subscription.unsubscribe());
        this._subscriptions = [];
    }

    private _positionNodeHelper(node: RelationGraphComponentNode): void {
        const { x, y } = node.scaledPosition;
        const { x: tx, y: ty } = this._graph.translate;
        const { width, height } = node.dimensions;
        this._nodeHelperElement.nativeElement.style.left = `${x + tx - width * 0.5}px`;
        this._nodeHelperElement.nativeElement.style.top = `${y + ty - height * 0.5}px`;
        this._nodeHelperElement.nativeElement.style.width = `${width}px`;
        this._nodeHelperElement.nativeElement.style.height = `${height}px`;
    }

    private _showDetails(node: RelationGraphComponentNode): void {
        this._hideDetails();
        this._detailsTitle = node.type.name;
        this._detailsBody = node.name;
        setTimeout(() => {
            const rect = this._elementRef.nativeElement.getBoundingClientRect();
            const detailsRect = this._detailsElement.nativeElement.getBoundingClientRect();
            const maxWidth = rect.width;
            const { width, height } = detailsRect;
            let x = node.scaledPosition.x + this._graph.translate.x - width * 0.5;
            let y = node.scaledPosition.y + this._graph.translate.y - height - 20;
            x = Math.min(maxWidth - 2 - width, Math.max(2, x));
            if (y < 2) {
                y = node.scaledPosition.y + this._graph.translate.y + 20;
            }
            this._detailsLeft = `${x}px`;
            this._detailsTop = `${y}px`;
            this._detailsVisible = true;
            this._zone.runOutsideAngular(() => {
                this._detailsTimeout = setTimeout(() => {
                    this._detailsTimeout = null;
                    this._zone.run(() => {
                        this._hideDetails();
                    });
                }, this._detailsDelay);
            });
        });
    }

    private _hideDetails(): void {
        this._detailsVisible = false;
        if (this._detailsTimeout) {
            clearTimeout(this._detailsTimeout);
            this._detailsTimeout = null;
        }
    }
}
