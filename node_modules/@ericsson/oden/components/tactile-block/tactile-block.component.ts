import {
    Component,
    ComponentFactoryResolver,
    ComponentRef,
    ElementRef,
    EventEmitter,
    HostBinding,
    HostListener,
    Input,
    OnDestroy,
    OnInit,
    Output,
    Renderer2,
    ViewChild,
    ViewContainerRef,
    ViewEncapsulation,
    OnChanges,
    SimpleChanges
} from '@angular/core';
import { ANIMATION } from '../../core/constants/animation.constants';
import { KeyboardAccessibility } from '../../core/classes/keyboard-accessibility';
import { animate, state, style, transition, trigger } from '@angular/animations';
import { TactileBlockItem } from '../../core/models/tactile-block-item.model';
import { DOMHelper } from '../../core/helpers/dom.helper';
import { ActionItem } from '../../core/models/action-item.model';
import { LibraryActionEvent } from '../../core/models/library-action-event.model';
import { ActionEvent } from '../../core/models/action-event.model';
import { ITactileBodyInterface } from '../../core/interfaces/tactile-body.interface';
import { TactileBlockService } from './tactile-block.service';
import { KEYBOARD } from '../../core/constants/keyboard.constants';
import { SIZING } from '../../core/constants';
import { TranslateService } from '@ngx-translate/core';
import { UnSub } from '../../core/classes';
import { Subscription } from 'rxjs/Subscription';

const inDropzone = (target: Node) => DOMHelper.isChildOfElement('.cui-dropzone', target) ||
    DOMHelper.isChildOfElement('.cui-block-tree', target);

@Component({
    selector: 'cui-tactile-block',
    templateUrl: 'tactile-block.component.html',
    styleUrls: ['tactile-block.component.scss'],
    animations: [
        trigger('state', [
            state('*', style({
                height: SIZING.TACTILE_BLOCK_HEIGHT + 'px'
            })),
            state('expanded', style({
                height: '*'
            })),
            transition('* => expanded', animate('100ms ' + ANIMATION.EASE_OUT_QUAD)),
            transition('expanded => *', animate('100ms ' + ANIMATION.EASE_OUT_QUAD))
        ])
    ],
    encapsulation: ViewEncapsulation.None
})
@UnSub()
export class TactileBlockComponent extends KeyboardAccessibility implements OnInit, OnDestroy, OnChanges {
    renderer: Renderer2;
    public elementRef: ElementRef;
    originalElementRef: ElementRef;
    selectableQuerySelector = '.cui-button';
    selectedHtmlClass = 'cui-button-focus';
    state: string = 'expanded';
    _libraryMenuActions: Array<ActionItem> = [];
    private _isMouseDown: boolean = false;
    private _childComponentRef: ComponentRef<ITactileBodyInterface>;
    private showHoverItems: boolean = false;
    private _libraryExpandAction = new ActionItem({
        action: 'libraryExpandAction', label: 'Expand', icon: 'maximize', aboveTheLine: true
    });
    private _libraryCollapseAction = new ActionItem({
        action: 'libraryCollapseAction', label: 'Collapse', icon: 'minimize', aboveTheLine: true
    });
    private _libraryAddItemAction = new ActionItem({
        action: 'libraryAddItemAction', label: 'Add', icon: 'plus', aboveTheLine: true
    });
    private _subscriptions: Array<Subscription> = [];

    @HostBinding('class.selected') get selected(): boolean {
        return this.tactileBlockItem && this.tactileBlockItem.selectable ? this._tactileBlockService
            .selected.filter(item => item === this.tactileBlockItem).length !== 0 : false;
    }
    @HostBinding('class.selectable') get selectable(): boolean {
        return this.tactileBlockItem && this.tactileBlockItem.selectable;
    }
    @HostBinding('class.cui-tactile-block') addClass: boolean = true;
    @HostBinding('class.cui-tactile-block-collapsable') @Input() collapsable: boolean = false;
    @Input() expandable: boolean = true;
    @HostBinding('class.focus') private _isKeyboardFocused: boolean = false;
    @HostBinding('class.cui-tactile-block-disabled') @Input() disabled: boolean = false;
    @Input() customTabIndex: number;

    @Input() isInLibrary: boolean = true;
    @Input() collapsed: boolean;
    @Input() tactileBlockItem: TactileBlockItem;
    @HostBinding('class.maximized') @Input() maximized: boolean = false;
    @Output() onButtonActionClick: EventEmitter<ActionEvent> = new EventEmitter<ActionEvent>();
    @Output() onMenuActionClick: EventEmitter<ActionItem> = new EventEmitter<ActionItem>();
    @Output() onTactileClick: EventEmitter<TactileBlockItem> = new EventEmitter<TactileBlockItem>();
    @Output() onMouseLeave: EventEmitter<void> = new EventEmitter<void>();
    @Output() onAddItemActionClick: EventEmitter<ActionItem> = new EventEmitter<ActionItem>();

    @ViewChild('wrapper') wrapper: ElementRef;
    @ViewChild('childContainer', { read: ViewContainerRef }) childContainer: ViewContainerRef;

    get actionMenuTabIndex(): number {
        return !this.disabled && !this.collapsable && (this.customTabIndex === undefined || this.customTabIndex > -1) ?
            (this.customTabIndex > -1 ? this.customTabIndex : 0) : -1;
    }

    get wrapperTabIndex(): number {
        return !this.disabled && (this.collapsable || this.customTabIndex > -1 ||
            (this.customTabIndex === undefined && !this.collapsable)) ?
            (this.customTabIndex > -1 ? this.customTabIndex : 0) : null;
    }

    constructor(
        renderer: Renderer2,
        elementRef: ElementRef,
        private _componentFactoryResolver: ComponentFactoryResolver,
        private _tactileBlockService: TactileBlockService,
        translate: TranslateService
    ) {
        super(renderer, elementRef);
        this._subscriptions.push(translate.stream('ODEN.COMMON.EXPAND').subscribe(value => this._libraryExpandAction.label = value));
        this._subscriptions.push(translate.stream('ODEN.COMMON.COLLAPSE').subscribe(value => this._libraryCollapseAction.label = value));
        this._subscriptions.push(translate.stream('ODEN.COMMON.ADD').subscribe(value => this._libraryAddItemAction.label = value));
    }

    /**
     * Set some default values. If collapsed is not defined, set it to true if it's collapsable (like in Library),
     * otherwise set it to false.
     */
    ngOnInit(): void {
        this.originalElementRef = this.elementRef;
        this.elementRef = this.wrapper;
        if (typeof this.collapsed === 'undefined') {
            this.collapsed = this.collapsable;
        }
        if (this.collapsed) {
            this.state = 'collapsed';
        }
        if (this.maximized) {
            this.state = 'expanded';
        }
        this.listenForKeyDown = this.collapsable;

        if (this.collapsable || this.customTabIndex > -1 || DOMHelper.isChildOfElement('.cui-dropzone', this.elementRef.nativeElement)) {
            // On focus, mark block as keyboardfocused if the action is not from a mouse event
            this.wrapper.nativeElement.addEventListener('focus', () => {
                this._isKeyboardFocused = !this._isMouseDown;
            });
            // Set block as not keyboard focused when we leave/blur the block.
            this.wrapper.nativeElement.addEventListener('blur', () => {
                this._isKeyboardFocused = false;
            });
        }

        if (this.tactileBlockItem && ((this.isInLibrary && this.tactileBlockItem.libraryChildComponent)
            || (!this.isInLibrary && this.tactileBlockItem.childComponent))) {
            const childComponent = this.isInLibrary ? this.tactileBlockItem.libraryChildComponent : this.tactileBlockItem.childComponent;
            const factory = this._componentFactoryResolver.resolveComponentFactory(childComponent);
            this._childComponentRef = <ComponentRef<ITactileBodyInterface>>this.childContainer.createComponent(factory);
            this._childComponentRef.instance.tactileBlockItem = this.tactileBlockItem;
            this._childComponentRef.instance.parentBlockComponent = this;
        }

        this._updateLibraryMenuActions();
    }

    ngOnDestroy(): void {
        if (this._childComponentRef) {
            this._childComponentRef.destroy();
            this._childComponentRef = null;
        }
    }

    ngOnChanges(changes: SimpleChanges): void {
        if (changes.maximized && !changes.maximized.firstChange) {
            this.state = changes.maximized.currentValue ? 'expanded' : 'collapsed';
            this._updateLibraryMenuActions();
        }
    }

    showActionMenu(): boolean {
        return !this.isInLibrary && (!!this.tactileBlockItem.menuActions && this.tactileBlockItem.menuActions.length > 0);
    }

    showLibraryActionMenu(): boolean {
        return this.isInLibrary && (!!this._libraryMenuActions && this._libraryMenuActions.length > 0);
    }

    onFocus(): void {
        this.showHoverItems = true;
        // hide all other hover-item first
        setTimeout(() => {
            Array.from(document.querySelectorAll('.hover-item.visible:not(.block-tree-hover-item)')).forEach((_element) => {
                if (DOMHelper.closestParent(_element, 'cui-tactile-block') !== this.originalElementRef.nativeElement) {
                    this.renderer.removeClass(_element, 'visible');
                }
            });
        });
    }

    onBlur(): void {
        this.showHoverItems = false;
    }
    /**
     * Toggle the blocks selected status when pressing space or enter
     * while having it in focus. Skip this if we're already have listenForKeyDown (listeners taken care from KeyboardAccessibility)
     * @param {KeyboardEvent} event
     */
    @HostListener('keydown', ['$event'])
    enterPress(event: KeyboardEvent): void {
        if (this.listenForKeyDown || !this.tactileBlockItem.selectable) {
            return;
        }
        if (event.keyCode === KEYBOARD.ENTER || event.keyCode === KEYBOARD.SPACE) {
            if (this._tactileBlockService.selected.indexOf(this.tactileBlockItem) < 0) {
                this._tactileBlockService.selected = [this.tactileBlockItem];
            } else {
                this._tactileBlockService.selected = [];
            }
            event.preventDefault();
        }
    }

    /**
     * When a user clicks a tactile block, fix with _isMouseDown attribute (read more below)
     */
    @HostListener('mousedown')
    public onMouseDown(): void {
        // We only *show* the focus style when focus has come to the tactile block via the keyboard.
        this._isMouseDown = true;
        setTimeout(() => { this._isMouseDown = false; }, 100);
    }

    @HostListener('mouseover', ['$event'])
    onMouseOver(event: MouseEvent): void {
        // hide all other hover-item first
        Array.from(document.querySelectorAll('.hover-item:not(.always-show):not(.block-tree-hover-item).visible')).forEach((_element) => {
            const closestParent = DOMHelper.closestParent(_element, 'cui-tactile-block');
            if (closestParent !== this.originalElementRef.nativeElement) {
                this.renderer.removeClass(_element, 'visible');
            }
        });
        const hoverItems = this.originalElementRef.nativeElement.querySelectorAll('.hover-item:not(.visible):not(.block-tree-hover-item)');
        Array.from(hoverItems).forEach((_element) => {
            const closestParent = DOMHelper.closestParent(_element, 'cui-tactile-block');
            if (closestParent === this.originalElementRef.nativeElement) {
                this.renderer.addClass(_element, 'visible');
            }
        });
        event.stopPropagation();
    }

    @HostListener('mouseleave', ['$event'])
    onMouseLeaveListener(event: MouseEvent): void {
        this.onMouseLeave.emit();
        const hoverItems = this.originalElementRef.nativeElement.querySelectorAll(
            '.hover-item:not(.always-show):not(.block-tree-hover-item).visible'
        );
        Array.from(hoverItems).forEach((_element: HTMLElement) => {
            const closestParent = DOMHelper.closestParent(_element, 'cui-tactile-block');
            setTimeout(() => {
                if (closestParent === this.originalElementRef.nativeElement) {
                    this.renderer.removeClass(_element, 'visible');
                }
            });
        });
        event.stopPropagation();
    }

    /**
     * Sets a tactile block in selected/deselected mode. If user clicks in DOM except the drawer, the selected tactile
     * block is deselected. If user clicks on a tactile block it will turn into selected state.
     */
    @HostListener('document:click', ['$event'])
    public onDocumentClick(event: MouseEvent): void {
        // If user clicks outside, on the tactile block but not in a drawer
        this.deSelect(event);
    }

    /**
     * Sets a tactile block in selected/deselected mode. If user clicks in DOM except the drawer, the selected tactile
     * block is deselected. If user clicks on a tactile block it will turn into selected state.
     * @param {MouseEvent} event
     */
    @HostListener('click', ['$event'])
    public onClick(event: MouseEvent): void {
        this.click(event);
    }

    click(event: MouseEvent, focus: boolean = true): void {
        if (focus) {
            this.originalElementRef.nativeElement.focus();
        }
        setTimeout(() => {
            this._isKeyboardFocused = false;
        });
        if (
            !this.deSelect(event)
            && this.tactileBlockItem.selectable && this.elementRef.nativeElement.contains(event.target) &&
            inDropzone(<Node>event.target) &&
            !DOMHelper.isChildOfElement('.cui-action-menu', <Node>event.target)
        ) {
            if (!document.body.classList.contains('dragging')) {
                this._tactileBlockService.selected = [this.tactileBlockItem];
                // hide all other hover-item first
                Array.from(document.querySelectorAll('.hover-item.visible:not(.block-tree-hover-item)')).forEach((_element) => {
                    if (DOMHelper.closestParent(_element, 'cui-tactile-block') !== this.originalElementRef.nativeElement) {
                        this.renderer.removeClass(_element, 'visible');
                    }
                });
                event.stopImmediatePropagation();
            }
        }

    }

    /**
     * If user clicks outside, on the tactile block but not in a drawer, we deselect
     * @param {MouseEvent} event
     * @returns {boolean}
     */
    deSelect(event: MouseEvent): boolean {
        if (this._tactileBlockService.selected.filter(item => item === this.tactileBlockItem).length !== 0) {
            const drawer: Element = document.querySelector('.cui-drawer');
            // If drawer exists and user don't click within it
            if (document.body.contains(<Node>event.target) && (drawer && !drawer.contains(<Node>event.target)
                && !DOMHelper.isChildOfElement('.overlay-component', <Node>event.target)
                && !(<HTMLElement>event.target).classList.contains('cui-backdrop')
                && !DOMHelper.isChildOfElement('.cui-action-menu', <Node>event.target)) || !drawer) {
                this._tactileBlockService.selected = [];
                if (!this.elementRef.nativeElement.contains(event.target)) {
                    Array.from(this.elementRef.nativeElement.querySelectorAll(
                        '.hover-item.visible:not(.block-tree-hover-item)'
                    )).forEach((_element) => {
                        this.renderer.removeClass(_element, 'visible');
                    });
                }
                return true;
            }
        }
        return false;
    }

    /**
     * Happens when the user selects.
     */
    triggerSelect(event: MouseEvent): void {
        this.click(event, false);
    }

    /**
     * Overrides KeyboardAccessibility
     * Controls which element that receives key down events
     * @returns {ElementRef}
     */
    keyDownElement(): ElementRef {
        return this.wrapper;
    }

    /**
     * Overrides KeyboardAccessibility
     * If the tactile block is expanded it's considered "canNavigate"
     * @returns {boolean}
     */
    canNavigate(): boolean {
        return this.state === 'expanded';
    }

    /**
     * Overrides KeyboardAccessibility
     */
    openContextMenu(): void {
        if (this.expandable) {
            this.originalElementRef.nativeElement.style.height = null;
            this.state = 'expanded';
        }
    }

    /**
     * Overrides KeyboardAccessibility
     */
    closeContextMenu(): void {
        if (this.collapsable) {
            this.originalElementRef.nativeElement.style.height = null;
            this.state = 'collapsed';
        }
    }

    /**
     * Overrides KeyboardAccessibility.
     * We wander through the action buttons if we tab in a expanded tactile block.
     * If we are on the last button and tabs forward - don't changeIndex & go to next tactile block
     * @param event
     */
    triggerTab(event): void {
        const focusedButton = this.getSelectedElement();
        // we go to next/previous button if there is one or if none is focused already
        if (this.state === 'expanded' && ((!focusedButton && !event.shiftKey) ||
            (focusedButton && !event.shiftKey && focusedButton.nextElementSibling
                && focusedButton.nextElementSibling.classList.contains('cui-button')) ||
            (focusedButton && event.shiftKey && focusedButton.previousElementSibling
                && focusedButton.previousElementSibling.classList.contains('cui-button')))) {
            this.changeIndex(event, !event.shiftKey);
            const selectedElement = this.getSelectedElement();
            if (selectedElement) {
                selectedElement.focus();
            }
        } else {
            this.setElementIndex(-1);
        }
    }

    /**
     * Toggle the state between collapsed or expanded
     */
    toggle(): void {
        if (!this.maximized && !this.originalElementRef.nativeElement.classList.contains('reset-styles')) {
            if (this.collapsable && this.state === 'expanded') {
                this.originalElementRef.nativeElement.style.height = null;
                this.state = 'collapsed';
            } else if (this.expandable && this.state === 'collapsed') {
                this.originalElementRef.nativeElement.style.height = null;
                this.state = 'expanded';
            }
            this._updateLibraryMenuActions();
        }
    }

    /**
     * To add the rule to canvas/drop zone and emit onButtonActionClick event
     * Using stopPropagation so the toggle() action isn't called.
     * @param action
     * @param event
     */
    buttonClick(action: ActionItem, event: Event): void {
        event.stopPropagation();
        const libraryActionEvent = new LibraryActionEvent({ ...action, tactileBlockComponent: this });
        this.onButtonActionClick.emit(libraryActionEvent);
    }

    /**
     * To remove the tactlie block from canvas/drop zone and emit onMenuActionClick event
     * @param {ActionItem}
     */
    menuClick(action: ActionItem): void {
        if (action === this._libraryExpandAction || action === this._libraryCollapseAction) {
            this.toggle();
        } else if (action === this._libraryAddItemAction) {
            const libraryActionEvent = new LibraryActionEvent({ ...action, tactileBlockComponent: this });
            this.onAddItemActionClick.emit(libraryActionEvent);
        } else {
            const libraryActionEvent = new LibraryActionEvent({ ...action, tactileBlockComponent: this });
            this.onMenuActionClick.emit(libraryActionEvent);
        }
    }

    /**
     * To set color code for tactile block if it has color code
     * @returns {string}
     */
    getColorCode(): string {
        if (this.tactileBlockItem.colorCode) {
            return this.tactileBlockItem.colorCode;
        }
        return 'transparent';
    }

    private _updateLibraryMenuActions(): void {
        if (this.tactileBlockItem && this.isInLibrary) {
            this._libraryMenuActions = [].concat(this.tactileBlockItem.libraryMenuActions || []);
            if (!this.maximized) {
                if (this.expandable && this.state === 'collapsed') {
                    this._libraryMenuActions.push(this._libraryExpandAction);
                } else if (this.collapsable && this.state === 'expanded') {
                    this._libraryMenuActions.push(this._libraryCollapseAction);
                }
            }
            this._libraryMenuActions.push(this._libraryAddItemAction);
        } else {
            this._libraryMenuActions = [];
        }
    }
}
