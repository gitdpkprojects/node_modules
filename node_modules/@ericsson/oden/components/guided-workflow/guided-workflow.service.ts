import { ComponentFactoryResolver, ComponentRef, Injectable } from '@angular/core';
import { Subject } from 'rxjs/Subject';
import { Observable } from 'rxjs/Observable';
import { WorkflowGuide } from '../../core/models/workflow-guide.model';
import * as _ from 'lodash';
import { WorkflowGuideStep } from '../../core/models/workflow-guide-step.model';
import { SnackBarComponent } from '../snack-bar/snack-bar.component';
import { SnackBarService } from '../snack-bar/snack-bar.service';
import { ActionItem } from '../../core/models/action-item.model';
import { GUIDED_WORKFLOW } from '../../core/constants/guided-workflow.constants';
import { NavigationEnd, Router } from '@angular/router';
import { GuidedWorkflowComponent } from './guided-workflow.component';
import { OverlayService } from '../overlay/overlay.service';
import { OVERLAY_CONTEXT } from '../overlay/overlay.constants';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../core/classes';

@Injectable()
@UnSub()
export class GuidedWorkflowService {
    breakpoint: number = 80;
    private _onShowSource: Subject<WorkflowGuide> = new Subject();
    private _onHideSource: Subject<WorkflowGuide> = new Subject();
    private _onChangeStepSource: Subject<{guide: WorkflowGuide, goToStep: number}> = new Subject();
    private _onEnterStepSource: Subject<WorkflowGuideStep> = new Subject();
    private _onLeaveStepSource: Subject<WorkflowGuideStep> = new Subject();
    private _onToggleMaximize: Subject<boolean> = new Subject();
    private _guides: Array<WorkflowGuide> = [];
    private _componentRefs: Array<ComponentRef<GuidedWorkflowComponent>> = [];
    private _subscriptions: Array<Subscription> = [];

    public onWorkflowShow$: Observable<WorkflowGuide>;
    public onWorkflowHide$: Observable<WorkflowGuide>;
    public onChangeStep$: Observable<{guide: WorkflowGuide, goToStep: number}>;
    public onEnterStep$: Observable<WorkflowGuideStep>;
    public onLeaveStep$: Observable<WorkflowGuideStep>;
    public onToggleMaximize$: Observable<boolean>;

    public guideModeOn: boolean = false;
    public toggleModeOn: boolean = false;

    componentFactoryResolver: ComponentFactoryResolver;

    get guides(): Array<WorkflowGuide> {
        return this._guides;
    }
    set guides(value: Array<WorkflowGuide>) {
        this._guides = value;
    }

    get guideIsVisible(): boolean {
        return this.guides.filter((_guide: WorkflowGuide) => _guide.visible).length > 0;
    }

    constructor(private _snackBarService: SnackBarService, private _router: Router,
        componentFactoryResolver: ComponentFactoryResolver, private _overlayService: OverlayService) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.onWorkflowShow$ = this._onShowSource.asObservable();
        this.onWorkflowHide$ = this._onHideSource.asObservable();
        this.onChangeStep$ = this._onChangeStepSource.asObservable();
        this.onEnterStep$ = this._onEnterStepSource.asObservable();
        this.onLeaveStep$ = this._onLeaveStepSource.asObservable();
        this.onToggleMaximize$ = this._onToggleMaximize.asObservable();

        // We show/hide guides based on the current URL, this way guides will work when we navigate with
        // brower's back/forward buttons for example
        this._subscriptions.push(this._router.events.subscribe((event) => {
            if ( event instanceof NavigationEnd && this.guideModeOn && !this.toggleModeOn) {
                const guide = this.getVisibleGuide();
                let anotherStepWithThisUrl;
                if (guide) {
                    // is current url corresponding to current active steps path, then everything is fine
                    if (guide.visible && this._router.url === guide.steps[guide.activeStep - 1].path) {
                        this.show(guide.id, guide.activeStep);
                        return;
                    }

                    // check if this page belongs to another step in active guide
                    guide.steps.forEach((step) => {
                        if (this._router.url === step.path) {
                            anotherStepWithThisUrl = step.number;
                        }
                    });
                    if (anotherStepWithThisUrl) {
                        this.changeStep(guide, anotherStepWithThisUrl);
                        return;
                    } else {
                        // check if the page belongs to another non-active guide
                        let thisIsAGuidePage: any;
                        if (!this.toggleModeOn) {
                            this.guides.forEach((_guide: WorkflowGuide) => {
                                _guide.steps.forEach((_step) => {
                                    if (!thisIsAGuidePage && this._router.url === _step.path) {
                                        thisIsAGuidePage = {guide: _guide, number: _step.number};
                                    }
                                });
                            });
                        }
                        // if so, show that guide instead
                        if (thisIsAGuidePage) {
                            this.show(thisIsAGuidePage.guide.id, thisIsAGuidePage.number);
                        } else if (!thisIsAGuidePage) {
                            // if not, hide this guide
                            this.hide(guide.id);
                        }
                    }
                }

                setTimeout(() => {
                    if (!this.toggleModeOn) {
                        // check if the page belongs to another non-active guide
                        let thisIsAGuidePage: any;
                        this.guides.forEach((_guide: WorkflowGuide) => {
                            _guide.steps.forEach((_step) => {
                                if (!thisIsAGuidePage && this._router.url === _step.path) {
                                    thisIsAGuidePage = {guide: _guide, number: _step.number};
                                }
                            });
                        });
                        // if so, show that guide instead
                        if (thisIsAGuidePage && !this.guideIsVisible) {
                            this.show(thisIsAGuidePage.guide.id, thisIsAGuidePage.number);
                        } else if (!thisIsAGuidePage && isNaN(+event.url.substr(event.url.length - 1))) {
                            /* TODO: Right now this doesn't trigger if url ends with a number -> is a dynamic url
                            We need to find a better way of matching dynamic urls with guide urls

                            If this is not a guide page, hide all guides (this will make guideModeOn = false
                            and "inactive" this url detector subscription */
                            this.hideAll();
                        }
                    }
                }, 500);
            }

        }));

    }

    /**
     * Get the current visible guide if there is one
     * @returns {WorkflowGuide}
     */
    getVisibleGuide(): WorkflowGuide {
        const visibleGuide = this.guides.filter((_guide: WorkflowGuide) => _guide.visible);
        return visibleGuide.length ? visibleGuide[0] : null;
    }

    /**
     * Shows the guided workflow and hides other and emits proper events
     * @param {string} guideId
     * @param {number} startAtStep
     */
    show(guideId: string, startAtStep?: number): void {
        this.guideModeOn = true;
        const visibleGuide = this.getVisibleGuide();
        this.toggleModeOn = visibleGuide !== null && visibleGuide.id !== guideId;
        setTimeout(() => {

            // move the guide we want to show to the front of array
            const new_index = 0;
            const old_index = this.guides.indexOf(this.getGuideById(guideId));
            if (new_index >= this.guides.length) {
                let k = new_index - this.guides.length;
                while ((k--) + 1) {
                    this.guides.push(undefined);
                }
            }
            this.guides.splice(new_index, 0, this.guides.splice(old_index, 1)[0]);

            this._guides.forEach((_guide: WorkflowGuide) => {
                if (startAtStep && guideId === _guide.id) {
                    _guide.activeStep = startAtStep;
                }
                if (guideId === _guide.id && !_guide.visible) {
                    if (this.toggleModeOn) {
                        setTimeout(() => {
                            this._onShowSource.next(_guide);
                            this._onEnterStepSource.next(_guide.steps[_guide.activeStep - 1]);
                            _guide.visible = true;
                            this.toggleModeOn = false;
                        }, 500);
                    } else {
                        this._onShowSource.next(_guide);
                        this._onEnterStepSource.next(_guide.steps[_guide.activeStep - 1]);
                        _guide.visible = true;
                    }
                } else if (guideId !== _guide.id && _guide.visible) {
                    this.hide(_guide.id);
                }
                _guide.minimized = false;
                _guide.maximized = false;
                this._onToggleMaximize.next(false);
            });
        }, 500);
    }

    /**
     * Gets the position setting for active/visible guide. Returns 'top' or 'bottom'.
     * @returns {string}
     */
    get position(): string {
        const visibleGuide = this.guides.filter((_guide: WorkflowGuide) => _guide.visible);
        if (visibleGuide.length) {
            return visibleGuide[0].position;
        }
        // we really need a position for everything to work, so if there is no visible guide, grab position from a hidden one
        const hiddenGuide = this.guides.filter((_guide: WorkflowGuide) => !_guide.visible);
        if (hiddenGuide.length) {
            return hiddenGuide[0].position;
        }
        return null;
    }

    /**
     * Gets the current visible guide.
     * @returns {WorkflowGuide}
     */
    getGuideById(guideId: string): WorkflowGuide {
        const guide = this.guides.filter((_guide: WorkflowGuide) => _guide.id === guideId);
        if (guide.length) {
            return guide[0];
        }
        return null;
    }

    /**
     * Change step in the WorkflowGuide and emits proper events
     * @param {WorkflowGuide} guide
     * @param {number} goToNumber
     */
    changeStep(guide: WorkflowGuide, goToNumber: number): void {
        const goToStep = guide.steps[goToNumber - 1];
        if (goToStep && goToStep.locked) {
            const action = new ActionItem({
                label: 'Close',
                action: 'close'
            });
            const message = goToStep.lockedMessage !== '' ? goToStep.lockedMessage : `Step ${goToNumber} is locked.`;
            const snackBar = this.createSnackbar(message, action);
            this._subscriptions.push(snackBar.onAction.subscribe((actionItem) => {
                switch (actionItem.action) {
                    case 'close':
                        snackBar.close();
                        break;
                }
            }));
        } else if (goToStep && guide.activeStep !== goToNumber) {
            this._onLeaveStepSource.next(guide.steps[guide.activeStep - 1]);
            if (guide.activeStep !== goToNumber) {
                this._onEnterStepSource.next(guide.steps[goToNumber - 1]);
            }
            this._onChangeStepSource.next({guide: guide, goToStep: goToNumber});
        }
    }

    /**
     * Creates a snackbar using the SnackbarService but positions it correctly in relation to the guide
     * @param {string} message
     * @param {ActionItem} action
     * @returns {SnackBarComponent}
     */
    createSnackbar(message: string, action?: ActionItem): SnackBarComponent {
        const placeOnTopOfGuide = this.position === GUIDED_WORKFLOW.BOTTOM || !this.position;
        return this._snackBarService.open(message, action,
            placeOnTopOfGuide ? <HTMLElement>document.querySelector('.cui-guided-workflow.active') : null);
    }

    /**
     * Hides the guided workflow
     */
    hide(guideId: string): void {
        const guide = this.guides.filter((_guide: WorkflowGuide) => _guide.id === guideId);
        if (guide.length) {
            guide[0].visible = false;
            guide[0].minimized = false;
            guide[0].maximized = false;
            this._onToggleMaximize.next(false);
            this._onLeaveStepSource.next(guide[0].steps[guide[0].activeStep - 1]);
            this._onHideSource.next(guide[0]);
        }
    }

    /**
     * Hides all guides and set guideModeOn to false
     */
    hideAll(): void {
        this.guideModeOn = false;
        this.guides.forEach((_guide) => {
            if (_guide.visible) {
                this._onHideSource.next(_guide);
            }
            _guide.visible = false;
            _guide.minimized = false;
            _guide.maximized = false;
            this._onToggleMaximize.next(false);
        });
    }

    /**
     * Destroy all guide components!
     */
    destroyAll(): void {
        this.hideAll();
        this._guides = [];
        this._componentRefs.forEach((_componentRef: ComponentRef<GuidedWorkflowComponent>) => {
            _componentRef.destroy();
        });
        this._componentRefs = [];
    }

    /**
     * Toggles the guided workflow visibility
     */
    toggle(guideId: string): void {
        const guide = this.guides.filter((_guide: WorkflowGuide) => _guide.id === guideId);
        if (guide.length) {
            if (guide[0].visible) {
                this.hide(guide[0].id);
            } else {
                this.show(guide[0].id);
            }
        }
    }

    /**
     * Creates a WorkflowGuide object or returns it if it's already registered
     * @param guideObject
     * @returns {WorkflowGuide}
     */
    createGuide(guideObject: any): WorkflowGuide {
        const guide = this.guides.filter((_guide: WorkflowGuide) => _guide.id === guideObject.id);
        if (guide.length) {
            return guide[0];
        }

        // First, make sure the guide steps are ordered by number
        guideObject.steps.sort((a: WorkflowGuideStep, b: WorkflowGuideStep) => {
            if (a.number < b.number) {
                return -1;
            } else if (a.number > b.number) {
                return 1;
            } else {
                return 0;
            }
        });
        const newGuide = new WorkflowGuide(guideObject);
        this._registerGuide(newGuide);
        return newGuide;
    }

    /**
     * Adds a guide to the register (array of guides)
     * @param {WorkflowGuide} guide
     */
    private _registerGuide(guide: WorkflowGuide): void {
        if (this.guides.filter((_guide: WorkflowGuide) => _guide.id === guide.id).length < 1) {
            this._guides.push(guide);
            const factory = this.componentFactoryResolver.resolveComponentFactory(GuidedWorkflowComponent);
            const componentRef = this._overlayService.getOverlay(OVERLAY_CONTEXT.APP).createComponent(factory);
            componentRef.instance.setGuidedWorkflowService(this);
            componentRef.instance.guide = guide;
            this._subscriptions.push(componentRef.instance.onFinishGuideClick.subscribe(() => {
                guide.finishEvent();
            }));
            this._subscriptions.push(componentRef.instance.onGoToStep.subscribe((stepNumber: number) => {
                if (guide.goToEvent) {
                    guide.goToEvent(stepNumber);
                }
            }));
            this._subscriptions.push(componentRef.instance.onPauseTask.subscribe(() => {
                guide.pauseEvent(guide);
            }));
            this._subscriptions.push(componentRef.instance.onWorkflowActionClick.subscribe((actionItem: ActionItem) => {
                guide.actionMenuEvent(actionItem);
            }));
            this._componentRefs.push(componentRef);
        }
    }

    /**
     * Removes a guide from the register (array of guides)
     * @param {string} guideId
     */
    unregisterGuide(guideId: string): void {
        const itemIndex = _.findIndex(this.guides, ['id', guideId]);
        if (itemIndex !== -1) {
            this._guides.splice(itemIndex, 1);
        }
    }

    /**
     * Toggles the guided workflow maximized state
     */
    toggleMaximized(guide: WorkflowGuide): void {
        guide.maximized = !guide.maximized;
        if (guide.maximized) {
            guide.minimized = false;
        }
        this._onToggleMaximize.next(guide.maximized);
    }
}
