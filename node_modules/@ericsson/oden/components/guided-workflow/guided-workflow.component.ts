import {
    AfterViewInit,
    Component,
    ComponentRef,
    ElementRef,
    EventEmitter,
    HostBinding,
    Input,
    OnDestroy,
    OnInit,
    Output,
    Renderer2,
    ViewEncapsulation
} from '@angular/core';
import { WorkflowGuide } from '../../core/models/workflow-guide.model';
import { WorkflowGuideStep } from '../../core/models/workflow-guide-step.model';
import { GuidedWorkflowService } from './guided-workflow.service';
import { ActionItem } from '../../core/models/action-item.model';
import { OverlayService } from '../overlay/overlay.service';
import { DOMHelper } from '../../core/helpers/dom.helper';
import { ANIMATION } from '../../core/constants/animation.constants';
import { animate, state, style, transition, trigger } from '@angular/animations';
import { BackdropComponent } from '../backdrop/backdrop.component';
import { BackdropService } from '../backdrop/backdrop.service';
import { TabViewService } from '../tab-view/tab-view.service';
import { Router } from '@angular/router';
import { GUIDED_WORKFLOW } from '../../core/constants/guided-workflow.constants';
import { LoaderConfig } from '../loader/loader.config';
import AnimationHelper from '../../core/helpers/animation.helper';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../core/classes';
import { NavigationHelper } from '../../core';
import { SIZING } from '../../core/constants';
import { OVERLAY_CONTEXT } from '../overlay/overlay.constants';

@Component({
    selector: 'cui-guided-workflow',
    templateUrl: './guided-workflow.component.html',
    styleUrls: ['./guided-workflow.component.scss'],
    encapsulation: ViewEncapsulation.None,
    animations: [
        trigger('state', [
            state('normal', style({
                height: `${SIZING.GUIDED_WORKFLOW_HEIGHT}px`
            })),
            state('maximized', style({
                height: '*'
            })),
            transition('* => maximized', animate('330ms ' + ANIMATION.EASE_OUT_QUAD)),
            transition('maximized => *', animate('330ms ' + ANIMATION.EASE_OUT_QUAD))
        ])
    ],
})
@UnSub()
export class GuidedWorkflowComponent implements AfterViewInit, OnInit, OnDestroy {
    @HostBinding('class.cui-guided-workflow') addClass: boolean = true;
    @HostBinding('class.active') private _active: boolean = false;
    @HostBinding('@state') get state(): string {
        return this.guide.maximized ? 'maximized' : 'normal';
    }
    @HostBinding('class.maximized') get isMaximized(): boolean {
        return this.guide.maximized;
    }
    @HostBinding('class.trigger-maximize') private _triggerMaximize: boolean = false;
    @HostBinding('class.position-top') get isTop(): boolean {
        return this.guide.position === GUIDED_WORKFLOW.TOP;
    }
    @HostBinding('style.z-index') zIndex: number;
    @HostBinding('style.transform') get _translate() {
        const yPosition = this.getYPosition();
        return `translate(0,${(this.isTop ? '-' : '')}${yPosition}px)`;
    }
    @HostBinding('class.hidden') private _hidden: boolean = true;

    @Output() onWorkflowActionClick: EventEmitter<ActionItem> = new EventEmitter<ActionItem>();
    @Output() onPauseTask: EventEmitter<null> = new EventEmitter<null>();
    @Output() onFinishGuideClick: EventEmitter<null> = new EventEmitter<null>();
    @Output() onGoToStep: EventEmitter<number> = new EventEmitter<number>();
    @Input() guide: WorkflowGuide = new WorkflowGuide();
    @Input() useOverlay: boolean = true;

    minimizedOpacity: number = 0;
    titleYPosition: number = 0;
    buttonYPosition: number = 0;
    overviewLoader: LoaderConfig = new LoaderConfig({});
    overviewLoading: boolean = false;

    private _backdrop: ComponentRef<BackdropComponent>;
    private _onScrollBind: EventListener = this.setCss.bind(this);
    private _guidedWorkflowService: GuidedWorkflowService;
    private _subscriptions: Array<Subscription> = [];
    private _timeout: any;
    get step(): WorkflowGuideStep {
        return this.guide && this.guide.steps.length ? this.guide.steps[this.guide.activeStep - 1] : null;
    }
    get overviewSteps(): Array<WorkflowGuideStep> {
        return this.guide.overviewSteps ? this.guide.overviewSteps : this.guide.steps;
    }
    get columnSize(): number {
        return this.guide.steps.length > 4 ? 3 : Math.floor(12 / this.guide.steps.length);
    }

    constructor(private _renderer: Renderer2, public elementRef: ElementRef, private _router: Router, public overlayService: OverlayService,
                private _backDropService: BackdropService, private _tabViewService: TabViewService) {
    }

    /**
     * Gets called from GuidedWorkflowService when we create a guide.
     * @param {GuidedWorkflowService} _guidedWorkflowService
     */
    setGuidedWorkflowService(_guidedWorkflowService: GuidedWorkflowService): void {
        this._guidedWorkflowService = _guidedWorkflowService;
        this._subscriptions.push(this._guidedWorkflowService.onWorkflowShow$.subscribe((guide: WorkflowGuide) => {
            if (guide.id !== this.guide.id) {
                return null;
            }

            this._hidden = false;
            this._tabViewService.customDirections = true;
            this.setCss();
            DOMHelper.getCuiApplicationContainer().addEventListener('scroll', this._onScrollBind);
            setTimeout(() => {
                this.zIndex = this.overlayService.zIndex;
            }, 100);
            setTimeout(() => {
                this._active = true;
            }, 350);
        }));
        // When workflow guide is hidden, remove listener and backdrop
        this._subscriptions.push(this._guidedWorkflowService.onWorkflowHide$.subscribe((guide: WorkflowGuide) => {
            if (guide.id !== this.guide.id) {
                return null;
            }
            this._tabViewService.customDirections = false;
            this._active = false;
            this.destroyBackdrop();
            DOMHelper.getCuiApplicationContainer().removeEventListener('scroll', this._onScrollBind);
            setTimeout(() => {
                this._hidden = true;
            }, 350);
        }));
        // When a step is changed, call our changeStep function.
        this._subscriptions.push(this._guidedWorkflowService.onChangeStep$.subscribe((obj: any) => {
            if (obj.guide.id !== this.guide.id) {
                return null;
            }
            this.changeStep(obj.goToStep);
        }));
        this._subscriptions.push(this._guidedWorkflowService.onEnterStep$.subscribe(() => {
            setTimeout(() => {
                this.zIndex = this.overlayService.zIndex;
            }, 100);
        }));
        this._subscriptions.push(this._guidedWorkflowService.onToggleMaximize$.subscribe((show: boolean) => {
            if (!show) {
                this.destroyBackdrop();
            }
        }));
    }

    ngOnInit(): void {
        this.overviewLoader.visible = true;
        // add the 'hideall' action as default
        if (!this.guide.actionMenuActions) {
            this.guide.actionMenuActions = [];
        }
    }

    /**
     * Insert the guided workflow at the end of #app on load
     */
    ngAfterViewInit(): void {
        document.getElementById('app').appendChild(this.elementRef.nativeElement);
    }

    /**
     * Emit the action menu click, unless it's the default 'hideall' action, then hide all.
     * @param {ActionItem} action
     */
    actionMenuActionClick(action: ActionItem) {
        if (action.action === 'pausetask') {
            this.onPauseTask.emit();
        } else if (action.action === 'hideall') {
            this._guidedWorkflowService.hideAll();
        } else {
            this.onWorkflowActionClick.emit(action);
        }
    }

    /**
     * Finishes the guide.
     */
    finishGuideClick() {
        this.onFinishGuideClick.emit();
    }

    /**
     * Sets opacity, top position etc based on if we're minimized/maximized etc
     */
    setCss(): void {
        const values = this.getValues();
        const scrollTop = values.scrollTop,
            breakpoint = values.breakpoint,
            multiplier = values.multiplier;

        this.guide.minimized = this.guide.maximized ? false : (scrollTop >= (breakpoint * multiplier));
        this.minimizedOpacity = this.guide.maximized ? 1 :
            (scrollTop > breakpoint ? 0 : (1 - (scrollTop / breakpoint) * 2 * multiplier));

        if (this.isTop) {
            this.buttonYPosition = this.guide.maximized ? 10 :
                (scrollTop >= breakpoint ? 31 : (31 * (scrollTop / breakpoint) * multiplier));
            this.buttonYPosition += this.guide.maximized ? 0 : 10;
            this.titleYPosition = this.guide.maximized ? 0 :
                (scrollTop >= breakpoint ? 45 : (45 * (scrollTop / breakpoint) * multiplier));
        } else {
            this.titleYPosition = this.guide.maximized ? 0 :
                (scrollTop >= breakpoint ? -34 : -(34 * (scrollTop / breakpoint) * multiplier));
            this.buttonYPosition = this.guide.maximized ? 10 :
                (scrollTop >= breakpoint ? -60 : -(60 * (scrollTop / breakpoint) * multiplier));
            this.buttonYPosition += this.guide.maximized ? 0 : 22;
        }

    }

    /**
     * Sets a new guide step as active
     * @param {number} stepNumber
     */
    changeStep(stepNumber: number) {
        if (this.guide.steps[stepNumber - 1]) {

            const direction = (this.guide.activeStep < stepNumber ? 'moveLeft' : 'moveRight');
            this.guide.activeStep = stepNumber;
            const path = this.guide.steps[stepNumber - 1].path;

            if (path) {
                const tabLink = <HTMLElement>document.querySelector(`#tabs-holder [href='${path}']`);
                const wrapper = DOMHelper.getCuiApplicationContainer();
                this._renderer.addClass(wrapper, 'overflow-x-hidden');
                if (tabLink) {
                    const currentIndex = this._tabViewService.currentIndex;
                    const nextIndex = DOMHelper.getNodeIndex(tabLink.parentElement.parentElement);
                    this._tabViewService.setLastIndex();
                    this._tabViewService.setCurrentIndex(nextIndex);
                    this._tabViewService.setAnimations(currentIndex, nextIndex, direction,
                        direction === `moveLeft` ? `moveRight` : `moveLeft`);
                }
                setTimeout(() => {
                    clearTimeout(this._timeout);
                    DOMHelper.scrollTo(document.querySelector('#cui-application'), 0, 200).then(() => {
                        NavigationHelper.navigateToPath(path, this._router);
                        this._timeout = setTimeout(() => {
                            this._renderer.removeClass(wrapper, 'overflow-x-hidden');
                        }, 1000);
                    });
                }, 1);
            }
        } else {
            throw(`Step ${stepNumber} doesn't exist!`);
        }
    }

    /**
     * Calls the service telling it to change step (which then emits an event that triggers the changeStep() above)
     * @param {number} stepNumber
     */
    goToStep(stepNumber: number) {
        this.onGoToStep.emit(stepNumber);
        this._guidedWorkflowService.changeStep(this.guide, stepNumber);
    }

    /**
     * Fetches scrollTop, scrollHeight etc and returns as an object
     * @returns {any}
     */
    getValues(): any {
        const scrollTop = DOMHelper.getCuiApplicationContainer().scrollTop;
        const breakpoint = this._guidedWorkflowService.breakpoint;
        const scrollHeight = DOMHelper.getCuiApplicationContainer().scrollHeight;
        const clientHeight = DOMHelper.getCuiApplicationContainer().clientHeight;
        const diff = scrollHeight - clientHeight;
        let multiplier = 1;
        if (diff > 0 && diff < breakpoint) {
            multiplier = breakpoint / diff;
        }
        return { scrollTop, breakpoint, diff, multiplier };
    }

    /**
     * Destroy the backdrop if there is one.
     */
    destroyBackdrop(): void {
        if (this._backdrop) {
            this._backDropService.remove(this._backdrop, OVERLAY_CONTEXT.APP);
            this._backdrop = null;
        }
    }

    /**
     * Gets how many pixels from the bottom the guided workflow should be, based on scroll position and visibility.
     */
    getYPosition(): number {
        let yPosition: number = SIZING.GUIDED_WORKFLOW_HEIGHT;
        if (this.guide.visible) {
            yPosition = this._guidedWorkflowService.breakpoint;
            if (this.guide.maximized) {
                yPosition = 0;
            } else if (DOMHelper.getCuiApplicationContainer().scrollTop <= this._guidedWorkflowService.breakpoint) {
                const scrollHeight = DOMHelper.getCuiApplicationContainer().scrollHeight;
                const clientHeight = DOMHelper.getCuiApplicationContainer().clientHeight;
                const diff = scrollHeight - clientHeight;
                if (diff > 0 && diff < this._guidedWorkflowService.breakpoint) {
                    yPosition = DOMHelper.getCuiApplicationContainer().scrollTop * (this._guidedWorkflowService.breakpoint / diff);
                } else {
                    yPosition = DOMHelper.getCuiApplicationContainer().scrollTop;
                }
            }
        }
        return yPosition;
    }

    /**
     * Toggles the maximize (aka overlay) mode
     */
    toggleMaximize(): void {
        this._triggerMaximize = true;

        // check if it's maximized and should transition to a minimized state
        if (this.guide.maximized) {
            this.destroyBackdrop();
        } else if (this.useOverlay) {
            this._backdrop = this._backDropService.create(true, OVERLAY_CONTEXT.APP);
            // close backdrop when we click on it
            this._subscriptions.push(this._backdrop.instance.onClose.subscribe(() => this.toggleMaximize()));
            setTimeout(() => {
                this.zIndex = this.overlayService.zIndex;
            });
        }

        let promise = Promise.resolve();
        if (!this.guide.maximized && this.guide.maximizeEvent) {
            this.overviewLoading = true;
            promise = this.guide.maximizeEvent();
        }
        promise.then(() => {
            this.overviewLoading = false;
            this._guidedWorkflowService.toggleMaximized(this.guide);
            setTimeout(() => {
                this.setCss();
            }, 10);
            // reset once the maximization animation is complete
            if (this._triggerMaximize) {
                AnimationHelper.animationCompleted(this.elementRef.nativeElement).then(() => {
                    this._triggerMaximize = false;
                });
            }
        });
    }

    ngOnDestroy(): void {
        DOMHelper.getCuiApplicationContainer().removeEventListener('scroll', this._onScrollBind);
    }
}
