import { Component, ComponentFactoryResolver, ComponentRef, ElementRef, EventEmitter,
    HostBinding, HostListener, Renderer2, ViewChild, ViewContainerRef, ViewEncapsulation } from '@angular/core';
import { Subscription } from 'rxjs';
import { KEYBOARD } from '../../../core/constants/keyboard.constants';
import { ComponentType } from '../../../core/interfaces/component-type.interface';
import { ICustomDialog } from '../../../core/interfaces/custom-dialog.interface';
import { IWindowSize } from '../../../core/interfaces/window-size';
import { ModalActionItem } from '../../../core/models/button-action-item.model';
import { ResizeService } from '../../../core/services';
import { ModalBase } from '../modal-base.class';
import { IModal } from '../modal.interface';
import { DialogConfig } from './dialog.config';
import { DIALOG_TYPE } from './dialog.constants';

@Component({
    selector: 'cui-general-dialog',
    templateUrl: 'dialog.component.html',
    styleUrls: ['dialog.component.scss'],
    encapsulation: ViewEncapsulation.None
})

export class DialogComponent extends ModalBase implements IModal {
    onClose: EventEmitter<DialogComponent> = new EventEmitter<DialogComponent>();
    onOpen: EventEmitter<DialogComponent> = new EventEmitter<DialogComponent>();
    onAction: EventEmitter<ModalActionItem> = new EventEmitter<ModalActionItem>();
    width: string = '416px';
    readonly padding = 16;
    customComponent: any | ICustomDialog;
    callingElement: Element;
    private _subscriptions: Array<Subscription> = [];
    private _config: DialogConfig = new DialogConfig();
    private _widthInPx = true;
    @HostBinding('class.cui-dialog') addClass: boolean = true;
    @HostBinding('class.positioned') addPositionedClass: boolean = false;
    positioned: boolean = false;
    @HostBinding('attr.tabindex') tabIndex: number = 0;
    @HostBinding('style.top') _top: string = '0';
    @HostBinding('style.left') _left: string = '0';
    @HostBinding('style.display') _display: string = 'inherit';
    @ViewChild('content', { read: ViewContainerRef }) content;
    @ViewChild('wrapper') dialogElement: ElementRef;
    _windowSize: IWindowSize;
    constructor (public element: ElementRef, public renderer: Renderer2, public componentFactoryResolver: ComponentFactoryResolver,
        private _resizeService: ResizeService) {
        super(element, renderer);
    }

    private get _type(): DIALOG_TYPE {
        if (this.config.type === undefined) {
            return DIALOG_TYPE.DIALOG;
        } else {
            return this.config.type;
        }
    }

    /**
     * Returns current config
     * @return {DialogConfig}
     */
    public get config(): DialogConfig {
        return this._config;
    }

    /**
     * Sets config for modal. If component property is specified in the config,
     * that component gets injected into the modal.
     *
     * @param config
     */
    public set config(config: DialogConfig) {
        this._config = config;
        if (config.component) {
            this._injectComponent(config.component);
        }
        if (config.width) {
            if (config.width.toString().endsWith('px')) {
                this._widthInPx = true;
            } else {
                this._widthInPx = false;
            }
            this.width = config.width;
        }
    }

    /**
     * Opening and sets css class of dialog type.
     */
    open(): void {
        super.open();
        this.renderer.addClass(this.element.nativeElement, this._getClassOfType());
    }

    /**
     * Injects custom component into dialog.
     * @param componentType
     * @return {ComponentRef<C>|ComponentFixture<T>}
     */
    private _injectComponent<C>(componentType: ComponentType<C>): ComponentRef<C> {
        const factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
        return this.customComponent = this.content.createComponent(factory).instance;
    }

    /**
     * Listens of click event in dialog background. If dialog is of type dialog, the dialog will close
     * @param event
     */
    @HostListener('click', ['$event'])
    click(event: MouseEvent): void {
        if (event.target === this.element.nativeElement && this._type === DIALOG_TYPE.DIALOG) {
            super.close();
        }
    }

    /**
     * Listens to keyboard events and closes the dialog if pressed key is escape.
     */
    @HostListener('document:keyup', ['$event'])
    bindKeyboardShortcuts(event: KeyboardEvent) {
        if (event && event.keyCode === KEYBOARD.ESCAPE && this.open && this._type === DIALOG_TYPE.DIALOG) {
            super.close();
        }
    }
    /**
     * Emits ModalActionItem to the listener
     * @param item
     */
    actionClicked(item: ModalActionItem): void {
        this.onAction.emit(item);
    }
    setPosition() {
        let parentRect: any;
        if (this.callingElement) {
            parentRect = this.callingElement.getBoundingClientRect();
        } else {
            parentRect = this.element.nativeElement.getBoundingClientRect();
        }
        const documentHeight = document.body.clientHeight;
        const documentWidth = document.body.clientWidth;
        let top = parentRect.top;
        let left = parentRect.left;
        const dialogRect = this.dialogElement.nativeElement.getBoundingClientRect();

        const originX = left;
        const originY = top;
        const dialogWidth = Number.parseInt(this.width); // Since its changed in browser, we use a static value
        const dialogHeight = dialogRect.height;
        if ((dialogWidth + this.padding * 2) > documentWidth /* || this._windowSize.size === ScreenSize.SMALL */) {
            this.addPositionedClass = false;
            top = 0;
            left = 0;
            this.backdrop.instance.isHidden = false;
        } else {
            this.backdrop.instance.isHidden = true;
            this.addPositionedClass = true;
            if ((originX + dialogWidth + this.padding) > documentWidth) {
                left = originX - (originX + dialogWidth + this.padding - documentWidth);
            }
            if ((originY + dialogHeight + this.padding) > documentHeight) {
                top = originY - (originY + dialogHeight + this.padding - documentHeight);
                if (top < 0) {
                    top = 0;
                }
            }
        }

        this._top = `${top}px`;
        this._left = `${left}px`;


    }
    setPositioned(positioned: boolean, callingElement: Element) {
        this.positioned = positioned;
        this.callingElement = callingElement;
        if (positioned) {
            this._subscriptions.push(this._resizeService.resize$.subscribe((size) => {
                this._windowSize = size;
                this.setPosition();
            }));
        } else {
            this.backdrop.instance.isHidden = false;
        }
    }

    /**
     * Returns css class corresponding DIALOG_TYPE
     * @return {string} - Css class
     */
    private _getClassOfType(): string {
        let cssClass: string;
        switch (this._type) {
            case DIALOG_TYPE.DIALOG:
                cssClass = 'dialog';
                break;
            case DIALOG_TYPE.MANDATORY:
                cssClass = 'mandatory';
                break;
            case DIALOG_TYPE.SYSTEM_ALERT:
                cssClass = 'system-alert';
                break;
            default:
                cssClass = '';
        }
        return cssClass;
    }

    close() {
        this._subscriptions.forEach((s) => s.unsubscribe());
        super.close();
    }
}
