import { ComponentFactoryResolver, ComponentRef, Injectable, ElementRef } from '@angular/core';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../core/classes';
import { DRAWER_CONTEXT } from '../../core/constants/drawer.constants';
import AnimationHelper from '../../core/helpers/animation.helper';
import { DOMHelper } from '../../core/helpers/dom.helper';
import { ComponentType } from '../../core/interfaces/component-type.interface';
import { BackdropService } from '../backdrop/backdrop.service';
import { DrawerService } from '../drawer/drawer.service';
import { MultiDrawerComponent } from '../drawer/multi-drawer/multi-drawer.component';
import { OVERLAY_CONTEXT } from '../overlay/overlay.constants';
import { OverlayService } from '../overlay/overlay.service';
import { ExternalTaskComponent } from './external-task/external-task.component';
import { FocusShiftBaseComponent } from './focus-shift/focus-shift-base.component';
import { IFocusShift } from './focus-shift/focus-shift.interface';
import { IModal } from './modal.interface';

@Injectable()
@UnSub()
export class ModalService {
    private _modalRefs: ComponentRef<IModal>[] = [];
    private _subscriptions: Array<Subscription> = [];
    constructor (private componentFactoryResolver: ComponentFactoryResolver,
        private _overlayService: OverlayService,
        private _backdropService: BackdropService,
        private _drawerService: DrawerService) {
    }

    /**
     * Creates a modal by the type of your choosing.
     * Adds listeners for onOpen and onClose. The component will be in the DOM after this method,
     * and should be opened directly. The component type should be implementing the IModal interface.
     * See the docs for more
     * @param {ComponentType<C extends IModal>} componentType
     * @param {boolean} visibleBackdrop
     * @returns {ComponentRef}
     */
    create<C extends IModal>(componentType: ComponentType<C>, visibleBackdrop = true): ComponentRef<C> {
        const componentRef = this.createComponent(componentType);
        this.createBackdrop(componentRef, visibleBackdrop);
        return componentRef;
    }

    /**
     * Creates a Focus shift block by the type of your choosing.
     * Adds listeners for onOpen and onClose. The component will be in the DOM after this method,
     * and should be opened directly. The component type should be implementing the IFocusShift interface.
     * @param {ComponentType<C extends IFocusShift>} componentType
     * @param focusShiftBlock
     * @param {string} contextTitle
     * @returns {Promise<ComponentRef<C extends IFocusShift>>}
     */
    createFocusShiftBlockFromComponent<C extends IFocusShift>(componentType: ComponentType<C>,
        focusShiftBlock: { elementRef: ElementRef }, contextTitle?: string): Promise<ComponentRef<C>> {
        return new Promise((resolve) => {
            if (this.instanceOf(componentType, ExternalTaskComponent)) {
                document.querySelector('.cui-systembar').className += ' on-bottom';
            } else {
                document.querySelector('.cui-systembar').className += ' on-top';
            }

            if (!contextTitle) {
                const appContainer = DOMHelper.getCuiApplicationContainer();
                if (appContainer) {
                    const h1: HTMLElement = <HTMLElement>(appContainer.querySelector('.cui-app-header h1'));
                    if (h1) {
                        contextTitle = h1.innerText.trim();
                    }
                }
            }

            focusShiftBlock.elementRef.nativeElement.className += ' becomes-focus-shift';
            const animationHolder = <HTMLElement>document.createElement('div');
            const boundingRect = focusShiftBlock.elementRef.nativeElement.getBoundingClientRect();

            const bgColor = window.getComputedStyle(focusShiftBlock.elementRef.nativeElement).getPropertyValue('background-color');
            const bgHex = DOMHelper.rgb2hex(bgColor);

            const styles = {
                backgroundColor: bgHex,
                top: `${boundingRect.top}px`,
                left: `${boundingRect.left}px`,
                width: window.getComputedStyle(focusShiftBlock.elementRef.nativeElement).getPropertyValue('width'),
                height: window.getComputedStyle(focusShiftBlock.elementRef.nativeElement).getPropertyValue('height'),
                zIndex: this._overlayService.zIndex
            };
            const isLight = DOMHelper.colorIsLight(bgHex);

            Object.assign(animationHolder.style, styles);
            document.getElementById('app').appendChild(animationHolder);
            animationHolder.className += ' focus-shift-animated-bg';

            setTimeout(() => {
                animationHolder.className += ' open';
            }, 100);

            setTimeout(() => {
                const componentRef = this.createComponent(componentType, OVERLAY_CONTEXT.APP);

                // Append "parent title" outside the focus shift block
                if (contextTitle && contextTitle !== '') {
                    const header = <HTMLElement>document.createElement('div');
                    header.className = 'shift-header';
                    if (isLight) {
                        header.className += ' dark';
                    }
                    header.innerHTML = contextTitle;
                    componentRef.instance.element.nativeElement.insertBefore(header,
                        componentRef.instance.element.nativeElement.firstChild);
                }

                // TODO: Check why application breaks unless a setClass function is run.
                componentRef.instance.setClass('focus-shift-block-from-button');
                componentRef.instance.backdrop = this._backdropService.create(false, OVERLAY_CONTEXT.APP);
                animationHolder.style.zIndex = (componentRef.instance.backdrop.instance.zIndex + 1).toString();
                const drawerCreated = this._createFocusShiftDrawer(componentRef.instance).then(() => {
                    setTimeout(() => {
                        componentRef.instance.setClass('visible');
                    }, 100);
                    setTimeout(() => {
                        componentRef.instance.setClass('ready');
                    }, 450);
                    this._subscriptions.push(componentRef.instance.onClose.subscribe(() => {
                        let timeout = 100;
                        if (drawerCreated) {
                            this._drawerService.destroyDrawer(componentRef.instance.drawer);
                            timeout = 300;
                        }
                        this._backdropService.remove(componentRef.instance.backdrop, OVERLAY_CONTEXT.APP);
                        this._removeModal(componentRef, OVERLAY_CONTEXT.APP);
                        setTimeout(() => {
                            // cross browser remove css class function
                            animationHolder.className =
                                animationHolder.className.replace
                                    (/(?:^|\s)open(?!\S)/g, '');
                            // cross browser remove css class function
                            focusShiftBlock.elementRef.nativeElement.className =
                                focusShiftBlock.elementRef.nativeElement.className.replace
                                    (/(?:^|\s)becomes-focus-shift(?!\S)/g, '');
                            AnimationHelper.animationCompleted(animationHolder).then(() => {
                                animationHolder.parentNode.removeChild(animationHolder);
                                // cross browser remove css class function
                                document.querySelector('.cui-systembar').className =
                                    document.querySelector('.cui-systembar').className.replace
                                        (/(?:^|\s)on-top(?!\S)/g, '');
                                document.querySelector('.cui-systembar').className =
                                    document.querySelector('.cui-systembar').className.replace
                                        (/(?:^|\s)on-bottom(?!\S)/g, '');
                            });
                        }, timeout);
                    }));

                    componentRef.instance.open();

                    resolve(componentRef);
                    return;
                });
            }, 350); // Should match the speed of the animation
        });
    }

    /**
     * Creates the components
     * @param componentType
     * @param overlay: OVERLAY_CONTEXT
     * @returns {ComponentRef<C>}
     */
    createComponent<C extends IModal>(componentType: ComponentType<C>,
        overlay: OVERLAY_CONTEXT = OVERLAY_CONTEXT.ROOT): ComponentRef<C> {
        const factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
        const componentRef = this._overlayService.getOverlay(overlay).createComponent(factory);
        this._modalRefs.push(componentRef);
        return componentRef;
    }

    /**
     * Adds listeners to the IModal component which creates and removes backdrop
     * @param componentRef
     * @param visibleBackdrop
     */
    createBackdrop(componentRef: ComponentRef<IModal>, visibleBackdrop = true) {
        this._subscriptions.push(componentRef.instance.onClose.subscribe(() => {
            this._backdropService.remove(componentRef.instance.backdrop);
            this._removeModal(componentRef);
        }));
        this._subscriptions.push(componentRef.instance.onOpen.subscribe(() => {
            componentRef.instance.backdrop = this._backdropService.create(visibleBackdrop);
        }));
    }

    /**
    * Instance of checker to support generic types
    * */
    instanceOf<T, C extends new (...args: any[]) => any>(value: T, clss: C): boolean {
        return <any>value === clss;
    }

    private _createFocusShiftDrawer(focusShiftComponent: FocusShiftBaseComponent | any): Promise<ComponentRef<MultiDrawerComponent>> {
        return new Promise((resolve) => {
            if (focusShiftComponent.drawerTypes.length > 0 || focusShiftComponent.drawerType !== undefined) {
                let drawerTypes = focusShiftComponent.drawerTypes;
                if (!drawerTypes.length) {
                    drawerTypes = [focusShiftComponent.drawerType];
                }
                this._drawerService.createMultiDrawer(focusShiftComponent, drawerTypes,
                    DRAWER_CONTEXT.FOCUS_SHIFT, this.componentFactoryResolver).then((drawerRef: ComponentRef<MultiDrawerComponent>) => {
                        focusShiftComponent.drawer = drawerRef;
                        resolve(drawerRef);
                    });
            } else {
                resolve();
            }
        });
    }
    /**
     * Returns the index of a modal in overlay container ref
     * @returns {number}
     * @private
     * @param componentRef
     * @param overlay
     */
    private _getModalIndex(componentRef: ComponentRef<IModal>, overlay: OVERLAY_CONTEXT = OVERLAY_CONTEXT.ROOT): number {
        return this._overlayService.getOverlay(overlay).indexOf(componentRef.hostView);
    }

    /**
     * Removes modal container ref from overlay container ref.
     * @private
     * @param componentRef
     * @param overlay
     */
    private _removeModal(componentRef: ComponentRef<IModal>, overlay: OVERLAY_CONTEXT = OVERLAY_CONTEXT.ROOT): void {
        componentRef.instance.element.nativeElement.className += ' destroyed';
        AnimationHelper.animationCompleted(componentRef.instance.element.nativeElement).then(() => {
            this._overlayService.getOverlay(overlay).remove(
                this._getModalIndex(componentRef, overlay)
            );

            const index = this._modalRefs.indexOf(componentRef);
            if (index > -1) {
                this._modalRefs.splice(index, 1);
            }
        });
    }
}
