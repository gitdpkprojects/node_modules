import { Observable } from 'rxjs';
import { Subject } from 'rxjs/Subject';
import { LoaderComponent } from '../loader/loader.component';
import { DOMHelper } from '../../core/helpers/dom.helper';
import { Injectable } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';

@Injectable()
export class TabViewService {
    public animationDirection$: Observable<string[]>;

    private _animationSubject: Subject<string[]>;
    private _currentIndex: number = 0;
    private _lastIndex: number = -1;
    private _animations: string[] = [];
    private _loader: LoaderComponent;
    private _removeOverflowTimeout: any;
    public customDirections: boolean = false;
    private _loading: string = '';
    /**
     * Instantiates observables.
     */
    constructor(translate: TranslateService) {
        this._animationSubject = new Subject<string[]>();
        this.animationDirection$ = this._animationSubject.asObservable();

        translate.stream([
            'ODEN.COMMON.LOADING'
        ]).subscribe(res => {
            this._loading = res['ODEN.COMMON.LOADING'];
        });
    }

    /**
     * Sets current index when changing rout. This is called from tab component
     * just before changing route.
     *
     * @param index
     */
    setTabIndex(index: number): void {
        this.setLastIndex();
        this.setCurrentIndex(index);
        if (this._lastIndex > index) {
            this._animations[this._lastIndex] = 'moveRight';
            this._animations[this._currentIndex] = 'moveLeft';
        } else if (this._lastIndex < index) {
            this._animations[this._lastIndex] = 'moveLeft';
            this._animations[this._currentIndex] = 'moveRight';
        } else if (this._lastIndex === index) {
            this._animations[this._lastIndex] = 'moveDown';
            this._animations[this._currentIndex] = 'moveDown';
        }

        // Broadcasts animation directions for all indexes
        this._animationSubject.next(this._animations);
    }

    /**
     * Sets new tab index and loader.
     *
     * @param index{number} Which index to go to
     * @param title{title} Which title the new tab has
     * @param tabsElement{HTMLElement} The tabs component's element
     */
    changeTab(index: number, title?: string, tabsElement?: HTMLElement): void {
        this.setTabIndex(index);
        if (this.loader) {
            this.loader.setText(`${this._loading} ${title}`);
        }

        let tabWrapper: HTMLElement;
        if (!tabsElement) {
            tabWrapper = DOMHelper.getCuiApplicationContainer();
        } else {
            // apply .tabview-wrapper to the element that wraps the tab views
            tabWrapper = DOMHelper.closestParent(tabsElement, 'tabview-wrapper');
            if (!tabWrapper) {
                tabWrapper = DOMHelper.getCuiApplicationContainer();
            }
        }

        clearTimeout(this._removeOverflowTimeout);
        if (!tabWrapper.classList.contains('overflow-x-hidden')) {
            tabWrapper.className += ' added-overflow-x-hidden overflow-x-hidden';
        }

        // remove added-overflow-x-hidden after 1 second when the tabs animation is finished
        // TODO: Maybe check this some other way?
        this._removeOverflowTimeout = setTimeout(() => {
            tabWrapper.className =
                tabWrapper.className.replace
                (/(?:^|\s)added-overflow-x-hidden(?!\S)/g, '');
            tabWrapper.className =
                tabWrapper.className.replace
                (/(?:^|\s)overflow-x-hidden(?!\S)/g, '');
        }, 1500);
    }

    /**
     * Sets last index to current index
     */
    setLastIndex(): void {
        this._lastIndex = this._currentIndex ? this._currentIndex : 0;
    }

    /**
     * Sets current index to number
     */
    setCurrentIndex(index: number): void {
        this._currentIndex = index;
    }

    /**
     * Gets current index
     */
    get currentIndex(): number {
        return this._currentIndex;
    }

    /**
     * Set an animation to current tab
     * @param animation{string}
     */
    setAnimationToCurrentIndex(animation: string): void {
        this._animations[this._currentIndex] = animation;

        // Broadcasts animation directions for all indexes
        this._animationSubject.next(this._animations);
    }

    /**
     * Set animations for lastIndex and currentIndex, then broadcast animation directions
     * @param {number} lastIndex
     * @param {number} currentIndex
     * @param {string} lastAnimation
     * @param {string} currentAnimation
     */
    setAnimations(lastIndex: number, currentIndex: number, lastAnimation: string, currentAnimation: string): void {
        this._animations[lastIndex] = lastAnimation;
        this._animations[currentIndex] = currentAnimation;
        // Broadcasts animation directions for all indexes
        this._animationSubject.next(this._animations);
    }

    setDrillDownAnimation(): void {
        for (let i = 0; i < this._animations.length; i++) {
            this._animations[i] = 'moveDown';
        }
        this._animationSubject.next(this._animations);
    }

    /**
     * Gets the animation name for given index
     * @param {number} index
     * @returns {string}
     */
    getAnimationForIndex(index: number): string {
        let animation = this._animations[index];
        if (!animation) {
            this.setTabIndex(index);
            animation = this._animations[index];
        }
        return animation;
    }

    /**
     * Sets the tabs loader and also makes it colored
     * @param loader
     */
    set loader(loader: LoaderComponent) {
        loader.setAsTabLoader();
        this._loader = loader;
    }

    /**
     * Returns the tabs loader
     * @returns {LoaderComponent}
     */
    get loader(): LoaderComponent {
        return this._loader;
    }
}
