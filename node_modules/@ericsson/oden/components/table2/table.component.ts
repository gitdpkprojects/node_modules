import {
    AfterContentInit,
    AfterViewInit,
    ChangeDetectionStrategy,
    ChangeDetectorRef,
    Component,
    ContentChildren,
    ElementRef,
    forwardRef,
    Input,
    NgZone,
    OnChanges,
    OnDestroy,
    OnInit,
    QueryList,
    Renderer2,
    SimpleChanges,
    TemplateRef,
    ViewChild,
    ViewEncapsulation,
    HostBinding,
    ViewChildren
} from '@angular/core';
import { sum, uniq } from 'lodash';
import { Observable, ReplaySubject, Subject, Subscription } from 'rxjs';
import { first, debounceTime } from 'rxjs/operators';
import { SIZING } from '../../core/constants/sizing.constants';
import { DOMHelper } from '../../core/helpers/dom.helper';
import { UUID } from '../../core/helpers/uuid.class';
import { ResizeService } from '../../core/services';
import { Base } from './../../core/classes/base';
import { HeaderComponent } from './header/header.component';
import { SelectHeaderComponent } from './header/select-header/select-header.component';
import { RowTemplateDirective } from './row-template/row-template.directive';
import { TablePaginationComponent } from './table-pagination/table-pagination.component';
import { NESTED_COLUMN_WIDTH, SELECT_COLUMN_WIDTH, SINGLE_ACTION_COLUMN_WIDTH } from './table.constants';
import { TableHelper, WidthType } from './table.helper';
import { Row2Component } from './table2-row/row.component';
import { TableColumnSetSelectorMenuComponent } from './head/column-set-selector-menu/column-set-selector-menu.component';

@Component({
    selector: 'oden-table',
    templateUrl: './table.component.html',
    styleUrls: ['../table/table.component.scss', './table.component.scss'],
    encapsulation: ViewEncapsulation.None,
    host: { class: 'cui-table' },
    providers: [
        TableHelper,
        { provide: Base, useExisting: forwardRef(() => Table2Component) }
    ],
    changeDetection: ChangeDetectionStrategy.OnPush
})
export class Table2Component
    implements OnInit, AfterContentInit, AfterViewInit, OnDestroy, OnChanges {
    @HostBinding('class.has-hidden-rows')
    private _hasHiddenRows: boolean = false;
    @ContentChildren(forwardRef(() => HeaderComponent))
    _headers: QueryList<HeaderComponent> = new QueryList();
    @ContentChildren(RowTemplateDirective)
    rowTemplatesQueryList: QueryList<RowTemplateDirective>;

    @ContentChildren(SelectHeaderComponent)
    _selectHeaderComponentQueryList: QueryList<SelectHeaderComponent>;
    _selectHeaderComponent: SelectHeaderComponent;
    _selectHeaderComponent$ = new ReplaySubject<SelectHeaderComponent>(null);
    @ContentChildren(TablePaginationComponent)
    _paginationComponentQueryList: QueryList<TablePaginationComponent>;
    @ContentChildren(TableColumnSetSelectorMenuComponent)
    _tableColumnSetSelectorMenuQueryList: QueryList<TableColumnSetSelectorMenuComponent>;
    @ViewChildren(TableColumnSetSelectorMenuComponent)
    _tableColumnSetSelectorMenuViewList: QueryList<TableColumnSetSelectorMenuComponent>;
    @ViewChild('tableElementRef')
    tableElementRef: ElementRef;
    @ContentChildren(forwardRef(() => Row2Component))
    rowComponentsQueryList: QueryList<Row2Component>;
    rowComponents: Array<Row2Component> = [];

    @Input()
    rows: Array<any>;
    @Input()
    addSingleActionColumn = true;

    _displayRows: Array<any> = [];
    private _onRowsChanged$ = new Subject<Array<any>>();
    _onRowsChanged = this._onRowsChanged$.asObservable();
    _isNestedTable = false;
    _hasSingleActionsCell = false;
    _hasIndexCell = false;
    _hasSingleSelectCell = false;
    readonly _tableUuid = UUID.create();
    _stickyTopPosition: number;
    _stickyWidth: number;
    _stickyLeftPosition: number;
    _showStickyTableHeader: boolean = false;
    batchActionsTemplateRef: TemplateRef<any>;
    _numberOfColumnsSets: number = 0;
    _isOverflowing: boolean = false;
    private _scrollAreaElement: HTMLElement;
    private _tabsStickyElement: HTMLElement;
    _tableInitated = false;
    private _columnSetActive: number = 0;
    private _selectChanged: Subscription;
    private _subscriptions: Array<Subscription> = [];
    private _rowInputUUIDs: Array<string>;
    private _selectedStatesChanged$ = new Subject<Array<Row2Component>>();
    private _onNumberOfColumnSetsChanged$ = new Subject<number>();
    private _currentColumnSet$ = new ReplaySubject<number>(0);
    private _headersAsync$ = new ReplaySubject<Array<HeaderComponent>>(null);
    _onColumnOverflow$ = new Subject();
    _onColumnOverflow = this._onColumnOverflow$.asObservable();
    _headersAsync = this._headersAsync$;
    _onHeaderChanged$ = new Subject<HeaderComponent>();
    _currentColumnSet = this._currentColumnSet$.asObservable();
    _onNumberOfColumnSetsChanged = this._onNumberOfColumnSetsChanged$.asObservable();
    private _isNestedTableChanged$ = new ReplaySubject<boolean>(1);
    private _hasSingleActionsCell$ = new ReplaySubject<boolean>(1);
    private _hasSingleSelectCell$ = new ReplaySubject<boolean>(1);
    private _hasIndexCell$ = new ReplaySubject<boolean>(1);
    private _afterRowsChanged$ = new Subject();
    private _afterRowsChanged = this._afterRowsChanged$.asObservable();
    private _tableSetupCompleted$ = new Subject();
    tableSetupCompleted = this._tableSetupCompleted$
        .asObservable()
        .shareReplay();
    private _tableDetectChanges$ = new Subject<null>();
    private _onPaginationChanged$ = new Subject<null>();
    _onPaginationChanged = this._onPaginationChanged$.asObservable();
    private _scrollAreaListener: Function;
    _currentPageRows: Array<Row2Component> = [];
    constructor(
        private _changeDetectorRef: ChangeDetectorRef,
        private _renderer: Renderer2,
        private _resizeService: ResizeService,
        private _ngZone: NgZone
    ) { }
    ngOnInit(): void {
        this._subscriptions.push(
            this._resizeService.resize$.subscribe(() => this._onResize())
        );
    }
    ngOnChanges(changes: SimpleChanges): void {
        if (changes['rows']) {
            this.rowsChanged();
        }
    }
    rowsChanged(): void {
        this._rowInputUUIDs = [];
        if (this.rows) {
            this.rows.forEach((_row, index) => this._rowInputUUIDs[index] = UUID.create());
        }
        this._changeDetectorRef.detectChanges();
    }
    ngAfterContentInit(): void {
        this._setHeaders();
        this._subscriptions.push(
            this._tableDetectChanges$.asObservable().pipe(debounceTime(10)).subscribe(() => { this._changeDetectorRef.detectChanges(); })
        );
        this._subscriptions.push(
            this._headers.changes.subscribe(() => this._setHeaders())
        );
        this._setRowTemplate();
        this._subscriptions.push(
            this.rowTemplatesQueryList.changes.subscribe(() =>
                this._setRowTemplate()
            )
        );
        this._subscriptions.push(
            this.rowComponentsQueryList.changes.subscribe(queryList => {
                this._rowComponentsChanged(
                    queryList || this.rowComponentsQueryList
                );
                this._onRowsChanged$.next();
                this._afterRowsChanged$.next();
            })
        );
        this._setSelectHeaderComponent();
        this._subscriptions.push(
            this._selectHeaderComponentQueryList.changes.subscribe(() =>
                this._setSelectHeaderComponent()
            )
        );
        this._subscriptions.push(
            this._currentColumnSet.subscribe((index: number) => {
                this._columnSetActive = index;
                this._changeDetectorRef.detectChanges();
            })
        );
        this._setActiveColumnSet(0);
    }

    ngAfterViewInit(): void {
        // Wait until rows caulucations are completed and the zone to be stable
        Observable.zip(this._ngZone.onStable, this._afterRowsChanged).pipe(first()).subscribe(() => {
            this._setStickyElements();
            this._setIsNestedTable();
            this._tableInitated = true;
            this._setHasSingleActionsCell();
            this._setHasSingleSelectCell();
            this._setHasIndexCell();
            this._setRowsInitState();
            this._tableSetupCompleted$.next();
            this._changeDetectorRef.detectChanges();
            this._checkColumnOverflow();
            this._checkColumnSetSelectorMenu();
        });
    }
    ngOnDestroy(): void {
        if (this._scrollAreaListener) {
            this._scrollAreaListener();
        }
        if (this._selectChanged) {
            this._selectChanged.unsubscribe();
        }
        this._subscriptions.forEach(subscription => subscription.unsubscribe());
    }

    // Checks rows if any has child rows and emits _isNestedTableChanged$
    _setIsNestedTable(): void {
        if (this.getRootRows().filter(row => row._hasChildRows).length > 0) {
            if (!this._isNestedTable) {
                this._isNestedTable = true;

                this._isNestedTableChanged$.next(true);
            }
        } else if (this._isNestedTable) {
            this._isNestedTable = false;
            this._isNestedTableChanged$.next(false);
        }
        this._changeDetectorRef.detectChanges();
    }

    _setActiveColumnSet(index: number) {
        this._currentColumnSet$.next(index);
    }
    // Sets and emits the current select header which the table and rows should subscribe to
    _setSelectHeaderComponent(): void {
        if (this._selectChanged) {
            this._selectChanged.unsubscribe();
        }
        this._selectHeaderComponent = null;
        if (this._selectHeaderComponentQueryList.first) {
            this._selectHeaderComponent = this._selectHeaderComponentQueryList.first;
            this._selectChanged = this._selectHeaderComponent.onChange.subscribe(
                select => this._setRowsSelectedInCurrentPage(select)
            );
        }
        this._selectHeaderComponent$.next(this._selectHeaderComponent);
    }

    _setRowsInitState(): void {
        this._setRowsSelectedFromChildren();
        this._selectedStatesChanged();
    }

    _selectedStatesChanged(): void {
        this._selectedStatesChanged$.next(this.getSelectedRows());
    }

    getSelectedRows(): Array<Row2Component> {
        return this.rowComponents.filter(row => row._selected);
    }

    _onIsNestedTableChanged(): Observable<boolean> {
        return this._isNestedTableChanged$.asObservable();
    }

    deselectAllRows(): void {
        if (this._selectHeaderComponent) {
            this._setRowsSelected(false);
        }
    }

    // Returns a observable which emits when single action cell is added / removed
    _onHasSingleActionsCellChanged(): Observable<boolean> {
        return this._hasSingleActionsCell$.asObservable();
    }
    _onHasIndexCellChanged(): Observable<boolean> {
        return this._hasIndexCell$.asObservable();
    }

    // Returns a observable which emits when single select cell is added / removed
    _onHasSingleSelectCellChanged(): Observable<boolean> {
        return this._hasSingleSelectCell$.asObservable();
    }

    // Returns a observable when select header is changed
    _onSelectHeaderComponentChange(): Observable<SelectHeaderComponent> {
        return this._selectHeaderComponent$.asObservable();
    }

    // Recursively sets each row and it's children selected and inderminate values based upon it's children
    _setRowsSelectedFromChildren(): void {
        this.getRootRows().forEach(rowComponent => {
            rowComponent._setSelectedFromChildren();
        });
    }

    // Recursively sets each row and it's children selected value based upon argument
    _setRowsSelected(select: boolean): void {
        this.getRootRows().forEach(row => {
            row._setSelectedValue(select);
        });
        this._selectedStatesChanged();
    }

    // Recursively sets each row in current page
    // and it's children selected value based upon argument
    _setRowsSelectedInCurrentPage(select: boolean): void {
        this._currentPageRows.forEach(row => {
            row._setSelectedValue(select);
        });
        this._selectedStatesChanged();
    }

    // Returns an observable that emits when any select state changes
    onSelectedStateChanged(): Observable<Array<Row2Component>> {
        return this._selectedStatesChanged$.asObservable();
    }

    // Triggered from a row when it has been selected in a single-select context
    _singleSelectedStatesChanged(row: Row2Component) {
        this.rowComponents.filter((_row) => _row !== row).forEach((_row) => _row._setSingleSelectedValue(false));
        this._selectedStatesChanged();
    }
    // Returns all rows that aren't child rows
    getRootRows(): Array<Row2Component> {
        return this.rowComponents.filter(
            rowComponent => !rowComponent._isChildRow
        );
    }

    // Get header component from index
    _getHeaderComponent(index: number): HeaderComponent {
        return this._headers.filter(header => header._index === index)[0];
    }

    // Sets index value for all headers
    _setHeaders() {
        this._headers.forEach((header, index) => {
            header._setIndex(index);
        });
        const headers = [];
        this._headers.forEach(h => headers.push(h));
        this._headersAsync$.next(headers);
    }

    // Checks row template
    _setRowTemplate() {
        if (this.rowTemplatesQueryList.length === 0) {
            console.warn('No RowTemplateDirective in <oden-table>');
        }
        if (this.rowTemplatesQueryList.length > 1) {
            console.warn(
                `More than 1 (${
                this.rowTemplatesQueryList.length
                }) RowTemplateDirective in <oden-table>`
            );
        }
    }

    // Trigged when rows QL has been changed to update calculated values based upon rows.
    _rowComponentsChanged(queryList: QueryList<Row2Component>): void {
        this.resetRows(queryList);

        if (this._tableInitated) {
            this._setHasSingleActionsCell();
            this._setIsNestedTable();
            this._selectedStatesChanged();
        }
        this._currentPageRows = this.getRootRows();
        this._onRowComponentsChanged$.next(this.rowComponents);
        this._changeDetectorRef.detectChanges();
    }

    private _onRowComponentsChanged$ = new ReplaySubject<
        Array<Row2Component>
    >(null);
    _onRowComponentsChanged(): Observable<Array<Row2Component>> {
        return this._onRowComponentsChanged$
            .asObservable()
            .filter(value => !!value);
    }
    // Sets all initial data for all rows
    resetRows(queryList: QueryList<Row2Component>): void {
        this.rowComponents = [];
        queryList.forEach(row => row.registerToTable());
    }

    // Checks if any rows has a single action cell
    _setHasSingleActionsCell(): void {
        if (this._tableInitated) {
            const hasSingleActionsCell =
                this.rowComponents.filter(row => row._hasSingleActionsCell)
                    .length > 0;
            if (hasSingleActionsCell !== this._hasSingleActionsCell) {
                this._hasSingleActionsCell = hasSingleActionsCell;
                this._hasSingleActionsCell$.next(this._hasSingleActionsCell);
            }
            this._changeDetectorRef.detectChanges();
        }
    }

    // Checks if any rows has a single action cell
    _setHasSingleSelectCell(): void {
        if (this._tableInitated) {
            const hasSingleSelectCell =
                this.rowComponents.filter(row => row._hasSingleSelectCell)
                    .length > 0;
            if (hasSingleSelectCell !== this._hasSingleSelectCell) {
                this._hasSingleSelectCell = hasSingleSelectCell;
                this._hasSingleSelectCell$.next(this._hasSingleSelectCell);
            }
            this._changeDetectorRef.detectChanges();
        }
    }

    // Checks if any rows has a index cell
    _setHasIndexCell(): void {
        if (this._tableInitated) {
            const hasIndexCell =
                this.rowComponents.filter(row => row._hasIndexCell)
                    .length > 0;
            if (hasIndexCell !== this._hasIndexCell) {
                this._hasIndexCell = hasIndexCell;
                this._hasIndexCell$.next(this._hasIndexCell);
            }
            this._changeDetectorRef.detectChanges();
        }
    }
    // Registers a row to the table component and assigns values to it and its optional parent
    _registerRow(rowComponent: Row2Component): void {
        if (
            rowComponent.rowId &&
            this._getRowComponentById(rowComponent.rowId)
        ) {
            console.warn(
                'Multiple tr[odenRowComponent] with same [rowId]',
                rowComponent.rowId
            );
        }
        const index = this.rowComponents.push(rowComponent) - 1; // Array.push returns the length of the array after push was made
        rowComponent._setIndex(index);
        if (typeof rowComponent.parentId !== 'undefined') {
            // This is should be a child row.

            const parentRowComponent = this._getRowComponentById(
                rowComponent.parentId
            );
            if (parentRowComponent) {
                parentRowComponent._addChildRow(rowComponent);
                rowComponent._setParentRow(parentRowComponent);
                if (this._tableInitated) {
                    this._setIsNestedTable();
                }
            } else {
                console.warn('Could not find parent row for row', {
                    rowId: rowComponent.rowId,
                    parentId: rowComponent.parentId
                });
            }
        }
    }

    _getTableWidth(): number {
        let stickyColumnWidth = 0;
        if (this._isNestedTable) {
            stickyColumnWidth += NESTED_COLUMN_WIDTH;
        }
        if (this._hasSingleActionsCell) {
            stickyColumnWidth += SINGLE_ACTION_COLUMN_WIDTH;
        }
        if (this._selectHeaderComponent) {
            stickyColumnWidth += SELECT_COLUMN_WIDTH;
        }
        const tableWidth: number = this.tableElementRef.nativeElement
            .offsetWidth;
        return tableWidth - stickyColumnWidth;
    }

    _onResize() {
        this._checkColumnOverflow();
        this._setStickyPosition();
        this._changeDetectorRef.detectChanges();
    }

    _checkColumnOverflow() {
        if (!this._headers) {
            return;
        }
        const headersWidthTypes = uniq(
            this._headers.map(header => header._widthType)
        );
        if (
            headersWidthTypes.length > 1 ||
            headersWidthTypes[0] === WidthType.NONE
        ) {
            // TODO RESET
            return; // Cant Overflow.
        }
        const headersWidths = sum(
            this._headers
                .filter(header => !header.hidden)
                .map(header => header._widthAsNumber)
        );
        const stickyHeadersWidths = sum(
            this._headers
                .filter(header => !header.hidden)
                .filter(header => header.sticky)
                .map(header => header._widthAsNumber)
        );
        let overflowing = false;
        if (headersWidthTypes[0] === WidthType.PIXEL) {
            let stickyColumnWidth = 0;

            if (this._isNestedTable) {
                stickyColumnWidth += NESTED_COLUMN_WIDTH;
            }
            if (this._hasSingleActionsCell) {
                stickyColumnWidth += SINGLE_ACTION_COLUMN_WIDTH;
            }
            if (this._selectHeaderComponent) {
                stickyColumnWidth += SELECT_COLUMN_WIDTH;
            }
            const tableWidth: number = this.tableElementRef.nativeElement
                .offsetWidth;
            const usableTableWidth: number = tableWidth - stickyColumnWidth;
            if (headersWidths > usableTableWidth) {
                overflowing = true;
                this._overflowColumns(usableTableWidth, stickyHeadersWidths);
            }
        } else {
            // Width is in percent
            if (headersWidths > 100) {
                overflowing = true;
                this._overflowColumns(100, stickyHeadersWidths);
            }
        }

        if (this._isOverflowing && !overflowing) {
            this._isOverflowing = false;
            this._headers.forEach(header => {
                header._setColumnSet(0);
            });
            this._numberOfColumnsSets = 0;
            this._onNumberOfColumnSetsChanged$.next(0);
            this._setActiveColumnSet(0);
        }
        this._onColumnOverflow$.next();
    }

    private _overflowColumns(max: number, stickyHeadersWidths: number) {
        this._isOverflowing = true;
        let columnSet = 0;
        let columnSetWidth = stickyHeadersWidths;
        this._headers
            .filter(header => !header.hidden)
            .filter(header => !header.sticky)
            .forEach(header => {
                if (
                    columnSetWidth + header._widthAsNumber > max &&
                    columnSetWidth !== stickyHeadersWidths
                ) {
                    columnSet++;
                    columnSetWidth = stickyHeadersWidths;
                }
                header._setColumnSet(columnSet);
                columnSetWidth += header._widthAsNumber;
            });
        if (columnSet !== this._numberOfColumnsSets) {
            this._numberOfColumnsSets = columnSet;
            this._onNumberOfColumnSetsChanged$.next(columnSet);
        }
    }
    detectChanges(): void {
        this._tableDetectChanges$.next();
    }
    // Checks if any rows has a single action cell
    _getRowComponentById(id: any): Row2Component {
        return this.rowComponents.filter(
            rowComponent => rowComponent.rowId === id
        )[0];
    }

    // Checks which element that table should relate to
    _setStickyElements(): void {
        const scrollArea = DOMHelper.closestParent(
            this.tableElementRef.nativeElement,
            'scroll-area'
        );
        this._scrollAreaElement = scrollArea
            ? scrollArea
            : document.getElementById('cui-application');
        if (this._scrollAreaElement) {
            this._tabsStickyElement = <HTMLElement>(
                this._scrollAreaElement.querySelector('.cui-sticky')
            );
            this._scrollAreaListener = this._renderer.listen(
                this._scrollAreaElement,
                'scroll',
                () => {
                    this._setStickyPosition();
                }
            );
        }
    }
    /**
     * Sets table headers and batch actions as sticky when the sticky tabs overlap
     */
    _setStickyPosition(): void {
        if (!this._scrollAreaElement) {
            return;
        }
        let bottomPosition: number;
        let showStickyTableHeader: boolean;
        this._tabsStickyElement = <HTMLElement>(
            this._scrollAreaElement.querySelector('.cui-sticky')
        );
        const tabsStickyRect: ClientRect = this._tabsStickyElement
            ? this._tabsStickyElement.getBoundingClientRect()
            : null;
        if (tabsStickyRect) {
            bottomPosition = tabsStickyRect.top + tabsStickyRect.height;
        } else {
            bottomPosition = SIZING.SYSTEMBAR_HEIGHT;
        }

        const tableRect = (<HTMLElement>(
            this.tableElementRef.nativeElement
        )).getBoundingClientRect();

        if (tableRect.bottom < bottomPosition) {
            // Table is out of bounds
            showStickyTableHeader = false;
        } else if (tableRect.top < bottomPosition) {
            // Table header is above bottomPosition
            showStickyTableHeader = true;
        } else {
            showStickyTableHeader = false;
        }

        if (showStickyTableHeader !== this._showStickyTableHeader) {
            this._showStickyTableHeader = showStickyTableHeader;
            this._changeDetectorRef.detectChanges();
        }
        if (showStickyTableHeader) {
            if (this._stickyTopPosition !== bottomPosition) {
                this._stickyTopPosition = bottomPosition;
                this._changeDetectorRef.detectChanges();
            }
            if (tableRect.width !== this._stickyWidth) {
                this._stickyWidth = tableRect.width;
                this._changeDetectorRef.detectChanges();
            }
            if (tableRect.left !== this._stickyLeftPosition) {
                this._stickyLeftPosition = tableRect.left;
                this._changeDetectorRef.detectChanges();
            }
        }
    }

    // Set batch action template to be displayed in sticky area
    _setBatchActionsTemplate(template: TemplateRef<any>) {
        this.batchActionsTemplateRef = template;
        this._changeDetectorRef.detectChanges();
    }

    // Unset batch action template
    _unsetBatchActionsTemplate() {
        this.batchActionsTemplateRef = null;
    }

    // Change displayRows to match current pagination data
    _paginationChanged(pagination: TablePaginationComponent): void {
        const startIndex = pagination.currentPage * pagination.itemsPerPage;
        let endIndex = startIndex + pagination.itemsPerPage;
        if (endIndex > this.rows.length) {
            endIndex = this.rows.length;
        }
        const displayRows = this.getRootRows()
            .filter(row => !row.hidden)
            .slice(startIndex, endIndex);
        const hiddenRows = this.getRootRows().filter(
            row => displayRows.indexOf(row) === -1
        );
        displayRows.forEach(row => (row._hiddenByPagination = false));
        hiddenRows.forEach(row => (row._hiddenByPagination = true));
        this._currentPageRows = displayRows;
        this._onPaginationChanged$.next();
        this._changeDetectorRef.detectChanges();
    }

    // Clear all header sorting
    _clearHeaderSorting() {
        this._headers.forEach((h) => {
            h._clearSortOrder();
        });
    }
    _ngForTrackByBind = this._ngForTrackBy.bind(this);
    _ngForTrackBy(index: number, _item: any): string {
        if (this._rowInputUUIDs) {
            return this._rowInputUUIDs[index];
        } else {
            return null;
        }
    }

    /**
     * Function to set hide the rows if tpg hide all the table columns
     * @param {Array<HeaderComponent>} selectedColumns
     */
    private _setRowsVisibility(selectedColumns: Array<HeaderComponent>): void {
        this._hasHiddenRows = !(selectedColumns.length > 0);
    }

    /**
     * Function to subscribe event and get the selected columns
     */
    private _checkColumnSetSelectorMenu(): void {
        // If tpg loads <th odenColumnSetSelectorMenu>
        if (this._tableColumnSetSelectorMenuQueryList.first) {
            this._subscriptions.push(
                this._tableColumnSetSelectorMenuQueryList.first.
                    _afterColumnsChanged.subscribe((selectedColumns) =>
                        this._setRowsVisibility(selectedColumns)
                    )
            );
        }
        // If <th odenColumnSetSelectorMenu> loads internally
        if (this._tableColumnSetSelectorMenuViewList.first) {
            this._subscriptions.push(
                this._tableColumnSetSelectorMenuViewList.first.
                    _afterColumnsChanged.subscribe((selectedColumns) =>
                        this._setRowsVisibility(selectedColumns)
                    )
            );
        }
    }
}
