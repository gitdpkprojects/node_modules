import {
    AfterContentInit,
    ChangeDetectionStrategy,
    ChangeDetectorRef,
    Component,
    ContentChild,
    HostBinding,
    Input,
    OnChanges,
    OnInit,
    SimpleChanges,
    OnDestroy,
    Inject,
    forwardRef,
    EventEmitter,
    Output
} from '@angular/core';
import { Observable, Subject, Subscription, BehaviorSubject } from 'rxjs';
import { CELL_ALIGNMENT, ORDER } from '../../../core/constants';
import { TableHelper, WidthType } from '../table.helper';
import { TableHeaderLabelComponent } from './header-label/header-label.component';
import { Table2Component } from '../table.component';
import { ISortEvent } from '../events.interfaces';

@Component({
    // tslint:disable-next-line:component-selector
    selector: 'th[odenHeader]',
    templateUrl: './header.component.html',
    styleUrls: ['./header.component.scss'],
    changeDetection: ChangeDetectionStrategy.OnPush
})
export class HeaderComponent
    implements OnInit, OnChanges, AfterContentInit, OnDestroy {
    @HostBinding('class.align-left')
    _isAlignedLeft = true;
    @HostBinding('class.align-right')
    _isAlignedRight = false;
    @HostBinding('class.align-center')
    _isAlignedCenter = false;
    @Input()
    align: CELL_ALIGNMENT = CELL_ALIGNMENT.LEFT;
    @Input()
    cellWidth: number | string;

    @Input()
    hidden: boolean = false;
    @Input()
    sticky: boolean = false;
    @Input() sortOrder: ORDER;
    _sortOrder: ORDER = ORDER.NONE;

    @Output()
    onSortChange = new EventEmitter<ISortEvent>();

    @HostBinding('style.width')
    _calculatedWidth: string;
    _index: number;
    _columnSet: number = 0;
    _label: string;
    _label$ = new BehaviorSubject<string>(null);
    _labelAsync = this._label$.asObservable();
    _widthType: WidthType = WidthType.NONE;
    _widthAsNumber: number;
    _sortOrderIconClass: string = '';
    private _activeColumnSet = 0;
    @ContentChild(TableHeaderLabelComponent)
    labelComponent: TableHeaderLabelComponent;
    private _alignmentChanged$ = new Subject<CELL_ALIGNMENT>();
    private _subscriptions: Array<Subscription> = [];
    private _overflowSubscriber: Subscription;
    constructor(
        @Inject(forwardRef(() => Table2Component))
        private _table: Table2Component,
        private _changeDetectorRef: ChangeDetectorRef,
        private _tableHelper: TableHelper
    ) { }

    ngOnInit() {
        this._setAlignment();
    }
    ngAfterContentInit(): void {
        if (!this.labelComponent) {
            console.error('No <oden-table-header-label> defined for header');
        } else {
            this._label = this.labelComponent.label;
            this._label$.next(this._label);

            this._subscriptions.push(
                this.labelComponent._onLabelChanged.subscribe(label => {
                    this._label = label;
                    this._label$.next(label);
                })
            );
        }
        this._table.tableSetupCompleted.first().subscribe(() => {
            this._subscriptions.push(
                this._table._currentColumnSet.subscribe((index: number) => {
                    this._activeColumnSet = index;
                    this._calculateWidth();
                })
            );
            /* this._subscriptions.push(
                this._table._onColumnToggle.subscribe(index => {
                    if (index === this._index) {
                        this._isHidden = !this._isHidden;
                        this._calculateWidth();
                    }
                })
            );
            this._subscriptions.push(
                this._table._onStickyToggle.subscribe((index: number) => {
                    if (this._index === index) {
                        this.sticky = !this.sticky;
                        this._calculateWidth();
                        this._table._onHeaderChanged$.next(this);
                    }
                })
            );*/
        });
    }
    ngOnChanges(changes: SimpleChanges): void {
        if (changes['align']) {
            this._setAlignment();
            this._changeDetectorRef.detectChanges();
            this._alignmentChanged$.next(this.align);
        }

        if (changes['cellWidth']) {
            this._widthAsNumber = Number.parseInt(<string>this.cellWidth, 0);
            this._widthType = this._tableHelper.getWidthType(this.cellWidth);
            this._calculatedWidth = this._tableHelper.getWidthAsString(
                this.cellWidth
            );
            if (!changes['cellWidth'].firstChange) {
                this._triggerColumnOverflowCheck();
            }
        }

        if (changes['hidden'] && !changes['hidden'].firstChange) {
            this._triggerColumnOverflowCheck();
        }

        if (changes['sortOrder']) {
            const sortOrder = changes['sortOrder'].currentValue;
            if (this._isSortOrderNone()) {
                this._sortOrder = sortOrder;
                this.updateSorting();
            }
        }
    }

    ngOnDestroy(): void {
        this._subscriptions.forEach(s => s.unsubscribe());
    }

    _onAlignmentChanged(): Observable<CELL_ALIGNMENT> {
        return this._alignmentChanged$.asObservable();
    }
    _setHidden(hidden: boolean): void {
        if (hidden !== this.hidden) {
            this.hidden = hidden;
            this._awaitNextOverflowCheck();
        }
    }
    _setSticky(sticky: boolean): void {
        if (sticky !== this.sticky) {
            this.sticky = sticky;
            this._triggerColumnOverflowCheck();
        }
    }
    _setAlignment(): void {
        this._tableHelper._setAlignmentClass(this.align, this);
    }
    _triggerColumnOverflowCheck(): void {
        this._awaitNextOverflowCheck();
        this._table._checkColumnOverflow();
    }

    _awaitNextOverflowCheck(): void {
        if (!this._overflowSubscriber) {
            this._overflowSubscriber = this._table._onColumnOverflow
                .first()
                .subscribe(() => {
                    this._overflowSubscriber = null;
                    this._calculateWidth();
                });
        }
    }
    _calculateWidth(): void {
        if (this.hidden) {
            this._calculatedWidth = '0px';
        } else if (
            typeof this._columnSet !== 'undefined' &&
            !this.sticky &&
            this._activeColumnSet !== this._columnSet
        ) {
            this._calculatedWidth = '0px';
        } else {
            this._calculatedWidth = this._tableHelper.getWidthAsString(
                this.cellWidth
            );
        }
        this._changeDetectorRef.detectChanges();
    }
    _setColumnSet(index: number) {
        if (index !== this._columnSet) {
            this._columnSet = index;
            this._awaitNextOverflowCheck();
            this._changeDetectorRef.detectChanges();
        }
    }
    _setIndex(index: number): void {
        if (this._index !== index) {
            this._index = index;
            this._changeDetectorRef.detectChanges();
        }
    }

    /**
     * Triggered when user clicks the table header
     */
    _onHeaderClick(): void {
        if (!this.sortOrder || this._isSortOrderNone()) {
            this.onSortChange.emit({ component: this, order: this._sortOrder });
        }
    }

    /**
     * Check the user gives the @input sortOrder is None or not.
     */
    private _isSortOrderNone(): boolean {
        return this.sortOrder !== ORDER.NONE;
    }

    /**
     * Clears sorting on all other headers and updates _sortOrder for this HeaderComponent
     */
    updateSorting(sortOrder = this._sortOrder): void {
        this._table._clearHeaderSorting();
        this._sortOrder = sortOrder;
        this._setOrderIconClass();
    }

    /**
     * Called from Table2Component when the table needs to clear all header sorting
     */
    _clearSortOrder(): void {
        this._sortOrder = ORDER.NONE;
        this._setOrderIconClass();
    }

    /**
     * Sets icon class corresponding current sorting value of header.
     */
    _setOrderIconClass(): void {
        if (this._sortOrder === ORDER.ASCENDING) {
            this._sortOrderIconClass = 'arrow-up';
        } else if (this._sortOrder === ORDER.DESCENDING) {
            this._sortOrderIconClass = 'arrow-down';
        } else {
            this._sortOrderIconClass = '';
        }
        this._changeDetectorRef.detectChanges();
    }
}
