import { Directive, ElementRef, OnDestroy, Renderer2 } from '@angular/core';
import { DraggableService } from '../draggable.service';
import { setInterval } from 'core-js/library/web/timers';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../../core/classes';

@Directive({
    selector: '[cui-autoscroll]'
})
@UnSub()
export class AutoScrollDirective implements OnDestroy {
    private _isDraggingTactileBlock: boolean;
    private _isScrolling: boolean;
    private _scrollingInterval: any;
    private _velocityInterval: any;
    private _velocity: number = 1;
    private _listener: Function;
    private _subscriptions: Array<Subscription> = [];

    constructor(private _elementRef: ElementRef, renderer: Renderer2, draggableService: DraggableService) {
        this._subscriptions.push(draggableService.onStartDrag.subscribe(() => {
            if (_elementRef.nativeElement.scrollHeight > _elementRef.nativeElement.clientHeight) {
                this._isDraggingTactileBlock = true;
            }
        }));
        this._subscriptions.push(draggableService.onStopDrag.subscribe(() => {
            this._isDraggingTactileBlock = false;
            this.stopScrolling();
        }));
        this._listener = renderer.listen(_elementRef.nativeElement, 'mousemove', e => this.update(e));
    }

    ngOnDestroy() {
        this.stopScrolling();
        this._listener();
    }

    /**
     * Controlls if the element should start or stop scrolling in right direction
     */
    update(e: MouseEvent) {
        if (this._isDraggingTactileBlock) {
            const elementTopPosition: number = this._elementRef.nativeElement.getBoundingClientRect().top;
            const elementBottomPosition: number = this._elementRef.nativeElement.getBoundingClientRect().top +
            this._elementRef.nativeElement.clientHeight;

            const distanceToTopEdge: number = e.clientY - elementTopPosition;
            const distanceToBottomEdge: number = elementBottomPosition - e.clientY;

            if (distanceToBottomEdge < 100 && !this._isScrolling) {
                this.startScroll(2);
            } else if (distanceToTopEdge < 100 && !this._isScrolling) {
                this.startScroll(-2);
            } else if (distanceToTopEdge >= 100 && distanceToBottomEdge >= 100 && this._isScrolling) {
                this.stopScrolling();
            }
        }
    }

    /**
     * Sets up interval for velocity and start scrolling
     * @param directionVelocity - Start speed, if positive element scrolls down, if negative element scrolls up
     */
    startScroll(directionVelocity: number = 2) {
        this._isScrolling = true;
        this._velocityInterval = setInterval(() => this._velocity += directionVelocity);
        this._scrollingInterval = setInterval(() => this._elementRef.nativeElement.scrollTop += this._velocity);
    }

    /**
     * Clears all intervals and stop scrolling
     */
    stopScrolling() {
        clearInterval(this._scrollingInterval);
        clearInterval(this._velocityInterval);
        this._isScrolling = false;
        this._velocity = 0;
    }
}
