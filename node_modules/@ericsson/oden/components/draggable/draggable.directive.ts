/* tslint:disable:directive-selector-name */
import { Directive, ElementRef, HostBinding, Input, OnDestroy, Renderer2, HostListener } from '@angular/core';
import { Observable, Subscription } from 'rxjs';
import { DOMHelper } from '../../core/helpers/dom.helper';
import { ICoordinate } from '../../core/interfaces/coordinate.interface';
import AnimationHelper from '../../core/helpers/animation.helper';
import { TactileBlockItem } from '../../core/models/tactile-block-item.model';
import { DropzoneService } from '../dropzone/dropzone.service';
import { MOUSE_BUTTON } from '../../core/constants/mouse-button.constant';
import { SIZING } from '../../core/constants/sizing.constants';
import { DraggableService } from './draggable.service';
import { UnSub } from '../../core/classes';
import { DraggableHelper } from '../../core/helpers/draggable.helper';

const leftMouse = (event: MouseEvent) => event.button === MOUSE_BUTTON.LEFT;

@Directive({
    selector: '[cui-draggable]'
})

@UnSub(500)
export class DraggableDirective implements OnDestroy {
    @Input() draggableConfig: TactileBlockItem = new TactileBlockItem();
    @HostBinding('class.cui-draggable') addClass: boolean = true;
    @HostBinding('class.dragging-enabled') @Input() isDraggable: boolean = true;
    @HostBinding('class.hover') hover: boolean = false;

    private _mouseOffset: ICoordinate = { x: 0, y: 0 };
    private _clone: HTMLElement;
    private _mouseDownEvent: any;
    private _mouseMove$: Observable<any>;
    private _mouseMove: Subscription;
    private _subscriptions: Array<Subscription> = [];
    private _stopDragListener: () => void;

    constructor(private _dropzoneService: DropzoneService,
        public elementRef: ElementRef,
        public renderer: Renderer2,
        private _draggableService: DraggableService) {
        const el = this.elementRef.nativeElement;
        const mouseDown$: Observable<any> = Observable.fromEvent(el, 'mousedown').filter(leftMouse);
        const mouseUp$: Observable<any> = Observable.fromEvent(window, 'mouseup').filter(leftMouse);
        this._mouseMove$ = Observable.fromEvent(document.body, 'mousemove').filter((event: MouseEvent) => event.buttons === 1);

        // Listens for mouse down event, adds delay and if mouse up observable was called the drag observable is
        // canceled.
        const drag$ = mouseDown$.switchMap((e) => Observable.of(e).delay(200).takeUntil(mouseUp$).take(1));

        this._subscriptions.push(mouseDown$.subscribe((event: MouseEvent) => this._mouseDownEvent = event));
        this._subscriptions.push(drag$.subscribe((event: MouseEvent) => this._startDrag(event)));
    }

    @HostListener('mousemove', ['$event'])
    mouseMove(event: MouseEvent): void {
        this.hover = this.isDraggable && DraggableHelper.isDraggableElement(event.target as Element, 'cui-draggable');
    }

    @HostListener('mouseleave')
    mouseLeave(): void {
        this.hover = false;
    }

    /**
     * Starts dragging
     * @private
     */
    private _startDrag(event: MouseEvent): void {
        if (this.isDraggable && DraggableHelper.isDraggableElement(event.target as Element, 'cui-draggable')) {
            this._mouseOffset = DOMHelper.getMousePointerOffset(this._mouseDownEvent, this.elementRef.nativeElement);
            this._dropzoneService.setDraggable(this.elementRef, this.draggableConfig);
            this._draggableService.onStartDrag.emit(event);
            this._mouseMove = this._mouseMove$.subscribe(evt => this._setPosition(<MouseEvent>evt));

            this._cloneElement();
            this._setDraggingStyling();
            this._clone.style.left = `${this._mouseDownEvent.clientX - this._mouseOffset.x}px`;
            this._clone.style.top = `${this._mouseDownEvent.clientY - this._mouseOffset.y}px`;

            if (this._clone.classList.contains('library-block')) {
                if (this._mouseOffset.y > SIZING.TACTILE_BLOCK_HEIGHT) {
                    setTimeout(() => {
                        this._centerDraggableToMouseY();
                    }, 0);
                }
            }
            this._setPosition(event);
            this._stopDragListener = this.renderer.listen('document', 'mouseup', () => { this._stopDrag(); });
        }
    }

    /**
     * Stops dragging
     * @private
     */
    private async _stopDrag(): Promise<void> {
        this._stopDragListener();
        if (this._clone) {
            if (this._mouseMove) {
                this._mouseMove.unsubscribe();
            }
            this._draggableService.onStopDrag.emit();
            let offset: ICoordinate;
            this.renderer.addClass(this._clone, 'released');
            this.renderer.addClass(this.elementRef.nativeElement, 'reset-styles');
            this.renderer.removeClass(this.elementRef.nativeElement, 'currently-dragging');

            // Adds timeout for making sure dropzone has set the acceptedElement in the dropzone service.
            // We're searching the DOM when setting acceptedElement (takes time) so in some cases this method
            // gets triggered before dropzone has set the accepted element.
            setTimeout(async () => {
                if (this._dropzoneService.acceptedElement) {
                    if (this._clone && this._dropzoneService.acceptedElement) {
                        offset = DOMHelper.getElementPageOffset(<HTMLElement>this._dropzoneService.acceptedElement);
                        this._clone.style.width = window.getComputedStyle(this._dropzoneService.acceptedElement).width;
                        this._clone.style.height = window.getComputedStyle(this._dropzoneService.acceptedElement).height;
                        this._clone.style.top = `${offset.y}px`;
                        this._clone.style.left = `${offset.x}px`;
                    }
                } else {
                    offset = DOMHelper.getElementPageOffset(this.elementRef.nativeElement);
                    this._clone.style.top = `${offset.y}px`;
                    this._clone.style.left = `${offset.x}px`;
                }
                await AnimationHelper.animationCompleted(this._clone);
                // Adding delay for not removing an animating everything at the same time (better experience).
                // This need to be change and instead adding a delay to the animationHelper promise.
                // Quick fix for patch release.
                setTimeout(() => {
                    this._removeDraggingStyling();
                    this._removeClonedElement();
                    this._dropzoneService.setDraggable(null);
                }, 100);
            }, 100);
        }
    }

    /**
     * Setts the position of cloned element. Removes the offsets for dragging the
     * element from pointer position, or if we should collapse, from the middle of the element (maxHeight / 2)
     * @param event
     * @private
     */
    private _setPosition(event: MouseEvent): void {
        if (this._clone) {
            this._clone.style.left = `${event.clientX - this._mouseOffset.x}px`;
            const y = this._mouseOffset.y;
            this._clone.style.top = `${event.clientY - y}px`;
        }
    }

    /**
     * Clones the draggable element and injects it into body
     * @private
     */
    private _cloneElement(): void {
        this._clone = this.elementRef.nativeElement.cloneNode(true);
        this._clone.style.position = 'absolute';
        this._clone.style.height = window.getComputedStyle(this.elementRef.nativeElement).height;
        this._clone.style.width = window.getComputedStyle(this.elementRef.nativeElement).width;
        document.body.appendChild(this._clone);
    }

    /**
     * Removes cloned element from body
     * @private
     */
    private _removeClonedElement(): void {
        if (this._clone) {
            document.body.removeChild(this._clone);
            this._clone = null;
        }
    }

    /**
     * Sets dragging class on body and element for correct styling
     * @private
     */
    private _setDraggingStyling(): void {
        if (this._clone) {
            this.renderer.addClass(this._clone, 'clone');
            this.renderer.addClass(this.elementRef.nativeElement, 'currently-dragging');
            // Adds CSS classes in timeouts to trigger CSS animations properly
            setTimeout(() => {
                this.renderer.addClass(this._clone, 'dragging');
            }, 1);
        }
        this.renderer.addClass(document.body, 'dragging');
    }

    /**
     * Removes dragging classes from body and element
     * @private
     */
    private _removeDraggingStyling(): void {
        if (this._clone) {
            this.renderer.removeClass(this._clone, 'dragging');
            this.renderer.removeClass(this._clone, 'clone');
        }
        this.renderer.removeClass(this.elementRef.nativeElement, 'reset-styles');
        this.renderer.removeClass(document.body, 'dragging');
    }

    /**
     * Centers cloned element to the center Y point
     * @private
     */
    private _centerDraggableToMouseY(): void {
        const offsetTop: number = Math.round(this._mouseOffset.y - (SIZING.TACTILE_BLOCK_HEIGHT / 2));
        this._clone.style.transform = `translate(0, ${offsetTop}px)`;
    }

    ngOnDestroy(): void {
        if (this._mouseMove) {
            this._mouseMove.unsubscribe();
        }
    }
}
