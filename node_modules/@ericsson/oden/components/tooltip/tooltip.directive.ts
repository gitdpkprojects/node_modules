import {
    Directive, ElementRef, OnDestroy, HostListener, Input, Renderer2, OnChanges,
    SimpleChanges, TemplateRef, ComponentFactoryResolver, ApplicationRef, Injector, ComponentRef
} from '@angular/core';
import { DOMHelper } from '../../core/helpers/dom.helper';
import AnimationHelper from '../../core/helpers/animation.helper';
import { TooltipTemplateComponent } from './tooltip-template.component';

@Directive({
    selector: '[cui-tooltip],[cuiTooltip]'
})

export class TooltipDirective implements OnDestroy, OnChanges {
    @Input() cuiTooltip: string | TemplateRef<any>;
    @Input() cuiTooltipContext: any;
    @Input() tooltipPosition: string = 'top';
    @Input() tooltipEvent: string = 'hover';
    @Input() cuiTooltipOnOverflow: boolean = false;
    @Input() dynamicCuiTooltipContent: boolean = false;
    @Input() tooltipMaxWidth: string;

    container: HTMLDivElement;
    create_timeout: any;
    delete_timeout: any;

    private _componentRef: ComponentRef<TooltipTemplateComponent>;

    constructor(private _element: ElementRef,
        private _renderer: Renderer2,
        private _resolver: ComponentFactoryResolver,
        private _appRef: ApplicationRef,
        private _injector: Injector) {
    }

    /**
     * Update the tooltip text when it changes. Hide the tooltip if text is empty.
     */
    ngOnChanges(changes: SimpleChanges): void {
        if (this.container && changes['cuiTooltip'] && changes['cuiTooltip'].currentValue !== changes['cuiTooltip'].previousValue) {
            const tooltipText = this.dynamicCuiTooltipContent ? this._element.nativeElement.innerText : this.cuiTooltip;
            const textDiv = this.container.querySelector('.cui-tooltip-text');
            if (textDiv) {
                if (tooltipText && tooltipText.length) {
                    // convert linebreaks to <br /> unless the string already contains HTML
                    textDiv.innerHTML = /<[a-z][\s\S]*>/i.test(tooltipText) ? tooltipText : DOMHelper.nl2br(tooltipText);
                    this.setPosition();
                } else {
                    this.hide();
                }
            }
        }
    }

    /**
     * Create the tooltip on mouseenter. Small timeout to make sure we can move the mouse over multiple tooltip
     * elements without triggering all.
     */
    @HostListener('mouseenter')
    onMouseEnter(): void {
        if (this.tooltipEvent === 'hover') {
            this.create_timeout = setTimeout(() => {
                clearTimeout(this.delete_timeout);
                this.show();
            }, 200);
        }
    }

    /**
     * Hide the tooltip on mouseleave (and cancel the create timeout)
     */
    @HostListener('mouseleave')
    onMouseLeave(): void {
        if (this.tooltipEvent === 'hover') {
            clearTimeout(this.create_timeout);
            this.hide();
        }
    }

    /**
     * Show the tooltip if it's a focus type tooltip and we're focusing.
     */
    @HostListener('focus')
    onFocus(): void {
        if (this.tooltipEvent === 'focus') {
            this.show();
        }
    }

    /**
     * Hide the tooltip if it's a focus type tooltip and we're leaving the element.
     */
    @HostListener('blur')
    onBlur(): void {
        if (this.tooltipEvent === 'focus') {
            this.hide();
        }
    }

    /**
     * Shows the tooltip by creating it, positioning it and then fading it in.
     */
    show(): void {
        // If we should only show the tooltip if content is overflowed, and it's not - then hide and cancel
        if (this.cuiTooltipOnOverflow && !DOMHelper.isOverflowed(this._element.nativeElement)) {
            this.hide();
            return;
        }
        if (!this.cuiTooltip && !this.dynamicCuiTooltipContent) {
            this.hide();
            return;
        }

        this.create().then(() => {
            this.setPosition();
            this._renderer.addClass(this.container, 'active');
        });
    }

    /**
     * Set left and top position based on nativeElements position
     */
    setPosition(): void {
        if (!this.container) {
            return;
        }

        const rect = this._element.nativeElement.getBoundingClientRect();
        const targetTop = rect.top + document.body.scrollTop;
        const targetLeft = rect.left + document.body.scrollLeft;
        const bodyWidth = document.body.offsetWidth;
        const targetBottom = rect.bottom;
        const toolTipWidth = DOMHelper.getOuterWidth(this.container);
        const elementWidth = DOMHelper.getOuterWidth(this._element.nativeElement);
        let top, left;

        // temporary disable transitions when we move container to get 100% correct outerWidth
        // this is only needed if the tooltip is already visible (= has a left position)
        const oldLeft = this.container.style.left;
        if (oldLeft) {
            this._renderer.addClass(this.container, 'no-transition');
            this.container.style.left = '0px';
        }
        switch (this.tooltipPosition) {
            case 'top':
                left = targetLeft - 4;
                // Overwrite left if element width exceeded tooltip max width
                if (elementWidth + 8 >= toolTipWidth) {
                    left = targetLeft + (elementWidth - toolTipWidth) / 2;
                }
                top = targetTop - DOMHelper.getOuterHeight(this.container);
                break;
            case 'top-center':
                left = targetLeft + (elementWidth - toolTipWidth) / 2;
                if (left < 0) {
                    left = 0;
                }
                if (left + elementWidth > bodyWidth) {
                    left = bodyWidth - elementWidth;
                }
                top = targetTop - DOMHelper.getOuterHeight(this.container);
                break;
            case 'bottom':
                left = targetLeft - 4;
                // Overwrite left if element width exceeded tooltip max width
                if (elementWidth + 8 >= toolTipWidth) {
                    left = targetLeft + (elementWidth - toolTipWidth) / 2;
                }
                top = targetBottom;
            break;
        }
        if (oldLeft) {
            this.container.style.left = oldLeft;
            setTimeout(() => {
                this._renderer.removeClass(this.container, 'no-transition');
                this.container.style.left = left + 'px';
                this.container.style.top = top + 'px';
            }, 1);
        } else {
            this.container.style.top = top + 'px';
            this.container.style.left = left + 'px';
        }
    }

    /**
     * Hides the tooltip and removing it from the DOM.
     */
    async hide(): Promise<void> {
        if (!this.container) {
            return;
        }
        this._renderer.removeClass(this.container, 'active');

        await AnimationHelper.animationCompleted(this.container);

        if (this._componentRef) {
            this._appRef.detachView(this._componentRef.hostView);
            this._componentRef.destroy();
            this._componentRef = null;
        }
        if (this.container) {
            document.body.removeChild(this.container);
            this.container = null;
        }
    }

    /**
     * Creates the tooltip as a div element and putting it in the bottom of the body tag.
     */
    create(): Promise<void> {
        // make sure there are no left over tooltips in the dom
        Array.from(document.querySelectorAll('.cui-tooltip-directive')).forEach(element => {
            this._renderer.removeClass(element, 'active');
            setTimeout(() => {
                if (document.body.contains(element)) {
                    document.body.removeChild(element);
                }
            }, 300);
        });

        this.container = document.createElement('div');
        this.container.className = 'cui-tooltip cui-tooltip-directive cui-tooltip-' + this.tooltipPosition;
        this.container.style.maxWidth = this.tooltipMaxWidth;

        return new Promise(done => {
            if (this.cuiTooltip instanceof TemplateRef) {
                this._componentRef = this._resolver.resolveComponentFactory(TooltipTemplateComponent).create(this._injector);
                this._componentRef.instance.template = this.cuiTooltip;
                this._componentRef.instance.context = this.cuiTooltipContext;

                this._appRef.attachView(this._componentRef.hostView);
                this.container.appendChild(this._componentRef.instance.getElement());
                document.body.appendChild(this.container);

                setTimeout(done);
            } else {
                const tooltipTextContainer = document.createElement('div');
                tooltipTextContainer.className = 'cui-tooltip-text';
                const tooltipText = this.dynamicCuiTooltipContent ? this._element.nativeElement.innerText : this.cuiTooltip;
                if (tooltipText && tooltipText.length) {
                    // convert linebreaks to <br /> unless the string already contains HTML
                    tooltipTextContainer.innerHTML = /<[a-z][\s\S]*>/i.test(tooltipText) ? tooltipText : DOMHelper.nl2br(tooltipText);
                    this.container.appendChild(tooltipTextContainer);
                    document.body.appendChild(this.container);
                }
                done();
            }
        });
    }

    /**
     * When we remove the tooltip we also remove it from the document body
     */
    ngOnDestroy(): void {
        if (this.container && this.container.parentElement && document.body.contains(this.container)) {
            document.body.removeChild(this.container);
        }
        this.container = null;
    }
}
