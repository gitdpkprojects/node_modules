/* tslint:disable:no-input-rename */
import {
    AfterViewInit,
    Component,
    ElementRef,
    EventEmitter,
    HostBinding,
    Input,
    OnChanges,
    OnDestroy,
    OnInit,
    Output,
    Renderer2,
    SimpleChanges,
    ViewChild,
    ViewEncapsulation,
    NgZone
} from '@angular/core';
import { Router, NavigationEnd } from '@angular/router';
import { ITabs } from '../../core/interfaces';
import { InkBarComponent } from './ink-bar/inkbar.component';
import { TabViewService } from '../tab-view';
import { DOMHelper } from '../../core/helpers/dom.helper';
import { ITabsItem } from '../../core/interfaces/tabs.interface';
import { SelectComponent } from '../form/select/select.component';
import { UnSub } from '../../core/classes/subscription.decorator';
import { NavigationHelper } from '../../core/helpers/navigation.helper';
import { Subscription } from 'rxjs/Subscription';
import { ResizeService } from '../../core/services/resize.service';
import { first } from 'rxjs/operators';

const DEFAULT_PLACEHOLDER = 'More';

@Component({
    selector: 'cui-tabs',
    templateUrl: 'tabs.component.html',
    styleUrls: ['tabs.component.scss'],
    encapsulation: ViewEncapsulation.None
})
@UnSub()
export class TabsComponent implements OnInit, AfterViewInit, OnDestroy, OnChanges {
    @Input('tabs') tabs: ITabs = [];
    @Input('usePaths') usePaths: boolean = true;
    @Input('color') color: string = '#000';

    @HostBinding('class.cui-tabs') addClass: boolean = true;
    @ViewChild('inkBar') inkBar: InkBarComponent;
    @ViewChild('hiddenTabsDropRef') hiddenTabsDropRef: SelectComponent;
    @ViewChild('tabElementRef') tabElementRef: ElementRef;
    @Output() onTabChange: EventEmitter<ITabsItem> = new EventEmitter<ITabsItem>();

    hiddenTabs: ITabs = [];
    visibleTabs: ITabs = [];
    private _activeTabItem: HTMLElement;
    private _listener;
    private _subscriptions: Array<Subscription> = [];

    get placeholder(): string {
        const activeOption = this.tabs.filter((item) => item.active);
        if (activeOption.length) {
            const isHidden = this.hiddenTabs.indexOf(activeOption[0]);
            if (isHidden > -1) {
                return this.hiddenTabs[isHidden].title;
            }
        }
        return DEFAULT_PLACEHOLDER;
    }

    constructor(private _elementRef: ElementRef,
        private _tabViewService: TabViewService,
        private _router: Router,
        private _renderer: Renderer2,
        private _resizeService: ResizeService,
        private _ngZone: NgZone) {
    }

    /**
     * Sets a default value for the visibleTabs
     */
    ngOnInit(): void {
        this._subscriptions.push(
            // Host listener for window resize event
            this._resizeService.resize$.subscribe(() => {
                this._ngZone.onStable.pipe(first()).subscribe(() => {
                    this.updateInkBar();
                });
            })
        );
        this.visibleTabs = this.tabs;
    }

    /**
     * Tells the ink-bar to align itself to the current selected tab.
     */
    updateInkBar(): void {
        const activeTabElement = this._elementRef.nativeElement.querySelector('li.cui-tab-active');
        this.inkBar.alignToElement(activeTabElement, 16);
    }

    /**
     * Update visibleTabs with current tabs value
     * @param changes
     */
    ngOnChanges(changes: SimpleChanges): void {
        if (changes['tabs'] && changes['tabs'].previousValue !== changes['tabs'].currentValue) {
            this.visibleTabs = changes['tabs'].currentValue;
            if (!this.visibleTabs) {
                this.hiddenTabs = changes['tabs'].currentValue;
            }
        }
    }

    /**
     * Update inkbar and set proper tabIndex on load
     * Small timeout, otherwise we won't get a hit on our querySelector
     */
    ngAfterViewInit(): void {
        Promise.resolve().then(() => {
            this.checkForOverflowedTabs();
        });
        this._listener = this._renderer.listen('window', 'resize', () => {
            this.checkForOverflowedTabs();
        });

        setTimeout(() => {
            this._activeTabItem = this._elementRef.nativeElement.querySelector('li.cui-tab-active');
            if (!this._activeTabItem && this.hiddenTabs.length) {
                const activeOption = this.hiddenTabsDropRef.elementRef.nativeElement.querySelector('.cui-option.active');
                if (activeOption) {
                    this._activeTabItem = this._elementRef.nativeElement.querySelector('li.hidden-tabs');
                }
            }
            if (this._activeTabItem) {
                const index = this.getActiveTabItemIndex();
                if (index > -1) {
                    this._tabViewService.setLastIndex();
                    this._tabViewService.setCurrentIndex(index);
                    this.tabs.forEach((tab) => {
                        tab.active = false;
                    });
                    this.tabs[index].active = true;
                }
            }
            setTimeout(() => {
                this.updateInkBar();
            });
        }, 100);

        // Subscribe to navigation end to update inkbar posision and width
        if (this._router && this._router.events) {
            this._subscriptions.push(
                this._router.events
                    .subscribe((event) => {
                        if (event instanceof NavigationEnd) {
                            this._ngZone.onStable.pipe(first()).subscribe(() => {
                                this.updateInkBar();
                            });
                        }
                    })
            );
        }
    }

    /**
     * Removes querystring params from URL
     * @param url
     */
    formatUrlPattern(url): string {
        return url.split('?')[0];
    }

    getActiveTabItemIndex(): number {
        let currentIndex = DOMHelper.getNodeIndex(this._activeTabItem);
        // if the active tab is in a More-dropdown, the currentIndex is based on selected option in there
        if (this._activeTabItem && this._activeTabItem.classList.contains('hidden-tabs')) {
            let activeOption = this.hiddenTabsDropRef.elementRef.nativeElement.querySelector('.cui-option.active');
            let activeHiddenTabsIndex;
            if (activeOption) {
                activeHiddenTabsIndex = DOMHelper.getNodeIndex(activeOption);
            } else {
                activeOption = this.hiddenTabs.filter((item) => item.active);
                if (activeOption) {
                    activeHiddenTabsIndex = this.hiddenTabs.indexOf(activeOption[0]);
                }
            }
            if (activeHiddenTabsIndex) {
                currentIndex += activeHiddenTabsIndex;
            }
        }
        return currentIndex;
    }

    /**
     * Sets new tab index and tab loader using the tabViewService.
     * Navigates to new url with timeout to make sure all animation properties have been set properly.
     *
     * @param index{number} Which index to go to
     * @param url{string} Which url to go to
     * @param title{title} Which title the new tab has
     */
    changeTab(index: number, url: string, title: string): void {
        if (this.tabs[index].newWindow === true) {
            this.onTabChange.emit(this.tabs[index]);
            this.tabs.forEach((tabItem) => {
                tabItem.active = false;
            });
            window.open(url, '_blank');
        } else {
            this._activeTabItem = this._elementRef.nativeElement.querySelector('.cui-tab-active');
            const currentIndex = this.getActiveTabItemIndex();
            this._tabViewService.setCurrentIndex(currentIndex);
            this._tabViewService.changeTab(index, title, this._elementRef.nativeElement);
            setTimeout(() => {
                this.onTabChange.emit(this.tabs[index]);
            }, 1);

            this.tabs.forEach((tab) => {
                tab.active = false;
            });
            this.tabs[index].active = true;

            if (!this.usePaths) {
                setTimeout(() => {
                    this.updateInkBar();
                });
            } else if (url) {
                // Scroll to top of application when changing routes
                // When scroll is finished, do navigate!
                // This timeout is _crucial_, without it the new animationDirection won't be set for the view about to be destroyed
                setTimeout(() => {
                    DOMHelper.scrollTo(document.querySelector('#cui-application'), 0, 200).then(() => {
                        NavigationHelper.navigateToPath(url, this._router);
                    });
                }, 0);
            }
        }
    }

    /**
     * Toggles the "Hidden tabs" dropdown
     */
    toggleHiddenTabs(): void {
        this.hiddenTabsDropRef.toggleDropdown();
    }

    /**
     * Hides/shows tab based on selected items in the "Hidden tabs" dropdown
     * @param tab
     * @param index
     */
    itemClicked(tab: ITabsItem, index: number): void {
        index += this.visibleTabs.length;
        if (tab.newWindow === true) {
            this.onTabChange.emit(this.tabs[index]);
            this.tabs.forEach((tabItem) => {
                tabItem.active = false;
            });
            window.open(tab.path, '_blank');
        } else {
            this.changeTab(index, tab.path, tab.title);
        }
    }

    /**
     * Checks if the tabs are outside of its wrapper and if so divides the tabs into visible/hidden tabs
     */
    checkForOverflowedTabs(): void {
        this.visibleTabs = this.tabs;
        this.hiddenTabs = [];
        setTimeout(() => {
            const width = (this.tabElementRef.nativeElement.clientWidth +
                this.tabElementRef.nativeElement.getBoundingClientRect().left);
            let index = 0;
            [].forEach.call(this.tabElementRef.nativeElement.querySelectorAll('.tabs-wrapper > ul > li'), (_item) => {
                if (_item.getBoundingClientRect().right < width) {
                    index++;
                }
            });
            if (index < this.tabs.length) {
                index--;
                this.visibleTabs = <ITabs>this.tabs.slice(0, index);
                this.hiddenTabs = <ITabs>this.tabs.slice(index, this.tabs.length);
            }
        }, 10);
    }

    /**
     * Returns true if any tab that's hidden is active
     */
    isHiddenTabActive(): boolean {
        return this.hiddenTabs.filter((item: ITabsItem) => item.active).length > 0;
    }

    ngOnDestroy(): void {
        if (typeof (this._listener) !== 'undefined') {
            this._listener();
        }
    }

}
