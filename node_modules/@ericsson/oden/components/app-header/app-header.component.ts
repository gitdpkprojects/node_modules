import { ObjectHelper } from './../../core/helpers/object.helper';
/* tslint:disable:no-unused-variable */

import {
    AfterViewInit,
    Component,
    EventEmitter,
    HostBinding,
    Input,
    OnChanges,
    OnInit,
    Output,
    Renderer2,
    SimpleChanges,
    ViewChild,
    ViewEncapsulation,
    Optional
} from '@angular/core';
import { ITabs } from '../../core/interfaces';
import { AppHeaderActions } from '../../core/models/app-header-actions.model';
import { ActionItem } from '../../core/models/action-item.model';
import { AppHeaderService } from './app-header.service';
import { BreadcrumbItem } from '../../core/models/breadcrumb.item';
import { EntityVersion } from '../../core/models/entity-version.model';
import { STATE } from '../../core/constants/state.constants';
import { VersionsService } from '../../core/services/versions.service';
import { GuidedWorkflowService } from '../guided-workflow/guided-workflow.service';
import { GUIDED_WORKFLOW } from '../../core/constants/guided-workflow.constants';
import { TabsComponent } from '../tabs/tabs.component';
import { OverlayService } from '../overlay/overlay.service';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../core/classes/subscription.decorator';
import { ApplicationService } from '../../core/services/application.service';
import { StringHelper } from '../../core/helpers/string.helper';
import { ITabsItem } from '../../core/interfaces/tabs.interface';
import { PageService } from '../../core/services/page.service';
import { PAGE_TYPE } from '../../core/constants/page-type.constants';

@Component({
    selector: 'cui-app-header',
    templateUrl: 'app-header.component.html',
    styleUrls: ['app-header.component.scss'],
    providers: [],
    encapsulation: ViewEncapsulation.None
})
@UnSub()
export class AppHeaderComponent implements OnInit, AfterViewInit, OnChanges {
    /**
     *
     * @Input() breadcrumb: Array of objects ({title:string,path:string}) that
     * gets outputted in the left corner of the app header IF it contains > 1 object
     * @Input() title: Name of Application, gets outputted inside an <h1> tag
     * @Input() onCloseApp: When there is no breadcrumb/breadcrumb is only 1 object,
     * a close icon appears in top left corner. When clicked, onCloseApp EventEmitter
     * fires (will typically be a function that closes the app)
     *
     * Your template should look like this.
     *
     * <cui-app-header
     *  [breadcrumb]='[{title:string,path:string}]>'
     *  [title]='string'
     *  (onCloseApp)='function()'></cui-app-header>
     */
    @HostBinding('class.cui-app-header-wrapper') addClass: boolean = true;
    @HostBinding('class.minimized') get isMinimized() {
        return this.guidedWorkflowService.guideIsVisible || this.guidedWorkflowService.toggleModeOn;
    }
    @HostBinding('class.minimized-top') get guideIsPositionTop() {
        return this.isMinimized && this.guidedWorkflowService.position === GUIDED_WORKFLOW.TOP;
    }
    @Input() breadcrumb: Array<BreadcrumbItem>;
    @Input() tabs: ITabs;
    @Input() title: string;
    @Input() entityAcronym: string;
    @Input() entitySubType: string;
    @Input() entityPlaceholder: string;
    @Input() versions: Array<EntityVersion> = [];
    selectedVersion: any;

    @Output() onCloseApp: EventEmitter<null> = new EventEmitter<null>();
    public appHeaderActions: AppHeaderActions;
    public multiButtonActions: Array<ActionItem> = [];
    private _subscriptions: Array<Subscription> = [];
    private pageType: PAGE_TYPE;
    @ViewChild('tabsElement') tabsElement: TabsComponent;

    stickyZIndex: number = 10;
    constructor(private _appHeaderService: AppHeaderService, private _versionsService: VersionsService,
        private _overlayService: OverlayService, private _applicationService: ApplicationService,
        public guidedWorkflowService: GuidedWorkflowService, private _renderer: Renderer2,
        @Optional() private _pageService: PageService) {
        // Listening for actionButtons observable if buttons should be visible in application header
        this._subscriptions.push(_appHeaderService.actionButtons$.subscribe((appHeaderActions) => {
            this.appHeaderActions = appHeaderActions;
            this.multiButtonActions = [];
            for (const key in appHeaderActions) {
                if (appHeaderActions.hasOwnProperty(key)) {
                    if (Array.isArray(appHeaderActions[key])) {
                        appHeaderActions[key].forEach(action => {
                            this.multiButtonActions.push(action);
                        });
                    } else {
                        this.multiButtonActions.push(appHeaderActions[key]);
                    }
                }
            }
            if (this.tabsElement) {
                this.tabsElement.checkForOverflowedTabs();
            }
        }));
        this._subscriptions.push(_appHeaderService.onTitleChange$
            .subscribe((title: string) => {
                this.title = title;
                setTimeout(() => {
                    this.setBodyClass();
                }, 300);
            }));
        this._subscriptions.push(_appHeaderService.onEntityAcronymChange$
            .subscribe((entityAcronym: string) => {
                this.entityAcronym = entityAcronym;
                this.setBodyClass();
            }));
        this._subscriptions.push(_appHeaderService.onEntitySubTypeChange$
            .subscribe((entitySubType: string) => {
                this.entitySubType = entitySubType;
                this.setBodyClass();
            }));
        this._subscriptions.push(_appHeaderService.onEntityPlaceholderChange$
            .subscribe((entityPlaceholder: string) => {
                this.entityPlaceholder = entityPlaceholder;
            }));
        this._subscriptions.push(_versionsService.onVersionsChange$
            .subscribe((versions: Array<EntityVersion>) => this.versions = versions));
        this._subscriptions.push(_appHeaderService.onTabsChange$
            .subscribe((tabs: ITabs) => {
                // check if new tabs are identical to the present ones
                if (this.tabs) {
                    let different: boolean = false;
                    tabs.forEach((tab: ITabsItem, index: number) => {
                        if (this.tabs.length !== tabs.length || !this.tabs[index] || tab.path !== this.tabs[index].path) {
                            different = true;
                        }
                    });
                    if (!different && tabs.length) {
                        return;
                    }
                }
                this.tabs = tabs;
            }));
        this._subscriptions.push(this._overlayService.onZIndexChange$.subscribe((zIndex) => {
            // change zindex so this is always on top, unless a backdrop or 'More' select is visible
            // small timeout to make sure .cui-backdrop is in DOM
            setTimeout(() => {
                if (!document.querySelector('.cui-backdrop') &&
                    !document.querySelector('.cui-app-header-wrapper .select-tab.open')) {
                    this.stickyZIndex = zIndex + 1;
                }
            });
        }));
        /* @deprecated */
        this._subscriptions.push(_appHeaderService.onStickyZIndexChange$.subscribe((zIndex) => {
            this.stickyZIndex = zIndex;
        }));
        if (this._pageService) { // subscribe to page type only if page service is available
            this._pageService.onPageTypeChange$.subscribe(pageType => {
                this.pageType = pageType;
            });
        }
    }

    get showTitle(): boolean {
        return this.title !== undefined && this.title !== '' &&
            (ObjectHelper.size(this.appHeaderActions) > 0 || this.pageType === PAGE_TYPE.ENTITY);
    }

    get getEntityAcronym(): string {
        const crumb = this._applicationService.breadCrumb;
        if (this._appHeaderService.entityAcronym) {
            return this._appHeaderService.entityAcronym;
        } else if (crumb && crumb.length > 0 && (ObjectHelper.size(this.appHeaderActions) > 0 || this.pageType === PAGE_TYPE.ENTITY)) {
            return StringHelper.stringToInitials(crumb[crumb.length - 1].title).toUpperCase();
        }
        return null;
    }

    get getEntitySubType(): boolean {
        return this.entitySubType !== undefined && this.entitySubType !== '' && this.showTitle;
    }

    close(): void {
        this.onCloseApp.emit();
    }

    ngOnInit(): void {
        if (!this.tabs) {
            this.tabs = [];
        } else {
            this._appHeaderService.tabs = this.tabs;
        }

        if (this.title) {
            this._appHeaderService.title = this.title;
        }

        if (this.breadcrumb) {
            this._applicationService.breadCrumb = this.breadcrumb;
        }

        if (this.versions) {
            this._versionsService.versions = this.versions;
        }

    }

    ngOnChanges(changes: SimpleChanges): void {
        if (changes['breadcrumb']) {
            this._applicationService.breadCrumb = changes['breadcrumb'].currentValue;
        }

        if (changes['tabs'] && !changes['tabs'].firstChange) {
            this._appHeaderService.tabs = changes['tabs'].currentValue;
        }
    }

    /**
     * Checks Overflow tabs after view is loaded
     */
    ngAfterViewInit(): void {
        if (this.tabsElement) {
            Promise.resolve().then(() => {
                this.tabsElement.checkForOverflowedTabs();
            });
        }
        this.setBodyClass();
    }

    /**
     * Toggles the 'has-entity-header' body class depending on if title or entityPlaceholder exists.
     */
    setBodyClass(): void {
        if (this.showTitle || this.getEntityAcronym) {
            this._renderer.addClass(document.body, 'has-entity-header');
        } else {
            this._renderer.removeClass(document.body, 'has-entity-header');
        }
    }

    /**
     * returns the selected version
     * @returns {EntityVersion}
     */
    getSelectedVersion(): EntityVersion {
        return this.versions.filter((version) => version.selected)[0];
    }

    /**
     * When a version is changed
     * @param version
     */
    onVersionChange(version: EntityVersion): void {
        this._versionsService.onVersionClick(version);
    }

    /**
     * Returns a presentable string
     * @param version
     * @returns {string}
     */
    getVersionDisplayText(version: EntityVersion): string {
        let displayText = '';
        switch (version.state) {
            case STATE.PUBLISHED:
                displayText = 'Published';
                if (version.label) {
                    displayText = 'Version';
                }
                break;
            case STATE.DRAFT:
                displayText = 'Draft';
                break;
        }
        if (version.label) {
            displayText += ': ' + version.label;
        }
        return displayText;
    }

    /**
     * When a action button is pressed
     * @param actionItem
     */
    actionClick(actionItem: ActionItem): void {
        this._appHeaderService.actionItemClicked(actionItem);
    }
}
