import { OverlayService } from './overlay.service';
import { Injectable } from '@angular/core';
import { OVERLAY_CONTEXT } from './overlay.constants';
import { DOMHelper } from '../../core/helpers/dom.helper';
import { IOverlayable } from './overlayable.interface';

@Injectable()
export class OverlayHelperService {

    private _interval: any;
    resizeListeners: Map<IOverlayable, Function> = new Map<IOverlayable, Function>();
    scrollListeners: Map<IOverlayable, Function> = new Map<IOverlayable, Function>();

    constructor(private _overlayService: OverlayService) {
    }

    /**
     * Moves a elementRef to the overlay. Places is in the same position as the parent elementRef.
     * Sets overlay-component class to the overlay elementRef.
     * @param component: OverlayBase
     * @param overlay: OVERLAY_CONTEXT
     * @param extraClass: Optional parameter, an additional class string that gets applied to '.overlay-component'
     * @return Promise - When done
     */
    appendToOverlay(component: IOverlayable, overlay: OVERLAY_CONTEXT = OVERLAY_CONTEXT.APP, extraClass?: string): Promise<null> {
        return new Promise((resolve) => {
            component.openedInOverlay = true;
            // force ROOT overlay if Universal Overlay or focus shift is visible
            if (document.querySelector('#universal-overlay.open') || document.querySelector('.focus-shift-block')) {
                overlay = OVERLAY_CONTEXT.ROOT;
            }
            const element: HTMLElement = this._overlayService.getOverlay(overlay).element.nativeElement;
            element.insertBefore(component.overlayElement.nativeElement, null);
            this.setNewZIndex(component, overlay);
            const closestScrollArea = DOMHelper.closestParent(component.elementRef.nativeElement, 'scroll-area');
            const scrollArea = closestScrollArea ? closestScrollArea : DOMHelper.getCuiApplicationContainer();
            this.scrollListeners.set(component,
                component.renderer.listen(scrollArea, 'scroll', () => this.setPosition(component, extraClass)));
            this.resizeListeners.set(component,
                component.renderer.listen(window, 'resize', () => this.setPosition(component, extraClass)));

            // If overlay has height 0, set it to equal biggest child to ensure getBoundingClientRect() gets correct
            // Using interval so we can fetch the height as soon as it becomes available in the DOM
            let highestChild: number = 0;
            this._interval = setInterval(() => {
                if (component.overlayElement.nativeElement.offsetHeight < 1 && highestChild < 1) {
                    highestChild = DOMHelper.getHeighestChild(component.overlayElement.nativeElement);
                    if (highestChild > 0) {
                        component.renderer.setStyle(component.overlayElement.nativeElement, 'minHeight', `${highestChild}px`);

                        this.setPosition(component, extraClass);
                        clearInterval(this._interval);
                    }
                } else {
                    clearInterval(this._interval);
                }
            }, 10);

            setTimeout(() => {
                this.setPosition(component, extraClass);
            });
            resolve();
        });
    }

    setNewZIndex(component: IOverlayable, overlay: OVERLAY_CONTEXT): void {
        let zindex;
        if (overlay === OVERLAY_CONTEXT.APP) {
            const appTabWrapper = (<HTMLElement>document.querySelector('.cui-app-header-wrapper > .cui-sticky.sticky'));
            if (appTabWrapper && !document.querySelector('.focus-shift-block')
                && !component.elementRef.nativeElement.classList.contains('select-tab')
                && !DOMHelper.closestParent(component.elementRef.nativeElement, 'cui-app-header-wrapper')) {
                zindex = parseInt(appTabWrapper.style.zIndex, 10) - 1;
            }
        }
        if (zindex === undefined) {
            zindex = this._overlayService.zIndex.toString();
        }
        component.renderer.setStyle(component.overlayElement.nativeElement, 'z-index', zindex);

    }

    /**
     * Positions the overlay inside the viewport. Will change top/left attributes depending on if the overlay
     * is too far down/to the right.
     * @param component: IOverlayable
     * @param extraClass: Optional parameter, an additional class string that gets applied to '.overlay-component'
     */
    setPosition(component: IOverlayable, extraClass?: string): void {
        if (component.setOverlayPosition) {
            component.setOverlayPosition();
        } else {
            const parentRect = component.elementRef.nativeElement.getBoundingClientRect();
            if (!component.overlayElement.nativeElement.classList.contains('overlay-component')) {
                component.renderer.addClass(
                    component.overlayElement.nativeElement,
                    'overlay-component'
                );
                if (extraClass) {
                    component.renderer.addClass(
                        component.overlayElement.nativeElement,
                        extraClass
                    );
                }
            }
            const scrollArea = DOMHelper.closestParent(component.elementRef.nativeElement, 'scroll-area');
            const windowHeight = document.body.offsetHeight;
            const documentWidth = Math.max(document.body.scrollWidth, document.body.offsetWidth,
                document.documentElement.clientWidth, document.documentElement.scrollWidth,
                document.documentElement.offsetWidth);
            let newTop;
            component.overlayElement.nativeElement.style.top = `${parentRect.top}px`;
            let overlayRect = component.overlayElement.nativeElement.getBoundingClientRect();

            if (!scrollArea) {
                // if the overlay is too far down
                if ((overlayRect.bottom + 20) > windowHeight && parentRect.top <= windowHeight) {
                    newTop = overlayRect.top - (overlayRect.bottom - windowHeight + 40);
                    component.overlayElement.nativeElement.style.top = `${newTop}px`;
                }
            } else {
                // to high up in scrollarea?
                if (overlayRect.top < scrollArea.getBoundingClientRect().top &&
                    DOMHelper.checkInView(scrollArea, component.elementRef.nativeElement)) {
                    newTop = scrollArea.getBoundingClientRect().top;
                    component.overlayElement.nativeElement.style.top = `${newTop}px`;
                    component.overlayElement.nativeElement.style.display = 'block';
                } else if (!DOMHelper.checkInView(scrollArea, component.elementRef.nativeElement)) {
                    component.overlayElement.nativeElement.style.display = 'none';
                }
                // to far down in scrollarea?
                overlayRect = component.overlayElement.nativeElement.getBoundingClientRect();
                if ((overlayRect.bottom + 20) > scrollArea.getBoundingClientRect().bottom &&
                    DOMHelper.checkInView(scrollArea, component.elementRef.nativeElement)) {
                    newTop = scrollArea.getBoundingClientRect().bottom - overlayRect.height - 40;
                    component.overlayElement.nativeElement.style.top = `${newTop}px`;
                }
            }

            // if the overlay is too far to the right
            component.overlayElement.nativeElement.style.left = `${parentRect.left}px`;
            overlayRect = component.overlayElement.nativeElement.getBoundingClientRect();
            if (overlayRect.right > documentWidth) {
                const newLeft = overlayRect.left - (overlayRect.right - documentWidth + 20);
                component.overlayElement.nativeElement.style.left = `${newLeft}px`;
            }


        }
    }

    removeFromOverlay(component: IOverlayable): void {
        if (component.openedInOverlay) {
            component.renderer.removeClass(
                component.overlayElement.nativeElement,
                'overlay-component'
            );

            component.openedInOverlay = false;
            const scrollListener = this.scrollListeners.get(component);
            const resizeListener = this.resizeListeners.get(component);
            if (typeof (scrollListener) === 'function') {
                scrollListener(); // Unbinds to any events
            }
            if (typeof (resizeListener) === 'function') {
                resizeListener(); // Unbinds to any events
            }
            component.elementRef.nativeElement.appendChild(component.overlayElement.nativeElement);
            clearInterval(this._interval);
        }
    }
}
