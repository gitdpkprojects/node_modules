import {
    AfterViewInit,
    Component,
    ElementRef,
    HostBinding,
    Input,
    OnDestroy,
    Renderer2,
    ViewEncapsulation
} from '@angular/core';
import { DOMHelper } from '../../core/helpers/dom.helper';
import { LOADER } from './loader.constants';
import { IElementOverlayConfig } from '../../core/interfaces/element-overlay-config.interface';

@Component({
    selector: 'cui-loader',
    templateUrl: './loader.component.html',
    styleUrls: ['./loader.component.scss'],
    encapsulation: ViewEncapsulation.None,
    animations: LOADER.LOADER_ANIMATION
})

export class LoaderComponent implements AfterViewInit, OnDestroy {
    @HostBinding('class.cui-loader') addClass: boolean = true;
    @HostBinding('attr.loaderText') get _loaderText(): string {
        return this.overlayConfig ? this.overlayConfig.text : this.loaderText;
    }
    @HostBinding('@visibility') visibility: string = 'none';
    @Input() visible: boolean = false;
    @Input() overlayConfig: IElementOverlayConfig;
    @Input() loaderText: string;
    isTabLoader: boolean = false;
    _parentElement: HTMLElement;

    constructor(private _element: ElementRef, private _renderer: Renderer2) {
    }

    /**
     * Return the loader's element (used in LoaderDirective)
     * @returns {ElementRef}
     */
    getElement(): ElementRef {
        return this._element;
    }

    /**
     * If we have specified the loader to be visible on load, show it
     */
    ngAfterViewInit(): void {
        setTimeout(() => {
            if (this.visible) {
                this.show();
            }
        }, 100);
    }

    /**
     * Shows the loader and adjusts its size according to its parent.
     * If the loader doesn't cover properly, try setting the parent element
     * to use position: relative;
     * Small timeout used to ensure we get the parentElement's height correctly.
     * Returns true if this call makes it shown or not.
     */
    show(): boolean {
        // Don't bother doing this if it's visible already
        if (this.visibility !== 'none') {
            return false;
        }
        setTimeout(() => {
            if (this.visibility === 'none') {
                let loaderHeight: number;
                let parentHeight: number;
                this._parentElement = this._element.nativeElement.parentElement;
                // Apply position: relative and display: block to parent element
                // This is necessary to avoid having the loader fill up the entire element.
                if (this._parentElement) {
                    this._renderer.addClass(this._parentElement, 'loading-wrapper');
                    if (window.getComputedStyle(this._parentElement).getPropertyValue('display') === 'inline') {
                        this._renderer.addClass(this._parentElement, 'display-block');
                    }
                }
                if (this.isTabLoader) {
                    // Temporarly set all tab views to position relative to calculate heights properly
                    [].map.call(document.querySelectorAll('.tab-view'), (el) => {
                        this._renderer.addClass(el, 'position-relative');
                        parentHeight = DOMHelper.getOuterHeight(el);
                    });
                } else {
                    parentHeight = DOMHelper.getOuterHeight(this._parentElement);
                }
                if (this._parentElement) {
                    if (parentHeight > 0) {
                        loaderHeight = parentHeight;
                    } else {
                        const heighestChild: number = DOMHelper.getHeighestChild(this._parentElement);
                        if (heighestChild > parentHeight) {
                            loaderHeight = heighestChild;
                        }
                    }
                }
                if (loaderHeight > 0) {
                    this.visibility = 'visible-fixed-height';
                    this._renderer.setStyle(this._element.nativeElement, 'height', `${loaderHeight}px`);
                } else {
                    this.visibility = 'visible';
                }
                if (this.isTabLoader) {
                    // Remove the temporary position-relative class from tab views
                    [].map.call(document.querySelectorAll('.tab-view'), (el) => {
                        this._renderer.removeClass(el, 'position-relative');
                    });
                }
            }
        }, 10);
        return true;
    }

    /**
     * Hides the loader
     * Returns true if this call makes it hidden or not.
     */
    hide(): boolean {
        // Don't bother doing this if it's already non-visible
        if (this.visibility === 'none') {
            return false;
        }
        this.visibility = 'none';

        // Remove temporary classes when the WEB animation has finished
        const checkForHideCompletion = setInterval(() => {
            const opacity = window.getComputedStyle(this._element.nativeElement).getPropertyValue('opacity');
            if (opacity === '0' || opacity === '') {
                this._element.nativeElement.style.height = null;
                this._renderer.removeClass(this._parentElement, 'loading-wrapper');
                this._renderer.removeClass(this._parentElement, 'display-block');
                clearInterval(checkForHideCompletion);
            }
        }, 50);
        return true;
    }

    ngOnDestroy(): void {
        this.hide();
    }

    /**
     * Sets the loader to a tab loader (has custom styling)
     */
    setAsTabLoader(): void {
        this.isTabLoader = true;
        this._renderer.addClass(this._element.nativeElement, 'tab-loader');
    }

    /**
     * Set the loader's text to @param text
     * @param text
     */
    setText(text: string): void {
        this.loaderText = text;
    }
}
