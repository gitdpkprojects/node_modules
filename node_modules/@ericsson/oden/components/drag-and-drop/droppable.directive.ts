/* tslint:disable:directive-selector-name */
import {
    Directive, ElementRef, EventEmitter, HostBinding, Input, OnDestroy, OnInit, Output,
    Renderer2
} from '@angular/core';
import { Observable } from 'rxjs';
import { DragAndDropService } from './drag-and-drop.service';
import { DROP_STATE } from '../../core/constants/drop-state.constant';
import { DOMHelper } from '../../core/helpers';
import { UUID } from '../../core/helpers/uuid.class';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../core/classes';

@Directive({
    selector: '[cui-droppable]',
})
@UnSub(50)
export class DroppableDirective implements OnInit, OnDestroy {
    @HostBinding('class.cui-droppable') addClass: boolean = true;
    @HostBinding('class.available') get availableClass() {
        return this._dropState === DROP_STATE.AVAILABLE;
    }
    @HostBinding('class.fully-populated') get fullClass() {
        return this._dropState === DROP_STATE.FULLY_POPULATED;
    }
    @HostBinding('class.engaged') get engagedClass() {
        return this._dropState === DROP_STATE.ENGAGED;
    }
    @HostBinding('class.is-droppable') @Input() isDroppable: boolean = true;

    private _dropState: DROP_STATE = DROP_STATE.IDLE;
    private _subscriptions: Array<Subscription> = [];
    set subscriptions(sub) {
        this._subscriptions.push(sub);
    }

    @Input() limit: number = 0;
    @Input() numberOfItems: number = 0;
    @Input() serviceId: string = 'd-' + UUID.create();

    @Output() onHover: EventEmitter<HTMLElement> = new EventEmitter<HTMLElement>();
    @Output() onLeave: EventEmitter<HTMLElement> = new EventEmitter<HTMLElement>();
    @Output() onDrop: EventEmitter<any> = new EventEmitter<any>();
    @Output() onReject: EventEmitter<any> = new EventEmitter<any>();
    @Output() onDropOutside: EventEmitter<any> = new EventEmitter<any>();

    constructor(
        public elementRef: ElementRef,
        public renderer: Renderer2,
        public dragAndDropService: DragAndDropService
    ) {
        const element = this.elementRef.nativeElement;

        const move$ = Observable.fromEvent(element, 'mousemove');
        const enter$ = Observable.fromEvent(element, 'mouseenter');
        const leave$ = Observable.fromEvent(element, 'mouseleave');
        const up$ = Observable.fromEvent(element, 'mouseup');

        const drop$: Observable<any> = Observable.fromEvent(element, 'mouseup').filter(() => this._dropState === DROP_STATE.ENGAGED);
        const dragOver = enter$.switchMap(() => move$.takeUntil(up$).filter(() => this._dropState !== DROP_STATE.IDLE));
        const dragAway = dragOver.switchMap(() => leave$.takeUntil(up$).take(1));

        // Start drag
        this.subscriptions = this.dragAndDropService.isDragging$.subscribe(isDragging => {
            this._dropState = isDragging ? (this.isFull ? DROP_STATE.FULLY_POPULATED : DROP_STATE.AVAILABLE)
                : DROP_STATE.IDLE;
        });

        this.subscriptions = dragOver.subscribe(() => {
            const engagedInsideArr = Array.from(element.querySelectorAll('.cui-droppable.engaged'));
            if (!engagedInsideArr.length) {
                const doContents = this.dragOverGetContents(element);
                if (!doContents.hasDropElements.length || (doContents.hasDropElements.length
                        && doContents.firstPossibleDropElement)
                        && !element.classList.contains('fully-populated')) {
                    this.setHover(true);
                    if (doContents.firstPossibleDropElement) { // Engaging with a branch -> Auto engage first possible dropelement
                        this.renderer.addClass(doContents.firstPossibleDropElement, 'auto-engaged');
                        this.animatePrevNext(<HTMLElement>doContents.firstPossibleDropElement.previousElementSibling,
                                    <HTMLElement>doContents.firstPossibleDropElement.nextElementSibling);
                    } else if (doContents.engagedDropElement) { // Engaging with an empty dropelement
                        this.animatePrevNext(<HTMLElement>doContents.engagedDropElement.previousElementSibling,
                                    <HTMLElement>doContents.engagedDropElement.nextElementSibling);
                    }
                }
            } else {
                const doContents = this.dragOverGetContents(element);
                this.setHover(false);
                if (doContents.firstPossibleDropElement) {
                    this.renderer.removeClass(doContents.firstPossibleDropElement, 'auto-engaged');
                }
            }
        });

        this.subscriptions = dragAway.subscribe(() => {
            this.removeAllClassesWithName('auto-engaged');
            this.onLeave.emit(this.elementRef.nativeElement);
            if (this._dropState === DROP_STATE.ENGAGED || this._dropState === DROP_STATE.FULLY_POPULATED) {
                this.setHover(false);
                this.clearClones();
            }
        });
        this.subscriptions = drop$.subscribe(() => {
            this.removeAllClassesWithName('auto-engaged');
            this.removeAllClassesWithName('engaged');
            this.setHover(false);
            this.clearClones();

            if (!this.isDroppable || this.isFull) {
                this.onReject.emit(this.dragAndDropService.current.item);
                return;
            }

            if (this.dragAndDropService.current.elementRef.nativeElement !== this.elementRef.nativeElement) {
                // No recursive drops please, Angular can't bend space... yet
                this.onDrop.emit(this.dragAndDropService.current.item);
            }
        });
        this.subscriptions = this.dragAndDropService.onDropOutside$.subscribe(() => {
            this.onDropOutside.emit(this.dragAndDropService.current.item);
        });
    }

    /**
     * Gets items inside an engaged object
     *
     * @param el
     * @returns {{hasDropElements: any[]; firstPossibleDropElement: HTMLElement; engagedDropElement: Element | null}}
     */
    dragOverGetContents(el) {
        const contentChildren = el.querySelector('.content') ? Array.from(el.querySelector('.content').children) : [];
        const hasDropElements = contentChildren.filter((_element: HTMLElement) => {
            return _element && _element.classList.contains('cui-dropelement');
        });
        const firstPossibleDropElements = contentChildren.filter((_element: HTMLElement) => {
            return _element && _element.classList.contains('cui-dropelement') && !_element.classList.contains('disabled');
        });
        const firstPossibleDropElement = firstPossibleDropElements.length ? firstPossibleDropElements[0] : null;
        const engagedDropElement = document.querySelector('.cui-dropelement.visible.engaged:not(.currently-dragging-clone)');

        return {
            hasDropElements: hasDropElements,
            firstPossibleDropElement: <HTMLElement>firstPossibleDropElement,
            engagedDropElement: engagedDropElement
        };
    }

    /**
     * Animates previous and next object of an engaged object
     *
     * @param {HTMLElement} prev
     * @param {HTMLElement} next
     */
    animatePrevNext(prev: HTMLElement, next: HTMLElement): void {
        if (prev) {
            this.renderer.addClass(prev, 'anim-prev');
        }
        if (next) {
            this.renderer.addClass(next, 'anim-next');
        }
    }

    /**
     * Removes all added animations
     */
    clearClones(): void {
        const prev = document.getElementsByClassName('anim-prev')[0];
        const next = document.getElementsByClassName('anim-next')[0];
        if (prev) {
            this.renderer.removeClass(prev, 'anim-prev');
        }
        if (next) {
            this.renderer.removeClass(next, 'anim-next');
        }
    }

    ngOnInit(): void {
        this.dragAndDropService.registerDroppable(this);
    }

    /**
     * Removes className from all elements containing it
     *
     * @param className
     */
    removeAllClassesWithName(className): void {
        Array.from(document.querySelectorAll('.' + className)).forEach((classNameInstance) => {
            this.renderer.removeClass(classNameInstance, className);
        });
    }

    ngOnDestroy(): void {
        this.dragAndDropService.deregisterDroppable(this.serviceId);
    }

    get isFull(): boolean {
        const atLimit = this.limit && this.limit === this.numberOfItems;
        if (this.elementRef.nativeElement.classList.contains('cui-dropelement')) {
            const closestBranch = DOMHelper.closestParent(this.elementRef.nativeElement, 'cui-block-tree-branch');
            const closestTree = DOMHelper.closestParent(this.elementRef.nativeElement, 'cui-block-tree');
            return atLimit &&
                ( closestBranch ? closestBranch.classList.contains('fully-populated') :
                    closestTree && closestTree.classList.contains('fully-populated'));
        }
        return atLimit && this.dragAndDropService.current.elementRef &&
            !this.elementRef.nativeElement.contains(this.dragAndDropService.current.elementRef.nativeElement);
    }

    /**
     * Sets DROP_STATE to ENGAGED while hovering. Emits a boolean for outside listeners
     * @param {boolean} hovering
     */
    setHover(hovering: boolean) {
        if (this.isFull) {
            this._dropState = DROP_STATE.FULLY_POPULATED;
        } else {
           this._dropState = hovering ? DROP_STATE.ENGAGED : DROP_STATE.AVAILABLE;
        }
        if (hovering) {
            this.onHover.emit(this.elementRef.nativeElement);
        }
    }
}
