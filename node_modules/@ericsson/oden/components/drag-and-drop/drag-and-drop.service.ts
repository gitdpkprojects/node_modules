import { ElementRef, EventEmitter, Injectable } from '@angular/core';
import * as _ from 'lodash';

import AnimationHelper from '../../core/helpers/animation.helper';
import { OverlayService } from '../overlay/overlay.service';
import { DraggableData } from './draggable2.directive';
import { DroppableDirective } from './droppable.directive';
import { DOMHelper } from '../../core/helpers/dom.helper';

@Injectable()
export class DragAndDropService {
    private _draggingElementRef: ElementRef;
    private _currentItem: any = null;
    private _isDragging: boolean = false;
    private _clone: HTMLElement = null;
    private _droppables: { [s: string]: DroppableDirective; } = {};
    private _memoizedElement: HTMLElement = null;
    private _memoizedDimensions: Dimensions = null;

    public isDragging$: EventEmitter<boolean> = new EventEmitter<boolean>();
    public onDragStart$: EventEmitter<any> = new EventEmitter<any>();
    public onDragEnd$: EventEmitter<any> = new EventEmitter<any>();
    public onDropOutside$: EventEmitter<any> = new EventEmitter<any>();

    constructor(private _overlayService: OverlayService) {}

    /**
     * Save the result from getComputedStyle so we don't have to
     * recalculate it every single frame
     * @param element
     * @returns {Dimensions}
     */
    getComputedDimensions(element: HTMLElement): Dimensions {
        if (!(element === this._memoizedElement && this._memoizedDimensions)) {
            this._memoizedElement = element;
            const {height, width} = window.getComputedStyle(element);
            this._memoizedDimensions = {height, width};
        }
        return this._memoizedDimensions;
    }

    /**
     * Creates position based on coordinates and a target element
     * @param data
     * @param {HTMLElement} element
     * @returns {Partial<CSSStyleDeclaration>}
     */
    createStyles(data: DraggableData, element: HTMLElement): Partial<CSSStyleDeclaration> {
        if (!data.centerElement) {
            return {
                top: data.y + 'px',
                left: data.x + 'px'
            };
        }
        const { height, width } = this.getComputedDimensions(element);
        const [ heightNumber, widthNumber ] = [height, String(data.width) || width]
            .map(string => Math.round(parseInt(string, 10) / 2));
        return {
            top: data.clientY - heightNumber + 'px',
            left: data.clientX - widthNumber + 'px',
        };
    }

    /**
     * Clones target element and adds a class to it
     * If a clone already exists it updates the coords accordingly
     * @param data
     * @param {ElementRef} element
     * @param item
     */
    setDragItem(data: DraggableData, element: ElementRef, item?: any): void {
        if (!this.isDragging) {
            this._draggingElementRef = element;
            this._currentItem = item;
            this._clone = element.nativeElement.cloneNode(true);
            this._clone.id = null;
            const { height, width } = window.getComputedStyle(element.nativeElement);
            const styles = {
                position: 'absolute',
                width: data.width ? data.width + 'px' : width,
                maxHeight: height,
                margin: '0px',
                zIndex: this._overlayService.highestZindex,
                visibility: 'hidden',
            };
            document.body.appendChild(this._clone);
            this._clone.classList.remove('currently-dragging-clone');
            this._clone.classList.add('currently-dragging');
            Object.assign(this._clone.style, styles);
            const coordStyles = this.createStyles(data, this._clone);
            Object.assign(this._clone.style, coordStyles, { visibility: 'visible' });
            this.isDragging = true;
            this.onDragStart$.emit(this.current);
        } else {
            const coordStyles = this.createStyles(data, this._clone);
            Object.assign(this._clone.style, coordStyles);
        }
    }

    /**
     * Clean up when dragging ends. Removes clones element from the DOM
     */
    dragEnd(droppedOutside?: boolean): void {
        // setting this._isDragging to false here so the onDragEnd$ emits correctly
        this._isDragging = false;

        if (droppedOutside) {
            this.onDropOutside$.emit(this.current);
        } else {
            this.onDragEnd$.emit(this.current);
        }
        const clone = <HTMLElement>document.querySelector('.currently-dragging');
        if (clone) {
            AnimationHelper.animationCompleted(clone).then(() => {
                this._currentItem = null;
                this._draggingElementRef = null;
                this.isDragging = false;
                if (this._clone) {
                    DOMHelper.removeElement(this._clone);
                    this._clone = null;
                }
            });
            setTimeout(() => {
                Array.from(document.querySelectorAll('.currently-dragging')).forEach((currentlyDragging: HTMLElement) => {
                    this._currentItem = null;
                    this._draggingElementRef = null;
                    this.isDragging = false;
                    if (this._clone) {
                        DOMHelper.removeElement(currentlyDragging);
                    }
                });
            }, 1000);
        }
    }

    get current() {
        return {
            item: this._currentItem,
            isDragging: this._isDragging,
            elementRef: this._draggingElementRef,
            clone: this._clone
        };
    }

    get isDragging() {
        return this._isDragging;
    }

    /**
     * Sets the private _isDragging to value and emits it with isDragging$
     * @param {boolean} value
     */
    set isDragging(value: boolean) {
        this._isDragging = value;
        this.isDragging$.emit(value);
    }

    /**
     * Registers a DroppableDirective which can looked up later
     * @param {DroppableDirective} droppable
     */
    registerDroppable(droppable: DroppableDirective) {
        if (!this._droppables[droppable.serviceId]) {
            this._droppables[droppable.serviceId] = droppable;
        }
    }

    /**
     * Remove reference to a registered DroppableDirective
     * @param {string} id
     */
    deregisterDroppable(id: string) {
        if (this._droppables[id]) {
            delete this._droppables[id];
        }
    }

    /**
     * Finds a DroppableDirective from the registered ones based on id
     * @param {string} id
     * @returns {DroppableDirective}
     */
    findDroppable(id: string): DroppableDirective {
        return this._droppables[id];
    }

    /**
     * Finds the correct DroppableDirective by using ugly lookups to preserve backwards compatibility
     * @deprecated If you use this you better have a very good reason
     * @param {ElementRef} droppable
     */
    findDroppableByDeprecatedHackDoNotUse(droppable: ElementRef) {
        return _.find(this._droppables,
                _droppable => _droppable.elementRef.nativeElement.parentElement === droppable.nativeElement);
    }
}

export type Dimensions = {
    height: string;
    width: string;
};
