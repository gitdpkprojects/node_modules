/* tslint:disable:directive-selector-name */
import {
    AfterViewInit,
    Directive,
    ElementRef,
    EventEmitter,
    HostBinding,
    Input,
    Output,
    Renderer2,
    HostListener
} from '@angular/core';
import { Observable } from 'rxjs';
import { MOUSE_BUTTON } from '../../core/constants/mouse-button.constant';
import { DragAndDropService } from './drag-and-drop.service';
import { DraggableService } from '../draggable/draggable.service';
import { Subscription } from 'rxjs/Subscription';
import { DOMHelper } from '../../core/helpers/dom.helper';
import { UnSub } from '../../core/classes';
import AnimationHelper from '../../core/helpers/animation.helper';
import { DraggableHelper } from '../../core/helpers/draggable.helper';

export type DraggableData = {
    x: number;
    y: number;
    clientX: number;
    clientY: number;
    centerElement: boolean;
    width?: number;
};

const leftMouse = (event: MouseEvent) => event.button === MOUSE_BUTTON.LEFT;
const onlyLeftMouse = (event: MouseEvent) => event.buttons === 1;
@Directive({
    selector: '[cui-draggable2]'
})
@UnSub(50)
export class Draggable2Directive implements AfterViewInit {
    @HostBinding('class.cui-draggable2')
    addClass: boolean = true;
    @HostBinding('class.currently-dragging-clone')
    get addClassDrag() {
        return this._isDragging || this._isAnimating;
    }
    @HostBinding('class.hover') hover: boolean = false;
    @HostBinding('class.is-draggable')
    @Input()
    isDraggable: boolean = true;
    @Input()
    item: any = {};
    @Input()
    centerElement: boolean = false;
    @Input()
    cloneWidth: number = null;
    @Output()
    onDragStart: EventEmitter<any> = new EventEmitter<any>();
    @Output()
    onDragEnd: EventEmitter<any> = new EventEmitter<any>();

    private _isDragging = false;
    private _isAnimating = false;
    private _subscriptions: Array<Subscription> = [];
    set subscriptions(sub) {
        this._subscriptions.push(sub);
    }
    constructor(
        public elementRef: ElementRef,
        public renderer: Renderer2,
        public dragAndDropService: DragAndDropService,
        private _draggableService: DraggableService
    ) { }
    ngAfterViewInit(): void {
        const el = this.elementRef.nativeElement;
        const mouseDown$: Observable<any> = Observable.fromEvent(
            el,
            'mousedown'
        )
            .filter(leftMouse)
            .filter((event: MouseEvent) => this.isDraggable &&
                DraggableHelper.isDraggableElement(event.target as Element, 'cui-draggable2'));
        const mouseUp$: Observable<any> = Observable.fromEvent(
            window,
            'mouseup'
        ).filter(leftMouse);
        const mouseLeave$: Observable<any> = Observable.fromEvent(
            el,
            'mouseleave'
        );
        const mouseMove$: Observable<any> = Observable.fromEvent(
            document.body,
            'mousemove'
        )
            .filter(onlyLeftMouse)
            .filter(() => this.isDraggable);
        const drag$ = mouseDown$.switchMap((e) => Observable.of(e).delay(200).takeUntil(mouseUp$).take(1));

        const dragStart$ = drag$.switchMap((event: MouseEvent) => {
            this._draggableService.onStartDrag.emit(event);
            return Observable.timer(1)
                .takeUntil(Observable.merge(mouseUp$, mouseLeave$))
                .map(() => event);
        });
        const dragging$ = dragStart$.flatMap((md: MouseEvent) => {
            const offSet = DOMHelper.getMousePointerOffset(
                md,
                this.elementRef.nativeElement
            );
            const temp = {
                x: md.clientX - offSet.x,
                y: md.clientY - offSet.y,
                clientX: md.clientX,
                clientY: md.clientY,
                centerElement: this.centerElement,
                width: this.cloneWidth
            };
            this.setPosition(temp);
            return mouseMove$
                .map((mm: MouseEvent) => {
                    mm.preventDefault();
                    return <DraggableData>{
                        x: mm.clientX - offSet.x,
                        y: mm.clientY - offSet.y,
                        clientX: mm.clientX,
                        clientY: mm.clientY,
                        centerElement: this.centerElement,
                        width: this.cloneWidth
                    };
                })
                .takeUntil(mouseUp$);
        });
        this.subscriptions = Observable.fromEvent(el, 'click').subscribe(
            (event: MouseEvent) => {
                event.stopImmediatePropagation();
            }
        );
        const dragEnd$ = dragging$.switchMap(() => mouseUp$.take(1));
        this.subscriptions = dragEnd$.subscribe(() => {
            const newlyCreated = document.querySelector('.newly-created');
            this.dragAndDropService.dragEnd(!newlyCreated);
            this._draggableService.onStopDrag.emit();
            this.onDragEnd.emit({ element: this.elementRef, item: this.item });
            this._isAnimating = true;

            const clone = <HTMLElement>(
                document.querySelector('.currently-dragging')
            );
            if (clone) {
                AnimationHelper.animationCompleted(clone).then(() => {
                    this._isAnimating = false;
                });
            }
            setTimeout(() => {
                this._isAnimating = false;
            }, 1000);
            this._isDragging = false;

            // mini-timeout to make onClick() in tactile-block.component.ts to work
            setTimeout(() => {
                this.renderer.removeClass(document.body, 'dragging');
            });
        });
        this.subscriptions = dragging$.subscribe((data: DraggableData) => {
            if (!this._isDragging) {
                this.onDragStart.emit({
                    element: this.elementRef,
                    item: this.item
                });
                this._isDragging = true;
            }
            this.setPosition(data);
        });
        this.subscriptions = mouseDown$.subscribe((event: MouseEvent) => {
            event.preventDefault();
            event.stopPropagation();
        });
    }

    setPosition(data: DraggableData): void {
        this.dragAndDropService.setDragItem(data, this.elementRef, this.item);
    }

    @HostListener('mousemove', ['$event'])
    mouseMove(event: MouseEvent): void {
        this.hover = this.isDraggable && DraggableHelper.isDraggableElement(event.target as Element, 'cui-draggable2');
    }

    @HostListener('mouseleave')
    mouseLeave(): void {
        this.hover = false;
    }
}
