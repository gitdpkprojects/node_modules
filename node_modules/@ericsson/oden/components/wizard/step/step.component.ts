import {
    AfterContentInit, Component, ContentChild, ContentChildren, EventEmitter, forwardRef, Host, HostBinding, Inject,
    Input, OnChanges, OnDestroy, OnInit, Output, QueryList, SimpleChanges, ViewEncapsulation, AfterViewInit
} from '@angular/core';
import { Subscription } from 'rxjs';
import { WIZARD_DISPLAY_TYPE, WIZARD_TYPE } from '../../../core/constants/wizard.constats';
import { WizardComponent } from '../wizard.component';
import { WizardService } from '../wizard.service';
import { ContentComponent } from './content/content.component';
import { SummaryComponent } from './summary/summary.component';

@Component({
    selector: 'cui-wizard-step',
    templateUrl: 'step.component.html',
    styleUrls: ['step.component.scss'],
    encapsulation: ViewEncapsulation.None
})
export class StepComponent implements OnChanges, OnInit, AfterContentInit, AfterViewInit, OnDestroy {
    private _subscriptions: Array<Subscription> = [];
    private _active: boolean = false;
    public stepIndex: number = 0;
    public totalSteps: number;
    public isHorizontal: boolean;
    public displayType: WIZARD_DISPLAY_TYPE;
    public isOptionalAndLinear: boolean;
    public type: WIZARD_TYPE;
    @HostBinding('class.cui-wizard-step') addClass: boolean = true;
    @HostBinding('class.active') activeClass: boolean = this.active;
    @HostBinding('class.clickable') _isClickable: boolean = true;
    @HostBinding('class.no-content') _noContent: boolean = false;
    @HostBinding('class.completed') private _completed: boolean = false;
    @HostBinding('class.locked') @Input() locked: boolean = false;
    @HostBinding('class.opened') opened: boolean = false;
    @ContentChildren(ContentComponent) contentComponents: QueryList<ContentComponent>;
    @ContentChild(forwardRef(() => SummaryComponent)) summaryComponent: SummaryComponent;
    @Input() optional: boolean = false;
    @Input() title: string;
    @Input() hideBack: boolean = false;
    @Input() hideNext: boolean = false;
    @Input() icon: string;
    @Input() stepIcon: string;
    @Input() iconTooltip: string;
    @Input() minWidth: number = 200;
    @Input() set completed(newCompleted: boolean) {
        this._completed = newCompleted;
        this._wizardComponent._setIsClickable();
    } get completed(): boolean {
        return this._completed;
    }
    @Output() onEnter: EventEmitter<StepComponent> = new EventEmitter<StepComponent>();
    @Output() onLeave: EventEmitter<StepComponent> = new EventEmitter<StepComponent>();

    constructor (
        @Host() @Inject(forwardRef(() => WizardComponent)) private _wizardComponent: WizardComponent,
        private _wizardService: WizardService
    ) { }

    setIsOptionalAndLinear() {
        this.isOptionalAndLinear = this.type === WIZARD_TYPE.LINEAR && this.optional;
    }

    ngOnInit() {
        this.type = this._wizardComponent.type;
        this.setIsOptionalAndLinear();
        this._subscriptions.push(this._wizardComponent.onTypeChange$.subscribe((type) => {
            this.type = type;
            this.setIsOptionalAndLinear();
        }));
        this._subscriptions.push(this._wizardComponent.steps.changes.subscribe((steps) => {
            this.totalSteps = steps.length;
        }));
        this.displayType = this._wizardComponent.displayType;
        this._subscriptions.push(this._wizardComponent.onDisplayTypeChange$.subscribe((displayType) => {
            this.displayType = displayType;
        }));
        this.setIsHorizontal();
    }

    ngAfterContentInit() {
        this.totalSteps = this._wizardComponent.steps.length;
        this._setButtonState();
    }

    ngAfterViewInit(): void {
        this._setButtonState();
    }

    /**
     * Updates button state when @Input changes (and onload).
     */
    ngOnChanges(changes: SimpleChanges) {
        if (changes['optional']) {
            this.setIsOptionalAndLinear();
        }
        this._setButtonState();
    }

    ngOnDestroy(): void {
        this._subscriptions.forEach(sub => sub.unsubscribe());
    }

    setIsHorizontal(): void {
        this.isHorizontal = this.displayType === WIZARD_DISPLAY_TYPE.HORIZONTAL;
    }

    /**
     * Sets this step as active or inactive
     * @param active
     */
    set active(active: boolean) {
        if (!this._active && active) {
            this._active = this.activeClass = active;
            this.onEnter.emit(this);
        } else if (this._active && !active) {
            this._active = this.activeClass = active;
            this.onLeave.emit(this);
        }
        this._setButtonState();
    }
    get active(): boolean {
        return this._active;
    }

    /**
     * Broadcast to wizardService to make this step as active.
     */
    setAsActiveStep(): void {
        if (!this._wizardComponent.openAll && !this._wizardComponent.isTimeline) {
            this._wizardService.changeStep(this.stepIndex);
        } else {
            this.toggleStep();
        }
    }

    /**
     * Toggles step between open and close
     */
    private toggleStep() {
        if (!this._noContent) {
            this.active = !this.active;
        }
    }

    /**
     * Sets is the button should be disabled or not depending on wizard settings.
     * @private
     */
    private _setButtonState() {
        if (this.contentComponents && this.contentComponents.length > 0) {
            this._noContent = false;

            this.contentComponents.first.buttonDisabled =
                this._wizardComponent.type === WIZARD_TYPE.LINEAR &&
                !this.optional &&
                !this.completed;
            if (this._wizardComponent.openAll) {
                this.opened = this._wizardComponent.openAll;
                this.hideBack = this.hideNext = true;
            }
            if (this._wizardComponent.isTimeline) {
                this.hideBack = this.hideNext = true;
                this.opened = true;
            }
        } else {
            this._noContent = true;
        }
    }
}
