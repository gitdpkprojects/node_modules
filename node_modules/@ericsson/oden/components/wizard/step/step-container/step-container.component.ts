import { animate, AnimationBuilder, AnimationFactory, AnimationPlayer, style } from '@angular/animations';
import { AfterViewInit, Component, ElementRef, HostListener, NgZone, OnDestroy, OnInit, ViewChild, ViewEncapsulation } from '@angular/core';
import { Subscription } from 'rxjs';
import { first } from 'rxjs/operators';
import { WizardComponent } from '../../wizard.component';
import { WizardService } from '../../wizard.service';
import { StepComponent } from '../step.component';

@Component({
    selector: 'cui-wizard-step-container',
    templateUrl: 'step-container.component.html',
    styleUrls: ['step-container.component.scss'],
    encapsulation: ViewEncapsulation.None,
    host: {
        'class': 'cui-wizard-step-container'
    }
})
export class StepContainerComponent implements AfterViewInit, OnDestroy, OnInit {
    currentStep: number = 0;
    offset: number = 0;
    index = 0;
    iconPrev: string = 'chevron-left';
    iconNext: string = 'chevron-right';
    customOffset: number = 0;
    currentPage = 0;
    sortedSteps: Array<Array<StepComponent>> = new Array();
    containerWidth: number;

    private _subscriptions: Array<Subscription> = [];
    private _player: AnimationPlayer;

    @ViewChild('carousel')
    private carousel: ElementRef;

    constructor (
        private _wizardService: WizardService,
        public wizardComponent: WizardComponent,
        private _builder: AnimationBuilder,
        private _ngZone: NgZone
    ) { }

    ngOnInit(): void {
        this._subscriptions.push(
            this._wizardService.stepChanged$.subscribe(index => {
                this.currentStep = index;
            })
        );
        this._subscriptions.push(
            this.wizardComponent.steps.changes.subscribe(() =>
                this.sortSteps()
            )
        );
        this._subscriptions.push(
            this._wizardService.previousStep$.subscribe(() => {
                this.currentStep = this.currentStep - 1;
                this.previousStep();
            })
        );
        this._subscriptions.push(
            this._wizardService.nextStep$.subscribe(() => {
                this.currentStep = this.currentStep + 1;
                this.nextStep();
            })
        );
    }
    ngAfterViewInit(): void {
        this._ngZone.onStable.pipe(first()).subscribe(() => {
            this._calculateWidth();
            this.sortSteps();
        });
    }
    ngOnDestroy(): void {
        this._subscriptions.forEach(sub => sub.unsubscribe());
    }
    @HostListener('window:resize')
    onResize(): void {
        this._calculateWidth();
        this.sortSteps();
        // Go to correct page based on current step
        this.currentPage = this.getPageIndex(this.currentStep);
        this.customOffset = this.currentPage * 100;
        this.animateCarousel();
    }
    /**
     * Get step size
     * @returns {number}
     */
    get stepSize(): number {
        if (!this.sortedSteps) {
            return 0;
        } else {
            return this.sortedSteps.length;
        }
    }
    /**
     * Get next page number
     * @returns {number}
     */
    get nextPage(): number {
        let page = 0;
        let size = 0;
        for (const step of this.sortedSteps) {
            size += step.length;
            if (this.currentStep < size) {
                break;
            } else {
                page++;
            }
        }
        return page;
    }
    /**
     * Get the global index of the step.
     * @param stepIndex - Step index of page
     * @param pageIndex - Page index
     * @return {number}
     */
    getIndex(stepIndex: number, pageIndex: number): number {
        let tmpIndex = 0;
        if (stepIndex > 0) {
            for (let i = 0; i < stepIndex; i++) {
                tmpIndex += this.sortedSteps[i].length;
            }
        }
        return tmpIndex + pageIndex;
    }
    /**
     * Get page index from global step index
     * @param stepIndex
     * @returns {number}
     */
    getPageIndex(stepIndex): number {
        let tmpStepIndex = 0;
        for (let p = 0; p < this.sortedSteps.length; p++) {
            for (let s = 0; s < this.sortedSteps[p].length; s++) {
                if (stepIndex === tmpStepIndex) {
                    return p;
                }
                tmpStepIndex++;
            }
        }
        return 0;
    }
    /**
     * Determine if next page button should be active.
     * @return {boolean}
     */
    shouldShowNext(): boolean {
        return this.currentPage + 1 < this.stepSize;
    }
    /**
     * Previous page button action.
     */
    prevPageButton(): void {
        if (this.currentPage > 0) {
            this.currentPage -= 1;
            this.customOffset -= 100;
            this.animateCarousel();
        }
    }
    /**
     * Next page button action.
     */
    nextPageButton(): void {
        if (this.currentPage < this.sortedSteps.length - 1) {
            this.currentPage += 1;
            this.customOffset += 100;
            this.animateCarousel();
        }
    }
    /**
     * Animate the Carousel.
     */
    animateCarousel(): void {
        const animation: AnimationFactory = this._builder.build([
            animate(
                250,
                style({ transform: `translateX(-${this.customOffset}%)` })
            )
        ]);
        this._player = animation.create(this.carousel.nativeElement);
        this._player.play();
    }
    /**
     * Broadcast to wizardService to make this step as active.
     * @param index
     */
    setAsActiveStep(index: number): void {
        this._wizardService.changeStep(index);
    }
    /**
     * Animate to previous step.
     */
    previousStep(): void {
        if (this.nextPage < this.currentPage) {
            this.currentPage -= 1;
            if (this.customOffset !== 0) {
                this.offset = this.customOffset - 100;
            } else {
                this.offset -= 100;
            }
            this.customOffset = this.offset;
            this.animateCarousel();
        }
    }
    /**
     * Animate to next step.
     */
    nextStep(): void {
        if (this.nextPage > this.currentPage) {
            this.currentPage += 1;
            if (this.offset !== 0) {
                this.offset = this.customOffset + 100;
            } else {
                this.offset += 100;
            }
            this.customOffset = this.offset;
            this.animateCarousel();
        }
    }
    /**
     * Sort steps in pages based on container size and its defined min-width
     */
    sortSteps(): void {
        let width = 0;
        let page = new Array();
        this.sortedSteps = [];
        this.wizardComponent.steps.forEach(step => {
            width += step.minWidth;
            if (width < this.containerWidth) {
                page.push(step);
            } else {
                this.sortedSteps.push(page);
                page = new Array();
                page.push(step);
                width = step.minWidth;
            }
        });
        if (page.length > 0) {
            this.sortedSteps.push(page);
        }
    }
    /**
     * Calculate width of carousel container.
     */
    private _calculateWidth(): void {
        this.containerWidth = this.carousel.nativeElement.clientWidth;
    }
}
