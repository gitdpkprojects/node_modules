import {
    AfterContentInit, Component, ContentChildren, HostBinding, Input, OnChanges,
    QueryList, SimpleChanges, ViewEncapsulation, OnInit
} from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../core/classes/subscription.decorator';
import { WIZARD_TYPE, WIZARD_DISPLAY_TYPE } from '../../core/constants/wizard.constats';
import { StepComponent } from './step/step.component';
import { WizardService } from './wizard.service';

@Component({
    selector: 'cui-wizard',
    templateUrl: 'wizard.component.html',
    styleUrls: ['wizard.component.scss'],
    encapsulation: ViewEncapsulation.None,
    providers: [WizardService],
    host: {
        'class': 'cui-wizard'
    }
})
@UnSub()
export class WizardComponent implements OnInit, AfterContentInit, OnChanges {
    private _currentStep: number = -1;
    private _isInitialized: boolean = false;
    private _gotoStepWhenInitialized: number;
    private _subscriptions: Array<Subscription> = [];
    public onDisplayTypeChange$ = new BehaviorSubject<WIZARD_DISPLAY_TYPE>(WIZARD_DISPLAY_TYPE.VERTICAL);
    public onTypeChange$ = new BehaviorSubject<WIZARD_TYPE>(WIZARD_TYPE.LINEAR);
    @HostBinding('class.horizontal') isHorizontal: boolean = false;
    @HostBinding('class.is-timeline')
    @ContentChildren(StepComponent) steps: QueryList<StepComponent> = new QueryList<StepComponent>();
    @Input() isTimeline: boolean = false;
    @Input() type: WIZARD_TYPE = WIZARD_TYPE.LINEAR;
    @Input() displayType: WIZARD_DISPLAY_TYPE = WIZARD_DISPLAY_TYPE.VERTICAL;
    @Input() openAll: boolean = false;
    /**
     * Sets current step in wizard, removes active class from previous step and adds that to new step.
     * @param newIndex
     */
    @Input() set currentStep(newIndex: number) {
        if (this._isInitialized) {
            this._setIndexes();
            if (this._isValidStep(newIndex)) {
                this._currentStep = newIndex;
                this.steps.forEach((step, index) => {
                    if (!this.openAll) {
                        step.active = index === newIndex;
                    } else {
                        step.active = true;
                    }
                });
            }
        } else {
            this._gotoStepWhenInitialized = newIndex;
        }
    }

    constructor (private _wizardService: WizardService) { }

    ngOnInit() {
        this._subscriptions.push(this._wizardService.stepChanged$.subscribe((index) => this.currentStep = index));
        this._subscriptions.push(this._wizardService.previousStep$.subscribe(() => this.currentStep = this.currentStep - 1));
        this._subscriptions.push(this._wizardService.nextStep$.subscribe(() => this.currentStep = this.currentStep + 1));
    }

    ngAfterContentInit() {
        this._isInitialized = true;
        // Child components values are bound to the view before this step.
        // Trying to change parent component (wizard & step) values result in an error during angular dirty checking.
        // Hence trigger an additional change detection.
        setTimeout(() => {
            if (this._gotoStepWhenInitialized) {
                this.currentStep = this._gotoStepWhenInitialized;
            } else {
                this.currentStep = 0;
            }
            // Update indexes when steps are added / removed
            this._subscriptions.push(
                this.steps.changes.subscribe(() => this._setIndexes())
            );
        });
    }

    ngOnChanges(changes: SimpleChanges) {
        if (changes['displayType']) {
            this.isHorizontal = this.displayType === WIZARD_DISPLAY_TYPE.HORIZONTAL;
            this.onDisplayTypeChange$.next(this.displayType);
        }
        if (changes['type']) {
            this.onTypeChange$.next(this.type);
        }
    }

    _setIsClickable(): void {
        let prevStep = null;
        this.steps.forEach((step) => {
            if (prevStep) {
                step._isClickable = !!this.openAll || this.type === WIZARD_TYPE.NON_LINEAR || !!prevStep.optional || !!prevStep.completed;
            }
            prevStep = step;
        });
    }

    /**
     * Returns current step in wizard.
     * @return {number}
     */
    get currentStep(): number {
        return this._currentStep;
    }

    /**
     * Sets correct stepIndex for all steps
     * @private
     */
    private _setIndexes() {
        this.steps.forEach((step, index) => (step.stepIndex = index));
        this._setIsClickable();
    }

    /**
     * Returns true if the newIndex is a valid index to go to. Checks if the current step is completed (if mandatory)
     * @param newIndex
     * @return {boolean}
     * @private
     */
    private _isValidStep(newIndex): boolean {
        if (newIndex < -1 || newIndex >= this.steps.length) {
            // Block navigation if index is out of bounds.
            return false;
        }
        if (newIndex < this._currentStep && newIndex >= -1) {
            // Always allow to go back in wizard
            return true;
        }
        if (this.type === WIZARD_TYPE.LINEAR) {
            if (
                this.steps.filter(
                    step =>
                        !step.completed &&
                        step.stepIndex === this._currentStep &&
                        !step.optional
                ).length !== 0
            ) {
                // If wizard is of type Linear, the step is not optional and not completed
                // then block navigation.
                return false;
            } else if (
                this.steps.filter(step => {
                    return (
                        !step.completed &&
                        step.stepIndex < newIndex &&
                        !step.optional
                    );
                }).length !== 0
            ) {
                // Block navigation to a step if a step in between is not completed
                return false;
            }
        }
        return true;
    }
}
