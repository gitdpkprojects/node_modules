import { TactileBlockItem } from '../../core/models/tactile-block-item.model';
import { UUID } from '../../core/helpers/uuid.class';
import { BlockTreeBranchLeaf } from '../../core/models/block-tree-branch-leaf.model';
import { BlockTreeBranch } from '../../core/models/block-tree-branch.model';
import { BlockTree } from '../../core/models/block-tree.model';
import { TimeHelper } from '../../core/helpers/time.helper';

export class BlockTreeHelper {
    static convertTactileToBlockTreeModel(
        tactileBlock: TactileBlockItem
    ): BlockTreeBranch | BlockTreeBranchLeaf {
        let dragged;
        if (tactileBlock.draggableItem instanceof BlockTreeBranchLeaf) {
            tactileBlock.id = 'tactile-' + UUID.create();
            dragged = new BlockTreeBranchLeaf(tactileBlock.draggableItem);
            dragged.newlyCreated = true;
            dragged.data = tactileBlock;
            dragged.id = 'brbl-new-' + UUID.create();
            return dragged;
        } else if (tactileBlock.draggableItem instanceof BlockTreeBranch) {
            tactileBlock.id = 'tactile-' + UUID.create();
            dragged = new BlockTreeBranch(tactileBlock.draggableItem);
            dragged.newlyCreated = true;
            dragged.id = 'brb-new-' + UUID.create();
            dragged.data = tactileBlock;
            dragged.isExpanded = false;
            return dragged;
        }
        throw new TypeError('Invalid block tree dropped');
    }

    static findInsertionIndex(droppedAt): number {
        let indexToInsert: number = -1;
        let i: number = 0;
        if (!droppedAt.children.length) {
            return 0;
        } else {
            // TODO: Fix this
            droppedAt.children.forEach(child => {
                if (
                    (i === 0 && child.isDroppableBefore) ||
                    (child.isDroppableBefore &&
                        droppedAt.children[i - 1].isDroppableAfter)
                ) {
                    indexToInsert = i;
                    return;
                } else if (
                    i === droppedAt.children.length - 1 &&
                    child.isDroppableAfter
                ) {
                    indexToInsert = i + 1;
                    return;
                }
                i++;
            });
            return indexToInsert;
        }
    }

    /**
     * Digs through the whole block tree and returns a selected branch if there is one
     * @param {BlockTree} blockTree
     * @param {Array<BlockTreeBranch>} children
     * @returns {BlockTree | BlockTreeBranch}
     */
    static getSelectedBranch(
        blockTree: BlockTree,
        children: Array<BlockTreeBranch>
    ): BlockTree | BlockTreeBranch {
        if (blockTree.isSelected) {
            return blockTree;
        }
        let selectedItem = null;
        children
            .filter(item => item instanceof BlockTreeBranch)
            .forEach((child: BlockTreeBranch) => {
                if (selectedItem) {
                    return;
                } else if (child.isSelected) {
                    selectedItem = child;
                } else if (child.children.length) {
                    selectedItem = this.getSelectedBranch(blockTree, child.children);
                }
            });
        return selectedItem;
    }

    /**
     * Expands given item and all its parents
     * @param {BlockTree | BlockTreeBranch | BlockTreeBranchLeaf} item
     */
    static expandItemAndParents(
        item: BlockTree | BlockTreeBranch | BlockTreeBranchLeaf
    ): void {
        if (item instanceof BlockTreeBranch || item instanceof BlockTree) {
            item.isExpanded = true;
        }
        if (!(item instanceof BlockTree) && item.parent) {
            item.parent.isExpanded = true;
            this.expandItemAndParents(item.parent);
        }
    }

    static async setDraggedVisible(timeout) {
        if (!timeout) {
            return;
        }
        await TimeHelper.wait(timeout);
        Array.from(document.querySelectorAll('.newly-created')).forEach(
            newlyCreated => {
                newlyCreated.classList.remove('newly-created');
            }
        );
    }

    /**
     * Traverses the tree backwards to find a branch where the filter matches. Returns true if one is found.
     * @param {BlockTreeBranch | BlockTreeBranchLeaf} item
     * @returns {boolean}
     */
    static isAnyParentMatchingFilter(
        item: BlockTreeBranch | BlockTreeBranchLeaf
    ): boolean {
        let _item: BlockTreeBranch | BlockTreeBranchLeaf = item;
        let match: boolean = false;
        while (_item.parent) {
            if (
                _item.parent instanceof BlockTreeBranch &&
                (<BlockTreeBranch>_item.parent).matchesFilter
            ) {
                match = true;
            }
            _item = _item.parent;
        }
        return match;
    }
}
