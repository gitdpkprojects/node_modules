import { BlockTreeService } from './block-tree.service';
import { BlockTree } from '../../core/models/block-tree.model';
import {
    AfterViewInit,
    Component,
    ElementRef,
    EventEmitter,
    HostBinding,
    HostListener,
    Input,
    OnDestroy,
    OnInit,
    Output,
    Renderer2,
    ViewEncapsulation
} from '@angular/core';
import { ANIMATION } from '../../core/constants';
import {
    animate,
    state,
    style,
    transition,
    trigger
} from '@angular/animations';
import { ActionItem, Divider, TactileBlockItem } from '../../core/models';
import { BlockTreeBranch } from '../../core/models/block-tree-branch.model';
import { BlockTreeBranchLeaf } from '../../core/models/block-tree-branch-leaf.model';
import { DragAndDropService } from '../drag-and-drop';
import { TactileBlockService } from '../tactile-block/tactile-block.service';
import { DOMHelper } from '../../core/helpers';
import { ButtonActionItem } from '../../core/models/button-action-item.model';
import { Subscription } from 'rxjs/Subscription';
import { KEYBOARD } from '../../core/constants/keyboard.constants';
import { UnSub } from '../../core/classes';
import { TimeHelper } from '../../core/helpers/time.helper';
import { BlockTreeHelper } from './block-tree.helper';
import { ILibraryItemReceiver } from '../../core/interfaces/library-item-receiver.interface';
import { LibraryItemReceiverService } from '../library/library-item-receiver.service';

@Component({
    selector: 'cui-block-tree',
    templateUrl: 'block-tree.component.html',
    styleUrls: ['block-tree.component.scss'],
    encapsulation: ViewEncapsulation.None,
    animations: [
        trigger('state', [
            state(
                '*',
                style({
                    height: '58px'
                })
            ),
            state(
                'expanded',
                style({
                    height: '*'
                })
            ),
            transition(
                '* => expanded',
                animate('100ms ' + ANIMATION.EASE_OUT_QUAD)
            ),
            transition(
                'expanded => *',
                animate('100ms ' + ANIMATION.EASE_OUT_QUAD)
            )
        ])
    ]
})
@UnSub()
export class BlockTreeComponent implements OnInit, OnDestroy, AfterViewInit, ILibraryItemReceiver {
    @HostBinding('attr.id')
    get id(): string {
        return this.blockTree.id;
    }
    @HostBinding('class.cui-block-tree')
    addClass: boolean = true;
    @HostBinding('class.hidden-root-tree')
    get hideRootNode(): boolean {
        return this.blockTree && this.blockTree.hideRootNode;
    }
    @HostBinding('class.expanded')
    get isExpanded(): boolean {
        return this.blockTree && this.blockTree.isExpanded;
    }
    @HostBinding('class.engaged')
    get isEngaged(): boolean {
        return this.blockTree.state.engaged;
    }
    @HostBinding('class.is-empty')
    get isEmpty(): boolean {
        return this.blockTree && this.blockTree.children.length < 1;
    }
    @HostBinding('class.is-droppable')
    get _isDroppable(): boolean {
        return this.blockTree && this.blockTree.isDroppable;
    }
    @HostBinding('class.focus')
    focused: boolean = false;
    @HostBinding('tabindex')
    get _tabIndex(): number {
        return this.hideRootNode ? -1 : this.tabIndex;
    }
    @HostBinding('class.selected')
    get isSelected(): boolean {
        return this.blockTree.isSelected;
    }
    @Input()
    name: string;
    @Input()
    tabIndex: number = 0;
    @Input()
    blockTree: BlockTree;
    @Input()
    placeholderTitle: string;
    @Input()
    placeholderDescription: string;
    @Input()
    placeholderActions: Array<ButtonActionItem> = [];
    @Input()
    enablePositionDisplay: boolean = false;

    @Output()
    onPlaceholderActionClick: EventEmitter<ButtonActionItem> = new EventEmitter<
        ButtonActionItem
    >();
    @Output()
    onActionClick: EventEmitter<ActionItem> = new EventEmitter<ActionItem>();
    @Output()
    onSwitchChange: EventEmitter<any> = new EventEmitter<any>();
    @Output()
    onSelectTactileBlock: EventEmitter<any> = new EventEmitter<any>();
    @Output()
    onSelectBranch: EventEmitter<any> = new EventEmitter<any>();
    @Output()
    onDragStart: EventEmitter<any> = new EventEmitter<any>();
    @Output()
    onDragEnd: EventEmitter<any> = new EventEmitter<any>();
    @Output()
    onBlockTreeChange: EventEmitter<null> = new EventEmitter<null>();

    blockTreeBranch = BlockTreeBranch;
    blockTreeBranchLeaf = BlockTreeBranchLeaf;

    // Keep track of the current index on subcomponents
    index: number = 0;
    private isExpanding: boolean = false;
    private _isMouseDown: boolean = false;
    private _subscriptions: Array<Subscription> = [];
    switcher: any;

    get actions(): Array<ActionItem | Divider> {
        return this.blockTree ? this.blockTree.actions : [];
    }
    get state(): string {
        return this.isExpanded ? 'expanded' : 'collapsed';
    }
    get filterTriggered(): boolean {
        return this._blockTreeService.filterTriggered;
    }
    get expandOrCollapse(): string {
        const allBranches = this._blockTreeService.getAllBranches(
            this.blockTree
        );
        const anyOpened = allBranches.filter(i => i.isExpanded);
        if (anyOpened.length === allBranches.length) {
            return 'Collapse';
        } else {
            return 'Expand';
        }
    }
    get itemsCount(): number {
        return this.blockTree.children.length;
    }
    get filterIsOn(): boolean {
        return this._blockTreeService.filterIsOn;
    }
    get children(): Array<BlockTreeBranch | BlockTreeBranchLeaf> {
        return this._blockTreeService.filterIsOn
            ? this.blockTree.filterChildren
            : this.blockTree.children;
    }

    constructor(
        private _element: ElementRef,
        private _renderer: Renderer2,
        private _blockTreeService: BlockTreeService,
        private _dragAndDropService: DragAndDropService,
        private _tactileBlockService: TactileBlockService,
        private _libraryItemReceiverService: LibraryItemReceiverService
    ) {
        this._subscriptions.push(
            _blockTreeService.onBlockTreeChange.subscribe(() => {
                this.onBlockTreeChange.emit();
            })
        );
        this._subscriptions.push(
            _blockTreeService.onSwitchChange.subscribe((obj: any) => {
                this.onSwitchChange.emit(obj);
            })
        );
        this._subscriptions.push(
            _blockTreeService.onSelectBranch.subscribe(
                (model: BlockTreeBranch | BlockTree) => {
                    // unselect all first
                    _blockTreeService.unselectAll(
                        this.blockTree,
                        this.blockTree.children,
                        model
                    );
                    this.onSelectBranch.emit(model);
                }
            )
        );
        this._subscriptions.push(
            _blockTreeService.onActionClick.subscribe((obj: any) => {
                // emit obj which consists of {actionItem, model (tree or branch or leaf)}
                this.onActionClick.emit(obj);
            })
        );
        this._subscriptions.push(
            this._tactileBlockService.onTactileBlocksSelected.subscribe(
                (items: Array<TactileBlockItem>) => {
                    const selectedBranch = BlockTreeHelper.getSelectedBranch(
                        this.blockTree,
                        this.blockTree.children
                    );
                    if (selectedBranch) {
                        this._blockTreeService.unselectAll(
                            this.blockTree,
                            this.blockTree.children
                        );
                        this._blockTreeService.selectChange(selectedBranch);
                    }
                    this.onSelectTactileBlock.emit(items);
                }
            )
        );
        this._subscriptions.push(
            this._dragAndDropService.onDragStart$.subscribe(obj => {
                this.onDragStart.emit(obj);
            })
        );
        this._subscriptions.push(
            this._dragAndDropService.onDragEnd$.subscribe(obj => {
                this.onDragEnded(obj);
            })
        );
        this._subscriptions.push(
            _blockTreeService.onSelectItem.subscribe((id: string) => {
                this.selectItem(id);
            })
        );
        this._subscriptions.push(
            _blockTreeService.onFocusItem.subscribe((id: string) => {
                this.focusItem(id);
            })
        );
        this._subscriptions.push(
            this._dragAndDropService.onDropOutside$.subscribe(obj => {
                this.onDragEnded(obj, true);
            })
        );
    }

    ngOnInit(): void {
        if (this.blockTree.switcherValue !== undefined) {
            this.switcher = this.blockTree.switcherValue;
        }
        this._libraryItemReceiverService.registerReceiver(this);
    }

    ngAfterViewInit(): void {
        this.selectItem(this._blockTreeService.selected);
        this.focusItem(this._blockTreeService.focused);
    }

    @HostListener('keydown', ['$event'])
    enterPress(event: KeyboardEvent): void {
        if (
            this._element.nativeElement === document.activeElement &&
            (event.keyCode === KEYBOARD.ENTER ||
                event.keyCode === KEYBOARD.SPACE)
        ) {
            this.toggleBranch(event);
            event.preventDefault();
        }
    }

    @HostListener('focus', ['$event'])
    onFocus(): void {
        this.focused = !this.hideRootNode && !this._isMouseDown;
    }

    @HostListener('blur', ['$event'])
    onBlur(): void {
        this.focused = false;
    }

    @HostListener('mouseover', ['$event'])
    onMouseOver(event: MouseEvent): void {
        if (this.hideRootNode) {
            return;
        }
        this.blockTree.state.visibleChilds = true;
        event.stopPropagation();
    }

    @HostListener('mouseleave', ['$event'])
    onMouseLeave(event: MouseEvent): void {
        this.blockTree.state.visibleChilds = false;
        event.stopPropagation();
    }

    onDragEnded(obj, droppedOutside?: Boolean) {
        this.isExpanding = false;
        this._blockTreeService.hideAllVisibleDropElements.emit();
        if (droppedOutside) {
            this._blockTreeService.onDropOutside(obj.item, this._renderer);
        }
        this.onDragEnd.emit(obj);
    }

    /**
     * Sets an item to selected and scrolls the viewport to it.
     * @param {string} id
     */
    async selectItem(id: string): Promise<void> {
        if (!id) {
            return;
        }
        const item = this._blockTreeService.getById(id, this.blockTree);
        const element = document.getElementById(id);
        this._blockTreeService.selected = null;
        if (!(element && item)) {
            return;
        }
        BlockTreeHelper.expandItemAndParents(item);
        await TimeHelper.wait(300);
        if (
            (item instanceof BlockTree ||
                item instanceof BlockTreeBranch) &&
            item.isSelectable
        ) {
            item.isSelected = true;
            this._blockTreeService.selectChange(item);
        } else if (
            item instanceof BlockTreeBranchLeaf &&
            item.data instanceof TactileBlockItem &&
            item.data.selectable
        ) {
            this._tactileBlockService.selected = [item.data];
        }
        element.scrollIntoView({
            behavior: 'smooth',
            block: 'center'
        });
    }

    /**
     * Sets an item to focused and scrolls the viewport to it.
     * @param {string} id
     */
    async focusItem(id: string): Promise<void> {
        if (!id) {
            return;
        }
        const item = this._blockTreeService.getById(id, this.blockTree);
        const leaf = document.getElementById(id);
        this._blockTreeService.focused = null;
        if (!(leaf && item)) {
            return;
        }
        BlockTreeHelper.expandItemAndParents(item);
        item.state.focused = true;
        await TimeHelper.wait(300);
        leaf.focus();
        leaf.scrollIntoView({
            behavior: 'smooth',
            block: 'center'
        });
    }

    /**
     * Event handler for when the root node's switch is changed
     */
    switchChange(): void {
        this._blockTreeService.switchChange(this.blockTree, this.switcher);
        this.blockTree.state.visibleChilds = false;
    }

    /**
     * Event handler for when tree has been selected (via Edit switcher)
     */
    selectChange(): void {
        this._blockTreeService.selectChange(this.blockTree);
        this.blockTree.state.visibleChilds = false;
    }

    /**
     * Event handler for when a BlockTreeBranch or a BlockTreeBranchLeaf is dropped
     *
     * @param {BlockTreeBranch | BlockTreeBranchLeaf} droppedAt
     * @param {BlockTreeBranch | BlockTreeBranchLeaf} dragged
     */
    onBlockDrop(
        droppedAt: BlockTreeBranchLeaf,
        dragged: BlockTreeBranch | BlockTreeBranchLeaf
    ): void {
        dragged.newlyCreated = true;
        this._blockTreeService.blockDropped(dragged, droppedAt, this._renderer);
        this.clearInterval();
        this._blockTreeService.hideAllVisibleDropElements.emit();
    }

    /**
     * Event handler for when a BlockTreeBranch or a BlockTreeBranchLeaf is dropped
     * on an empty position on tree root level
     *
     * @param {BlockTreeBranch | BlockTreeBranchLeaf} dragged
     * @param {number} droppedAtIndex
     */
    onBlockDropAtRootPosition(
        dragged: BlockTreeBranch | BlockTreeBranchLeaf,
        droppedAtIndex: number
    ) {
        dragged.newlyCreated = true;
        this._blockTreeService.blockDroppedAtRootPosition(
            dragged,
            this.blockTree,
            droppedAtIndex,
            this._renderer
        );
        this.clearInterval();
        this._blockTreeService.hideAllVisibleDropElements.emit();
    }

    /**
     * Event handler for when a BlockTreeBranch or a BlockTreeBranchLeaf is dropped
     * directly on a BlockTreeBranch
     *
     * @param {BlockTreeBranch} droppedAt
     * @param {BlockTreeBranch | BlockTreeBranchLeaf} dragged
     */
    onBranchDrop(
        droppedAt: BlockTreeBranch,
        dragged: BlockTreeBranch | BlockTreeBranchLeaf
    ): void {
        dragged.newlyCreated = true;
        this._blockTreeService.branchDropped(
            droppedAt,
            dragged,
            this._renderer
        );
        this.clearInterval();
        this._blockTreeService.hideAllVisibleDropElements.emit();
    }

    /**
     * Triggers when we drop on something that is already full or not droppable.
     */
    onReject(event) {
        this.clearInterval();
        setTimeout(() => {
            this._blockTreeService.onReject(event, this._renderer);
        });
    }

    isDropElementDroppable(i: number) {
        const children = this.children;
        const nextOkay = !children[i + 1] || (children[i + 1] && children[i + 1].isDroppableBefore);
        const prevOkay = !children[i] || (children[i] && children[i].isDroppableAfter);
        return nextOkay && prevOkay;
    }

    isDroppable(child: BlockTreeBranch): boolean {
        return (
            child.isExpanded &&
            !this.filterIsOn &&
            child.isDroppable &&
            (!child.children.length ||
                child.children.some(
                    (_child: BlockTreeBranch | BlockTreeBranchLeaf) => {
                        return (
                            _child.isDroppableAfter || _child.isDroppableBefore
                        );
                    }
                ))
        );
    }

    /**
     * Returns true if the item is draggable depending on isDraggable property and if it's collapsed (branches only)
     * @param {BlockTreeBranch | BlockTreeBranchLeaf} child
     * @returns {boolean}
     */
    isDraggable(child: BlockTreeBranch | BlockTreeBranchLeaf): boolean {
        return (
            !this.filterIsOn &&
            child.isDraggable &&
            ((child instanceof BlockTreeBranch && !child.isExpanded) ||
                child instanceof BlockTreeBranchLeaf)
        );
    }

    /**
     * If user clicks outside tree and it's selected, let's make it unselected
     * @param {MouseEvent} event
     */
    @HostListener('document:click', ['$event'])
    public onDocumentClick(event: MouseEvent): void {
        if (
            document.body.contains(<Node>event.target) &&
            !this._element.nativeElement.contains(<Node>event.target) &&
            !DOMHelper.isChildOfElement('.overlay-component', <Node>(
                event.target
            )) &&
            !(<HTMLElement>event.target).classList.contains('cui-backdrop') &&
            !DOMHelper.isChildOfElement('.cui-drawer', <Node>event.target)
        ) {
            if (this.blockTree.isSelected) {
                this.blockTree.isSelected = false;
                this._blockTreeService.selectChange(this.blockTree);
            }
            this.blockTree.state.visibleChilds = false;
        }
    }

    /**
     * We only *show* the focus style when focus has come to the element via the keyboard.
     * We make this work with the _isMouseDown variable.
     */
    @HostListener('mousedown')
    public onMouseDown(): void {
        this._isMouseDown = true;
        this.focused = false;
        setTimeout(() => {
            this._isMouseDown = false;
        }, 100);
    }

    toggleParentEngaged(engaged: boolean): void {
        this.blockTree.state.engaged = engaged;
    }

    /**
     * Clear the toggleExpandTimeout counter when leaving the branch
     */
    onLeave(): void {
        this.clearInterval();
    }

    /**
     * Action dispatcher for onActionClick
     * @param actionItem
     */
    actionClick(actionItem: ActionItem): void {
        this._blockTreeService.actionClick(actionItem, this.blockTree);
    }

    /**
     * When a draggable is hovering one of the branches under this branch, we start timing
     * and opens up the branch after 2 seconds of hovering.
     * @param {HTMLElement} element
     * @param {BlockTreeBranch} child
     */
    async toggleExpandTimeout(
        element: HTMLElement,
        child: BlockTreeBranch
    ): Promise<void> {
        if (
            !this.isExpanding &&
            !child.isExpanded &&
            !element.classList.contains('currently-dragging-clone')
        ) {
            this.isExpanding = true;
            await TimeHelper.wait(100);
            if (!child.isExpanded) {
                child.state.hoverToOpen = true;
            }
            await TimeHelper.wait(800);
            if (!child.isExpanded) {
                child.isExpanded = true;
                this.clearInterval();
            }
        }
    }

    clearInterval(): void {
        this._blockTreeService.setStateRecursive('hoverToOpen', false, this.blockTree);
        this.isExpanding = false;
    }

    /**
     * This function triggers when the user clicks on the tree
     * @param {MouseEvent} event
     */
    clickTree(event: MouseEvent): void {
        if (
            this.blockTree.isSelectable &&
            !this.blockTree.hideRootNode &&
            !DOMHelper.isChildOfElement('.cui-action-menu', <Node>event.target)
        ) {
            this.blockTree.isSelected = !this.blockTree.isSelected;
            this.selectChange();
            event.stopImmediatePropagation();
        }
    }

    /**
     * Toggles tree between expanded and not expanded
     * @param {Event} event
     */
    toggleBranch(event: Event): void {
        event.stopPropagation();
        this.blockTree.isExpanded = !this.blockTree.isExpanded;
    }

    /**
     * Emits the onPlaceholderActionClick EventEmitter
     * @param action
     */
    placeholderActionClicked(action: ButtonActionItem): void {
        this.onPlaceholderActionClick.emit(action);
    }

    /**
     * Iterates all branches and sets their `isExpanded` to false.
     */
    closeAll(): void {
        this._blockTreeService
            .getAllBranches(this.blockTree)
            .forEach((branch: BlockTree | BlockTreeBranch) => {
                if (branch instanceof BlockTreeBranch || !branch.hideRootNode) {
                    branch.isExpanded = false;
                }
            });
    }

    /**
     * Iterates all branches and sets their `isExpanded` to true.
     */
    openAll(): void {
        this.blockTree.isExpanded = true;
        this._blockTreeService
            .getAllBranches(this.blockTree)
            .forEach(branch => {
                branch.isExpanded = true;
            });
    }

    /**
     * Open or close all branches depending on if all are open or not
     */
    toggleAllBranches(): void {
        if (this.expandOrCollapse === 'Collapse') {
            this.closeAll();
        } else {
            this.openAll();
        }
    }
    ngOnDestroy(): void {
        this._libraryItemReceiverService.deregisterReceiver(this);
        this.clearInterval();
    }

    canReceiveLibraryItem(tactileItem: TactileBlockItem): boolean {
        if (!this._isDroppable) {
            return false;
        }

        if (!(tactileItem.draggableItem instanceof BlockTreeBranchLeaf || tactileItem.draggableItem instanceof BlockTreeBranch)) {
            return false;
        }

        this.onDragStart.emit({ item: tactileItem });
        const targets = this._getDropTargets(this.blockTree.children || []);
        const canReceive = targets.length > 0 || this._isDroppableOnRoot();
        this.onDragEnd.emit({ item: tactileItem });

        return canReceive;
    }

    onReceiveLibraryItem(tactileItem: TactileBlockItem): void {
        const source = BlockTreeHelper.convertTactileToBlockTreeModel(tactileItem);
        this.onDragStart.emit({ item: tactileItem });
        const targets = this._getDropTargets(this.blockTree.children || []);
        if (targets.length) {
            const emptyBranchTargets = this._getEmptyBranchTargets(targets);
            const beforeOrAfterTargets = this._getDropBeforeOrAfterTargets(targets);
            const selectedDropOnTarget = this._getSelectedDropOnTarget(targets);
            const selectedDropBeforeOrAfterTarget = this._getSelectedDropBeforeOrAfterTarget(targets);

            const emptyBranchTarget = this._getLastTarget(emptyBranchTargets);
            const beforeOrAfterTarget = this._getLastTarget(beforeOrAfterTargets);
            const target = this._getLastTarget(targets);

            if (selectedDropOnTarget) {
                this._dropOn(source, selectedDropOnTarget);
            } else if (selectedDropBeforeOrAfterTarget) {
                this._drop(source, selectedDropBeforeOrAfterTarget);
            } else if (emptyBranchTarget) {
                this._dropOn(source, emptyBranchTarget);
            } else if (beforeOrAfterTarget) {
                this._drop(source, beforeOrAfterTarget);
            } else {
                this._drop(source, target);
            }
        } else if (this._isDroppableOnRoot()) {
            this._dropOnRoot(source);
        }
        this.onDragEnd.emit({ item: tactileItem });
    }

    _getDropTargets(children: Array<BlockTreeBranch | BlockTreeBranchLeaf>): Array<BlockTreeBranch | BlockTreeBranchLeaf> {
        return children.reduce((leafs, child, index) => {
            if (child instanceof BlockTreeBranch) {
                leafs = leafs.concat(this._getDropTargets(child.children || []));
            }
            const previous = children[index - 1];
            const next = children[index + 1];
            if ((this._isDroppableBefore(child, previous) ||
                this._isDroppableAfter(child, next) ||
                this._isDroppableOn(child)) &&
                !this._isFullyPopulated(child.parent)) {
                leafs.push(child);
            }
            return leafs;
        }, []);
    }

    _isDroppableOnRoot(): boolean {
        return !this.blockTree.children.length && this.blockTree.isDroppable;
    }

    private _drop(source: BlockTreeBranch | BlockTreeBranchLeaf, target: BlockTreeBranch | BlockTreeBranchLeaf): void {
        if (this._isDroppableAfter(target)) {
            this._dropAfter(source, target);
        } else if (this._isDroppableBefore(target)) {
            this._dropBefore(source, target);
        } else if (this._isDroppableOn(target)) {
            this._dropOn(source, target);
        }
    }

    private _dropAfter(source: BlockTreeBranch | BlockTreeBranchLeaf, target: BlockTreeBranch | BlockTreeBranchLeaf): void {
        const targetIndex = this._indexOf(target);
        target.parent.children.splice(targetIndex + 1, 0, source);
        this._postDrop(source);
    }

    private _dropBefore(source: BlockTreeBranch | BlockTreeBranchLeaf, target: BlockTreeBranch | BlockTreeBranchLeaf): void {
        const targetIndex = this._indexOf(target);
        target.parent.children.splice(targetIndex, 0, source);
        this._postDrop(source);
    }

    private _dropOn(source: BlockTreeBranch | BlockTreeBranchLeaf, target: BlockTreeBranch | BlockTreeBranchLeaf): void {
        if (target instanceof BlockTreeBranchLeaf) {
            const newBranch = this._blockTreeService.createBranch([target, source]);
            const targetIndex = this._indexOf(target);
            target.parent.children.splice(targetIndex, 1, newBranch);
        } else if (target instanceof BlockTreeBranch) {
            target.children.push(source);
            target.isExpanded = true;
        }
        this._postDrop(source);
    }

    private _dropOnRoot(source: BlockTreeBranch | BlockTreeBranchLeaf): void {
        this.blockTree.children.push(source);
        this._postDrop(source);
    }

    private _postDrop(source: BlockTreeBranch | BlockTreeBranchLeaf): void {
        this.onBlockTreeChange.emit();
        setTimeout(() => {
            const element = document.getElementById(source.id);
            if (element) {
                element.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }, 300);
    }

    private _indexOf(target: BlockTreeBranch | BlockTreeBranchLeaf): number {
        return target.parent.children.findIndex(e => e === target);
    }

    private _getEmptyBranchTargets(targets: Array<BlockTreeBranch | BlockTreeBranchLeaf>):
        Array<BlockTreeBranch | BlockTreeBranchLeaf> {
        return targets.filter(target => target instanceof BlockTreeBranch &&
            target.isDroppable && (!target.children || !target.children.length));
    }

    private _getDropBeforeOrAfterTargets(targets: Array<BlockTreeBranch | BlockTreeBranchLeaf>):
        Array<BlockTreeBranch | BlockTreeBranchLeaf> {
        return targets.filter(target => target instanceof BlockTreeBranchLeaf &&
            target.parent.isDroppable && (target.isDroppableBefore || target.isDroppableAfter));
    }

    private _getSelectedDropOnTarget(targets: Array<BlockTreeBranch | BlockTreeBranchLeaf>): BlockTreeBranch | BlockTreeBranchLeaf {
        const selected = this._tactileBlockService.selected;
        return targets.find(t => this._isDroppableOn(t) && selected.indexOf(t.data) >= 0);
    }

    private _getSelectedDropBeforeOrAfterTarget(targets: Array<BlockTreeBranch | BlockTreeBranchLeaf>)
        : BlockTreeBranch | BlockTreeBranchLeaf {
        const selected = this._tactileBlockService.selected;
        return targets.find(t => (this._isDroppableBefore(t) || this._isDroppableAfter(t)) && selected.indexOf(t.data) >= 0);
    }

    private _getLastTarget(targets: Array<BlockTreeBranch | BlockTreeBranchLeaf>): BlockTreeBranch | BlockTreeBranchLeaf {
        return targets.length ? targets[targets.length - 1] : undefined;
    }

    private _isDroppableBefore(target: BlockTreeBranch | BlockTreeBranchLeaf, previous?: BlockTreeBranch | BlockTreeBranchLeaf): boolean {
        return target.parent && target.parent.isDroppable && target.isDroppableBefore && (!previous || previous.isDroppableAfter);
    }

    private _isDroppableAfter(target: BlockTreeBranch | BlockTreeBranchLeaf, next?: BlockTreeBranch | BlockTreeBranchLeaf): boolean {
        return target.parent && target.parent.isDroppable && target.isDroppableAfter && (!next || next.isDroppableBefore);
    }

    private _isDroppableOn(target: BlockTreeBranch | BlockTreeBranchLeaf): boolean {
        if (target instanceof BlockTreeBranch) {
            return target.isDroppable && !this._isFullyPopulated(target);
        } else if (target instanceof BlockTreeBranchLeaf) {
            return target.isDroppable;
        } else {
            return false;
        }
    }

    private _isFullyPopulated(parent: BlockTreeBranch | BlockTree): boolean {
        return parent && parent.maxChildren && parent.children.length >= parent.maxChildren;
    }
}
