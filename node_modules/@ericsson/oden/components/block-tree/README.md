[//]: # (title: Block tree)
[//]: # (category: Block Tree)
[//]: # (icon: fa-indent)

#Block tree
* import { BlockTreeModule, BlockTree, BlockTreeBranch, BlockTreeBranchLeaf } from '@ericsson/oden';

A block tree allows for configuring tactile blocks and Branching blocks in a hierarchy.

```
<cui-block-tree [blockTree]="BlockTree"
    (onBlockTreeChange)="function(null)"
    (onActionClick)="function($event)"
    (onSwitchChange)="function($event)"
    (onSelectTactileBlock)="function($event)"
    (onSelectBranch)="function($event)"
    (onDragStart)="function($event)"
    (onDragEnd)="function($event)"
    [placeholderTitle]="string"
    [placeholderDescription]="string"
    [placeholderActions]="Array<ButtonActionItem>"
    (onPlaceholderActionClick)="function($event)">
</cui-block-tree>

```

###[blockTree]:_BlockTree___*__
The most important input - this is your BlockTree model containing all branches and leaves.

```
export class BlockTree {
    id: string = `bt-${UUID.create()}`;
    title?: string;
    hideRootNode?: boolean; // set this to true to hide the root node
    isExpanded?: boolean = true;
    children?: Array<BlockTreeBranch>;
    actions?: Array<ActionItem | Divider> = [];
    switchLabels?: Array<String> = []; // put 1 or 2 strings in an array to put a custom Switcher on top of BlockTree
    maxChildren?: number = 0; // 0 = unlimited
    isSelectable?: boolean = false; // set to true to show an 'Edit' switcher on top
    isSelected?: boolean = false; // will become true when the 'Edit' switcher is active
    switcherValue?: any; // if switchLabels are used you can assign a default value to the switcher with this, typically true or false
    isDroppable?: boolean = true; // set to false if users shouldn't be able to drop items in the root node
    selectLabel?: string; // the label for the 'Edit' switcher if `isSelectable` is true.
}
```

###(onBlockTreeChange)_:function(null)_
This event will get triggered when the user adds or removes something from the block tree. Also triggered on reorder.

###(onActionClick)_:function({actionItem: ActionItem, model: BlockTreeBranch | BlockTree | BlockTreeBranchLeaf})_
This event will get triggered when the user clicks on an item inside a ActionMenu anywhere in the block tree and emits the action and which model it was clicked on.

###(onSwitchChange)_:function({model: BlockTreeBranch | BlockTree, switch: boolean})_
This event will get triggered when the user clicks on a Switcher element. It passes an object containing `model` which is the affected `BlockTreeBranch` (or `BlockTree` if you've selected the root node) and `switch`, a boolean, that tells if the Switcher is on or off.

###(onSelectTactileBlock)_:function(Array&lt;TactileBlockItem&gt;)_
This event will get triggered when the user selects a Tactile block in the tree. It will pass an array of the selected `TactileBlockItem`s (normally one or zero).

###(onSelectBranch)_:function(BlockTreeBranch | BlockTree)_
This event will get triggered when the user selects a Branching block (or the root node) in the Block tree by using the 'Edit' switcher. It will pass the selected `BlockTreeBranch` (or `BlockTree` if it's the root node).

###(onDragStart)_:function(Object)_
This event will get triggered when the user starts dragging an item in the block tree. It will emit the following object:

```
{
item: BlockTreeBranch | BlockTreeBranchLeaf,
isDragging: boolean,
elementRef: ElementRef
}
```

The onDragStart event makes it possible to validate custom rules before a BlockTreeBranch or BlockTreeBranchLeaf is dropped onto a BlockTree.

For example we could say that "If a dragged leaf is of type 'action' then set property isDroppableBefore = false on all leaves of type 'condition' in the BlockTree".
This will cause the drop of an action leaf to be rejected anywhere after a condition leaf.

By default no specific rules are applied.

###(onDragEnd)_:function(Object)_
This event will get triggered when the user stops dragging an item in the block tree. It will emit the same object as in `onDragStart`.

###(onPlaceholderActionClick)_:function(ButtonActionItem)_
This event will get triggered when one of the placeholder buttons are being clicked.

###[placeholderTitle]_:string_
Optional. Placeholder title to be shown when the block tree is empty.

###[placeholderDescription]_:string_
Optional. Placeholder description to be shown when the block tree is empty.

###[placeholderActions]_:Array&lt;ButtonActionItem&gt;_
Optional. Adds CTA buttons below placeholder message when the block tree is empty.

###[enablePositionDisplay]_:boolean_
Optional. Enables displaying index position of items.

##createBranchFunction()

When a leaf or a branch is dropped onto another leaf a new `BranchTreeBranch` should be created. This is done with `createBranchFunction` that you create yourself (preferably in `ngOnInit`), like this:

```
ngOnInit(): void {
    this._blockTreeService.createBranchFunction = (obj: any) => { // obj contains 'children' which contains the dragged and dropped models
        return new BlockTreeBranch({
            title: 'ALL',
            isOperator: true,
            children: obj.children,
            switchLabels: ['All', 'Any'],
            actions: [new ActionItem({action: 'remove', label: 'Remove'})]
        });
    }
    ...
}
```


##BlockTreeBranch

The BlockTree's children is an array of `BlockTreeBranch`, which look very similar to the BlockTree model.

```
export class BlockTreeBranch {
    id: string = `btb-${UUID.create()}`;
    isOperator?: boolean = false; // set to true to visualize the branch as an operator (ie 'ALL' or 'ANY')
    color?: string; // the color of the branch, only applicable if isOperator is true
    title?: string = 'Untitled';
    subtitle?: string;
    isDroppable?: boolean = true;
    maxChildren?: number = 0; // 0 = unlimited
    children?: Array<BlockTreeBranch | BlockTreeBranchLeaf> = [];
    isExpanded?: boolean = true;
    actions?: Array<ActionItem | Divider> = [];
    tags?: Array<Tag> = [];
    switchLabels?: Array<String> = [];
    isSelectable?: boolean = true;
    isSelected?: boolean = false;
    isDroppableBefore?: boolean = true; // set to false if you don't want users to be able to drop something directly before this branch
    isDroppableAfter?: boolean = true; // set to false if you don't want users to be able to drop something directly after this branch
    parent?: BlockTree | BlockTreeBranch; // will automatically be set to this branch's parent model
    showItemsCount?: boolean = true; // set to false to hide the items count next to the title
    switcherValue?: any;
    data?: any;
    selectLabel?: string = 'Edit'; // the label for the 'Edit' switcher if `isSelectable` is true.
    icon?: string = null;
    iconTooltip?: string = '';
}
```


##BlockTreeBranchLeaf

The leaves are the final destinations in the BlockTree. They contain very little information by themselves, but instead keeps ie an `TactileBlock` in their `data` property.

```
export class BlockTreeBranchLeaf {
    id: string = `btbl-${UUID.create()}`;
    isDroppable?: boolean = true;
    isDroppableBefore?: boolean = true;
    isDroppableAfter?: boolean = true;
    parent?: BlockTreeBranch;
    data: any;
    placeholderDescription: boolean = false;
    isNotOperator: boolean; // set to true to visualize the leaf as a 'NOT' condition, only useful in combination with the Rule visualisation component.
}
```


##Usage example

Here is an example on how you can create your BlockTree structure.

```
    actions: Array<ActionItem | Divider> = [
        new ActionItem({action: 'remove', label: 'Remove'})
    ];
    myTactileBlocks: Array<TactileBlockItem> = [
        new TactileBlockItem({
            title: 'Condition item 1',
            colorCode: '#F9BA00',
            menuActions: this.actions,
            subtitle: 'Condition',
            description: 'This is a description',
            type: ['condition'],
            childComponent: TactileBodyComponent,
            data: {uuid: UUID.create(),
                tags: [
                    new Tag({
                        value: 'Condition',
                        type: TAGTYPE.Condition,
                        tooltip: 'I am little tooltip'
                    })
                ]
            }
        }),
        new TactileBlockItem({
            title: 'Condition item 2',
            colorCode: '#F9BA00',
            menuActions: this.actions,
            subtitle: 'Condition',
            description: 'This is a <b>condition item</b> with tags',
            type: ['condition'],
            data: {uuid: UUID.create(),
                tags: [
                    new Tag({
                        value: 'Condition',
                        type: TAGTYPE.Condition,
                        tooltip: 'I am little tooltip'
                    })
                ]
            }
        })
    ];
    blockTree: BlockTree = new BlockTree({
        title: 'Root Node',
        isSelectable: true,
        hideRootNode: false,
        children: [
            new BlockTreeBranch({
                title: 'ALL',
                switchLabels: ['All', 'Any'],
                isOperator: true,
                isExpanded: true,
                actions: this.actions,
                children: [
                    new BlockTreeBranchLeaf({
                        isDroppableBefore: false,
                        isDroppableAfter: true,
                        data: this.myTactileBlocks[0]
                    }),
                    new BlockTreeBranchLeaf({
                        isDroppableBefore: true,
                        isDroppableAfter: false,
                        data: this.myTactileBlocks[1]
                    })
                ]
            })
        ]
    });
```

##Filtering a BlockTree

To create a filter for a BlockTree, simply put some Filter components above your tree, like this:

####component.html
```
    <cui-list-controller>
        <cui-list-controller-filter (onFilterChange)="onFilterTree($event)" [placeholder]="'Filter by name'"></cui-list-controller-filter>
        <cui-list-controller-category-filter
            (onCategoryFilterChange)="onCategoryFilter($event)"
            [filterGroup]="categoryFilterGroup"></cui-list-controller-category-filter>
    </cui-list-controller>
    <cui-block-tree [blockTree]="getBlockTree"
    ....
    ></cui-block-tree>
```

Then, in your component.ts-file, do something like this:

####component.ts
```
...
    blockTree: BlockTree;
    filteredBlockTree: BlockTree;
    filterString: string = '';
    filterCategories: Array<string> = [];
    categoryFilterGroup: ListControllerCategoryFilterGroup = new ListControllerCategoryFilterGroup({
        label: 'Categories',
        items: [
            new ListControllerCategoryFilterItem({label: 'Branches', field: 'branch'}),
            new ListControllerCategoryFilterItem({label: 'Conditions', field: 'condition'}),
            new ListControllerCategoryFilterItem({label: 'Actions', field: 'action'})
        ]
    });

    ngOnInit(): void {
        this.blockTree = ... // see example in 'Usage example' above
        this.filterCategories = this.categoryFilterGroup.items.map((o) => o['field']);
        this.filteredBlockTree = this.blockTree;
        ...
    }

    onFilterTree(filterString: string): void {
        this.filterString = filterString;
        // Reset filter and remove highlight tags if our search string is empty and all categories have been selected
        if ((this.filterString === '' || this.filterString === undefined) && this.filterCategories.length === 3) {
            this._blockTreeService.resetFilter();
            Array.from(document.querySelectorAll('.cui-block-tree .title, .cui-block-tree .subtitle, .cui-block-tree .description')).
            forEach((element: HTMLElement) => {
                element.innerHTML = element.innerText;
            });
        } else {
            const text = StringHelper.stripNonAlphanumeric(this.filterString);
            const regex = new RegExp('(' + text + ')', 'gi');
            // call the getFilteredBlockTree() function to get a filtered version of our blocktree
            this.filteredBlockTree = this._blockTreeService.getFilteredBlockTree(this.blockTree, this.filterString, (_item) => {
                // OUR FILTER FUNCTION
                return (this.filterString === undefined ||
                    (_item instanceof BlockTreeBranch && _item.title.match(regex) !== null) ||
                    (_item instanceof BlockTreeBranch && _item.subtitle && _item.subtitle.match(regex) !== null) ||
                    (_item instanceof BlockTreeBranchLeaf && _item.data.subtitle && _item.data.subtitle.match(regex) !== null) ||
                    (_item instanceof BlockTreeBranchLeaf && _item.data.description && _item.data.description.match(regex) !== null) ||
                    (_item instanceof BlockTreeBranchLeaf && _item.data.title.match(regex) !== null))
                    && ((_item instanceof BlockTreeBranch && this.filterCategories.indexOf('branch') > -1) ||
                    (_item instanceof BlockTreeBranchLeaf &&
                        (this.filterCategories.indexOf('action') > -1 && _item.data && _item.data.type.indexOf('action') > -1) ||
                        (this.filterCategories.indexOf('condition') > -1 && _item.data && _item.data.type.indexOf('condition') > -1)
                    ));
            }, (_item) => {
                // OUR HIGHLIGHT FUNCTION
                setTimeout(() => {
                    Array.from(document.querySelectorAll('#' + _item.id + ' .title, #' + _item.id + ' .subtitle, ' +
                        '#' + _item.id + ' .description')).forEach((element: HTMLElement) => {
                            element.innerHTML = DOMHelper.highlightString(this.filterString, element.innerText);
                    });

                })
            });
        }
    }

    onCategoryFilter(object: any) {
        this.filterCategories = object.ngModel.map((o) => o['field']);
        this.onFilterTree(this.filterString);
    }

    get getBlockTree(): BlockTree {
        // _blockTreeService.filterIsOn is true when we have called blockTreeService.getFilteredBlockTree()
        if (!this._blockTreeService.filterIsOn) {
            return this.blockTree;
        }
        return this.filteredBlockTree;
    }

```

*NB!* When a BlockTree is filtered, all drag and drop functions are disabled.

##Focusing and selecting programmatically

To select or focus an item in the BlockTree, call `selected` or `focused` in `BlockTreeService`.

```
this._blockTreeService.selected = 'id-of-branch-leaf-or-tree';
this._blockTreeService.focused = 'id-of-branch-leaf-or-tree';
```

You can do this from the same component where the BlockTree is rendered, or from another page and then navigate to the BlockTree page. The item will then be selected/focused once the BlockTree has been rendered.
