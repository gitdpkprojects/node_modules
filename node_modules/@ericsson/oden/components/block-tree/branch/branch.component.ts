import { BlockTreeService } from './../block-tree.service';
import { BlockTreeBranch } from './../../../core/models/block-tree-branch.model';
import { BlockTreeBranchLeaf } from './../../../core/models/block-tree-branch-leaf.model';
import {
    Component,
    ElementRef,
    EventEmitter,
    HostBinding,
    HostListener,
    Input,
    OnInit,
    Output,
    Renderer2,
    ViewEncapsulation
} from '@angular/core';
import { ANIMATION } from '../../../core/constants';
import {
    animate,
    state,
    style,
    transition,
    trigger
} from '@angular/animations';

import { ActionItem } from '../../../core/models';
import { DOMHelper } from '../../../core/helpers';
import { BlockTree } from '../../../core/models/block-tree.model';
import { KEYBOARD } from '../../../core/constants/keyboard.constants';
import { TimeHelper } from '../../../core/helpers/time.helper';

@Component({
    selector: 'cui-block-tree-branch',
    templateUrl: 'branch.component.html',
    styleUrls: ['branch.component.scss'],
    encapsulation: ViewEncapsulation.None,
    animations: [
        trigger('state', [
            state(
                '*',
                style({
                    height: '58px'
                })
            ),
            state(
                'expanded',
                style({
                    height: '*'
                })
            ),
            transition(
                '* => expanded',
                animate('100ms ' + ANIMATION.EASE_OUT_QUAD)
            ),
            transition(
                'expanded => *',
                animate('100ms ' + ANIMATION.EASE_OUT_QUAD)
            )
        ])
    ]
})
export class BlockTreeBranchComponent implements OnInit {
    @HostBinding('attr.id')
    get id(): string {
        return this.branchModel.id;
    }
    @HostBinding('class.newly-created')
    get newlyCreated(): boolean {
        return this.branchModel.newlyCreated;
    }
    @HostBinding('class.clickable')
    get isClickable(): boolean {
        return (
            this.branchModel.isExpanded &&
            this.branchModel.isSelectable &&
            !this.branchModel.isOperator
        );
    }
    @HostBinding('class.cui-block-tree-branch')
    addClass: boolean = true;
    @HostBinding('class.expanded')
    get isExpanded(): boolean {
        return this.branchModel.isExpanded;
    }
    @HostBinding('class.engaged')
    get isEngaged(): boolean {
        return this.branchModel.state.engaged;
    }
    @HostBinding('class.focus')
    get isFocused(): boolean {
        return this.branchModel.state.focused;
    }
    @HostBinding('class.hover-to-open')
    get hoverToOpen(): boolean {
        return this.branchModel.state.hoverToOpen;
    }
    @HostBinding('class.operator')
    get isOperator(): boolean {
        return this.branchModel.isOperator;
    }
    @HostBinding('class.selected')
    get isSelected(): boolean {
        return this.branchModel.isSelected;
    }
    @HostBinding('class.parent-is-tree')
    get parentIsTree(): boolean {
        return (
            this.branchModel.parent &&
            this.branchModel.parent instanceof BlockTree
        );
    }
    @HostBinding('style.border-color')
    get borderColor(): string {
        return this.branchModel.isOperator && this.branchModel.color
            ? this.branchModel.color
            : null;
    }
    @HostBinding('tabindex')
    @Input()
    tabIndex: number = 0;
    @HostBinding('class.display-position')
    get shouldDisplayPosition(): boolean {
        return this.enablePositionDisplay && this.parentIsTree;
    }
    @Output()
    onActionClick: EventEmitter<ActionItem> = new EventEmitter<ActionItem>();
    @Output()
    onDrag: EventEmitter<BlockTreeBranchComponent> = new EventEmitter<
        BlockTreeBranchComponent
    >();
    @Input()
    branchModel: BlockTreeBranch;
    @Input()
    parent: BlockTreeBranch | BlockTree;
    @Input()
    enablePositionDisplay: boolean = false;
    blockTreeBranch = BlockTreeBranch;
    blockTreeBranchLeaf = BlockTreeBranchLeaf;

    switcher: any;
    private isExpanding: boolean = false;
    private _isMouseDown: boolean = false;
    @HostBinding('@state')
    get state(): string {
        return this.isExpanded ? 'expanded' : 'collapsed';
    }
    get itemsCount(): number {
        return this.branchModel.children.length;
    }
    get filterIsOn(): boolean {
        return this._blockTreeService.filterIsOn;
    }
    get children(): Array<BlockTreeBranch | BlockTreeBranchLeaf> {
        return this._blockTreeService.filterIsOn
            ? this.branchModel.filterChildren
            : this.branchModel.children;
    }
    constructor(
        private _element: ElementRef,
        private _renderer: Renderer2,
        private _blockTreeService: BlockTreeService
    ) {}

    ngOnInit(): void {
        this.branchModel.parent = this.parent;
        if (this.branchModel.switcherValue !== undefined) {
            this.switcher = this.branchModel.switcherValue;
        }
        setTimeout(() => {
            this.branchModel.newlyCreated = false;
        }, 500);
    }

    /**
     * Triggers when we drop on something that is already full or not droppable.
     */
    onReject(event) {
        this.clearInterval();
        setTimeout(() => {
            this._blockTreeService.onReject(event, this._renderer);
        });
    }

    isDroppable(child: BlockTreeBranch): boolean {
        return (
            child.isExpanded &&
            !this.filterIsOn &&
            child.isDroppable &&
            (!child.children.length ||
                child.children.filter(
                    (_child: BlockTreeBranch | BlockTreeBranchLeaf) => {
                        return (
                            _child.isDroppableAfter || _child.isDroppableBefore
                        );
                    }
                ).length > 0)
        );
    }

    /**
     * Returns true if the item is draggable depending on isDraggable property and if it's collapsed (branches only)
     * @param {BlockTreeBranch | BlockTreeBranchLeaf} child
     * @returns {boolean}
     */
    isDraggable(child: BlockTreeBranch | BlockTreeBranchLeaf): boolean {
        return (
            !this.filterIsOn &&
            child.isDraggable &&
            ((child instanceof BlockTreeBranch && !child.isExpanded) ||
                child instanceof BlockTreeBranchLeaf)
        );
    }

    /**
     * This function triggers when the user clicks on the branch
     * @param {MouseEvent} event
     */
    clickBranch(event: MouseEvent): void {
        if (
            this.branchModel.isSelectable &&
            !this.branchModel.isOperator &&
            !DOMHelper.isChildOfElement('.cui-action-menu', <Node>event.target)
        ) {
            this.branchModel.isSelected = !this.branchModel.isSelected;
            this.selectChange();
            event.stopImmediatePropagation();
        }
    }

    /**
     * Event handler for when a BlockTreeBranch or a BlockTreeBranchLeaf is dropped
     *
     * @param {BlockTreeBranch | BlockTreeBranchLeaf} droppedAt
     * @param {BlockTreeBranch | BlockTreeBranchLeaf} dragged
     */
    onBlockDrop(
        droppedAt: BlockTreeBranchLeaf,
        dragged: BlockTreeBranch | BlockTreeBranchLeaf
    ): void {
        dragged.newlyCreated = true;
        this._blockTreeService.blockDropped(dragged, droppedAt, this._renderer);
        this.clearInterval();
        this._blockTreeService.hideAllVisibleDropElements.emit();
    }

    /**
     * Event handler for when a BlockTreeBranch or a BlockTreeBranchLeaf is dropped
     * on an empty position
     *
     * @param {BlockTreeBranch | BlockTreeBranchLeaf} dragged
     * @param {BlockTreeBranch} droppedAt
     * @param {number} droppedAtIndex
     */
    onBlockDropAtEmptyPosition(
        dragged: BlockTreeBranch | BlockTreeBranchLeaf,
        droppedAt: BlockTreeBranch,
        droppedAtIndex: number
    ) {
        dragged.newlyCreated = true;
        this._blockTreeService.blockDroppedAtEmptyPosition(
            dragged,
            <BlockTreeBranch>droppedAt,
            droppedAtIndex,
            this._renderer
        );
        this.clearInterval();
        this._blockTreeService.hideAllVisibleDropElements.emit();
    }

    /**
     * Event handler for when a BlockTreeBranch or a BlockTreeBranchLeaf is dropped
     * directly on a BlockTreeBranch
     *
     * @param {BlockTreeBranch} droppedAt
     * @param {BlockTreeBranch | BlockTreeBranchLeaf} dragged
     */
    onBranchDrop(
        droppedAt: BlockTreeBranch,
        dragged: BlockTreeBranch | BlockTreeBranchLeaf
    ): void {
        dragged.newlyCreated = true;
        this._blockTreeService.branchDropped(
            droppedAt,
            dragged,
            this._renderer
        );
        this.clearInterval();
        this._blockTreeService.hideAllVisibleDropElements.emit();
    }

    @HostListener('keydown', ['$event'])
    enterPress(event: KeyboardEvent): void {
        if (
            this._element.nativeElement === document.activeElement &&
            (event.keyCode === KEYBOARD.ENTER ||
                event.keyCode === KEYBOARD.SPACE)
        ) {
            this.toggleBranch(event);
            event.preventDefault();
        }
    }

    /**
     * Toggles a branch between expanded and not expanded
     * @param {Event} event
     */
    toggleBranch(event: Event): void {
        event.stopPropagation();
        this.branchModel.isExpanded = !this.branchModel.isExpanded;
    }

    /**
     * If user clicks outside branch and it's selected, let's make it unselected
     */
    @HostListener('document:click')
    public onDocumentClick(): void {
        if (
            this.branchModel.isSelected &&
            document.body.contains(<Node>event.target) &&
            !this._element.nativeElement.contains(<Node>event.target) &&
            !DOMHelper.isChildOfElement('.cui-drawer', <Node>event.target) &&
            !(<HTMLElement>event.target).classList.contains('cui-backdrop') &&
            !DOMHelper.isChildOfElement('.overlay-component', <Node>(
                event.target
            ))
        ) {
            this.branchModel.isSelected = false;
            this.branchModel.state.focused = false;
            this._blockTreeService.selectChange(this.branchModel);
        }
    }

    /**
     * We only *show* the focus style when focus has come to the element via the keyboard.
     * We make this work with the _isMouseDown variable.
     */
    @HostListener('mousedown')
    public onMouseDown(): void {
        this._isMouseDown = true;
        this.branchModel.state.focused = false;
        setTimeout(() => {
            this._isMouseDown = false;
        }, 100);
    }

    /**
     * Returns true if we are to a dropelement
     *
     * @param {BlockTreeBranch} branchModel
     * @param {number} i
     * @returns {boolean}
     */
    showDropElement(branchModel: BlockTreeBranch, i: number): boolean {
        return (
            !this.filterIsOn &&
            branchModel.isDroppable &&
            ((branchModel.children[i + 1] &&
                branchModel.children[i + 1].isDroppableBefore &&
                (branchModel.children[i] &&
                    branchModel.children[i].isDroppableAfter)) ||
                (!branchModel.children[i + 1] &&
                    branchModel.children[i] &&
                    branchModel.children[i].isDroppableAfter))
        );
    }

    /**
     * Event handler for when a branch's switch is changed
     */
    switchChange(): void {
        this._blockTreeService.switchChange(this.branchModel, this.switcher);
        this.branchModel.state.visibleChilds = false;
    }

    selectChange(): void {
        this._blockTreeService.selectChange(this.branchModel);
        this.branchModel.state.visibleChilds = false;
    }

    /**
     * Action dispatcher for onActionClick
     * @param actionItem
     */
    actionClick(actionItem: ActionItem): void {
        this._blockTreeService.actionClick(actionItem, this.branchModel);
    }

    /**
     * When a draggable is hovering one of the branches under this branch, we start timing
     * and opens up the branch after 2 seconds of hovering.
     * @param {HTMLElement} element
     * @param {BlockTreeBranch} child
     */
    async toggleExpandTimeout(
        element: HTMLElement,
        child: BlockTreeBranch
    ): Promise<void> {
        if (
            !this.isExpanding &&
            !child.isExpanded &&
            !element.classList.contains('currently-dragging-clone')
        ) {
            this.isExpanding = true;
            await TimeHelper.wait(100);
            if (!child.isExpanded) {
                child.state.hoverToOpen = true;
            }
            await TimeHelper.wait(800);
            if (!child.isExpanded) {
                child.isExpanded = true;
                this.clearInterval();
            }
        }
    }

    /**
     * Clear the toggleExpandTimeout counter when leaving the branch
     */
    onLeave(): void {
        this.clearInterval();
    }

    toggleParentEngaged(addClass: boolean): void {
        this._blockTreeService.toggleParentEngaged(this.branchModel, addClass);
    }

    clearInterval(): void {
        this._blockTreeService.setStateRecursive('hoverToOpen', false, this.branchModel);
        this.isExpanding = false;
    }

    @HostListener('focus', ['$event'])
    onFocus(): void {
        this.branchModel.state.focused = !this._isMouseDown;
    }

    @HostListener('blur', ['$event'])
    onBlur(): void {
        this.branchModel.state.focused = false;
    }

    @HostListener('mouseover', ['$event'])
    onMouseOver(event: MouseEvent): void {
        this.branchModel.state.visibleChilds = true;
        this.branchModel.parent.state.visibleChilds = false;
        event.stopPropagation();
    }

    @HostListener('mouseleave', ['$event'])
    onMouseLeave(event: MouseEvent): void {
        this.branchModel.state.visibleChilds = false;
        this.branchModel.parent.state.visibleChilds = true;
        event.stopPropagation();
    }
}
