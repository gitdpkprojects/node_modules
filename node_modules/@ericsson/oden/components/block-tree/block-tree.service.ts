import { EventEmitter, Injectable, Renderer2 } from '@angular/core';
import { TactileBlockItem } from '../../core/models/tactile-block-item.model';
import { ActionItem } from '../../core/models/action-item.model';
import { BlockTreeBranchLeaf } from '../../core/models/block-tree-branch-leaf.model';
import { BlockTreeBranch } from '../../core/models/block-tree-branch.model';
import { BlockTree } from '../../core/models/block-tree.model';
import { LibraryService } from '../../core/services/library.service';
import { TactileBlockService } from '../tactile-block/tactile-block.service';
import { BlockTreeHelper } from './block-tree.helper';
import { DragAndDropService } from '../drag-and-drop/drag-and-drop.service';
import { TimeHelper } from '../../core/helpers/time.helper';

@Injectable()
export class BlockTreeService {
    public onBlockTreeChange: EventEmitter<null> = new EventEmitter<null>();
    public onSwitchChange: EventEmitter<any> = new EventEmitter<any>();
    public onSelectBranch: EventEmitter<
        BlockTreeBranch | BlockTree
    > = new EventEmitter<BlockTreeBranch | BlockTree>();
    public onActionClick: EventEmitter<any> = new EventEmitter<any>();
    public onSelectItem: EventEmitter<string> = new EventEmitter<string>();
    public onFocusItem: EventEmitter<string> = new EventEmitter<string>();
    public hideAllVisibleDropElements: EventEmitter<null> = new EventEmitter<null>();
    public showDropElements: EventEmitter<null> = new EventEmitter<null>();
    public filterTriggered: boolean = false;
    public filterIsOn: boolean = false;
    public filterFunction: Function;
    public highlightFunction: Function;
    public filterString: string;
    public justFocused: boolean = false;
    public _selected: string;
    public _focused: string;

    private _createBranchFunction: (Object) => BlockTreeBranch;

    private _flattenedBranches: Array<BlockTreeBranch> = [];
    private _flattenedOfType: Array<BlockTreeBranch | BlockTreeBranchLeaf> = [];
    private _blockTree: BlockTree;
    private _timeout;
    private _prevIsDroppable: boolean;

    constructor(
        private _libraryService: LibraryService,
        private _tactileBlockService: TactileBlockService,
        private dragAndDropService: DragAndDropService
    ) { }

    emitTree() {
        this.onBlockTreeChange.emit();
    }

    set createBranchFunction(func: (Object) => BlockTreeBranch) {
        this._createBranchFunction = func;
    }

    get selected(): string {
        return this._selected;
    }
    set selected(id: string) {
        this._selected = id;
        if (id) {
            this.onSelectItem.emit(id);
        }
    }
    get focused(): string {
        return this._focused;
    }
    set focused(id: string) {
        this._focused = id;
        if (id) {
            this.justFocused = true;
            this.onFocusItem.emit(id);
            setTimeout(() => {
                this.justFocused = false;
            }, 100);
        }
    }

    /**
     * Handler for when a branch or leaf is dropped on a leaf
     * @param {BlockTreeBranch | BlockTreeBranchLeaf} dragged
     * @param {BlockTreeBranch | BlockTreeBranchLeaf} droppedAt
     * @param {Renderer2} renderer
     */
    blockDropped(
        dragged: BlockTreeBranch | BlockTreeBranchLeaf | TactileBlockItem,
        droppedAt: BlockTreeBranchLeaf,
        renderer: Renderer2
    ): void {
        if (dragged === droppedAt) {
            return;
        }
        if (dragged instanceof TactileBlockItem) {
            this._libraryService.added$.emit(dragged);
            dragged = BlockTreeHelper.convertTactileToBlockTreeModel(dragged);
        } else if (dragged.parent) {
            this.recursiveIndexOfSplice(dragged.parent, dragged);
        }
        this.recursiveIndexOfAppend(
            droppedAt.parent,
            dragged,
            droppedAt,
            renderer
        );
    }

    toggleParentEngaged(
        item: BlockTree | BlockTreeBranch,
        engaged: boolean
    ): void {
        item.state.engaged = engaged;
    }

    setStateRecursive(
        key: string,
        value: any,
        tree: BlockTree | BlockTreeBranch | BlockTreeBranchLeaf
    ) {
        if (!tree || tree instanceof BlockTreeBranchLeaf) {
            return;
        }
        tree.state[key] = value;
        tree.children.forEach(branch => {
            branch.state[key] = value;
            if (tree instanceof BlockTreeBranchLeaf) {
                return;
            }
            this.setStateRecursive(key, value, branch);
        });
    }

    /**
     * Handler for when a branch or leaf is dropped in an empty area
     *
     * @param {BlockTreeBranchLeaf | BlockTreeBranch} dragged
     * @param {BlockTreeBranch} droppedAt
     * @param {number} droppedAtIndex
     * @param {Renderer2} renderer
     */
    blockDroppedAtEmptyPosition(
        dragged: BlockTreeBranch | BlockTreeBranchLeaf | TactileBlockItem,
        droppedAt: BlockTreeBranch,
        droppedAtIndex: number,
        renderer: Renderer2
    ) {
        if (!dragged) {
            throw new TypeError('"dragged" was undefined');
        }
        if (dragged === droppedAt) {
            return;
        }
        if (dragged instanceof TactileBlockItem) {
            this._libraryService.added$.emit(dragged);
            dragged = BlockTreeHelper.convertTactileToBlockTreeModel(dragged);
        } else if (dragged.parent) {
            dragged.newlyCreated = true;
            const draggedFromIndex = this.recursiveIndexOfSplice(
                dragged.parent,
                dragged
            );
            if (
                dragged.parent === droppedAt &&
                draggedFromIndex < droppedAtIndex
            ) {
                droppedAtIndex -= 1;
            }
        }
        droppedAt.children.splice(droppedAtIndex, 0, dragged);
        this.emitTree();
        this.animateDrop(dragged, renderer);
    }

    /**
     * Event handler for when a BlockTreeBranch or a BlockTreeBranchLeaf is dropped
     * on an empty position on tree root level
     *
     * @param {BlockTreeBranch | BlockTreeBranchLeaf} dragged
     * @param {BlockTree} droppedAt
     * @param {number} droppedAtIndex
     * @param {Renderer2} renderer
     */
    blockDroppedAtRootPosition(
        dragged: BlockTreeBranch | BlockTreeBranchLeaf | TactileBlockItem,
        droppedAt: BlockTree,
        droppedAtIndex: number,
        renderer: Renderer2
    ) {
        if (dragged instanceof TactileBlockItem) {
            this._libraryService.added$.emit(dragged);
            dragged = BlockTreeHelper.convertTactileToBlockTreeModel(dragged);
        } else if (dragged.parent) {
            const draggedFromIndex = this.recursiveIndexOfSplice(
                dragged.parent,
                dragged
            );
            if (
                dragged.parent === droppedAt &&
                draggedFromIndex < droppedAtIndex
            ) {
                droppedAtIndex -= 1;
            }
        }
        droppedAt.children.splice(droppedAtIndex, 0, dragged);
        this.emitTree();
        this.animateDrop(dragged, renderer);
    }

    /**
     * Event handler for when a BlockTreeBranch or a BlockTreeBranchLeaf is dropped
     * directly on a BlockTreeBranch
     *
     * @param {BlockTreeBranch} droppedAt
     * @param {BlockTreeBranch | BlockTreeBranchLeaf} dragged
     * @param {Renderer2} renderer
     */
    branchDropped(
        droppedAt: BlockTreeBranch,
        dragged: BlockTreeBranch | BlockTreeBranchLeaf | TactileBlockItem,
        renderer: Renderer2
    ) {
        if (dragged === droppedAt) {
            return;
        }

        const indexToInsert = BlockTreeHelper.findInsertionIndex(droppedAt);
        if (indexToInsert > -1) {
            if (dragged instanceof TactileBlockItem) {
                this._libraryService.added$.emit(dragged);
                dragged = BlockTreeHelper.convertTactileToBlockTreeModel(
                    dragged
                );
            }
            // Dragged must have a parent for us to know what index to remove it from; else: Do not remove
            if (dragged.parent) {
                this.recursiveIndexOfSplice(dragged.parent, dragged);
            }
            droppedAt.children.splice(indexToInsert, 0, dragged);
            this.emitTree();
            this.animateDrop(dragged, renderer);
        }
    }

    /**
     * Removes objToRemove from the block tree
     *
     * @param {BlockTree | BlockTreeBranch | BlockTreeBranchLeaf} parent
     * @param {Array<BlockTreeBranch | BlockTreeBranchLeaf>} children
     * @param {BlockTreeBranch | BlockTreeBranchLeaf} objToRemove
     */
    recursiveIndexOfSplice(
        parent: BlockTree | BlockTreeBranch,
        objToRemove: BlockTreeBranch | BlockTreeBranchLeaf
    ): number {
        const indexToSplice = parent.children.indexOf(objToRemove);
        if (indexToSplice > -1) {
            parent.children.splice(indexToSplice, 1);
            this.emitTree();
            return indexToSplice;
        } else {
            parent.children.forEach(child => {
                if (child instanceof BlockTreeBranch) {
                    this.recursiveIndexOfSplice(child, objToRemove);
                }
            });
        }
        return -1;
    }

    async animateDrop(dragged, renderer: Renderer2): Promise<void> {
        renderer.addClass(document.body, 'animating-drop');
        const cloneAnimDurMs = 420;
        BlockTreeHelper.setDraggedVisible(cloneAnimDurMs);

        const currentlyDragging = this.dragAndDropService.current.clone;
        await TimeHelper.wait(0);
        if (!dragged) {
            return;
        }
        let draggedHTMLElement = document.getElementById(dragged.id);
        if (!draggedHTMLElement) {
            draggedHTMLElement = document.getElementById('tactile-' + dragged.id);
        }
        if (!draggedHTMLElement) {
            return;
        }
        draggedHTMLElement.style.opacity = '0';
        renderer.addClass(currentlyDragging, 'is-animating');
        const {
            top,
            left
        } = draggedHTMLElement.getBoundingClientRect();
        Object.assign(currentlyDragging.style, {
            top: top + 'px',
            left: left + 'px',
            width: draggedHTMLElement.offsetWidth + 'px',
            height: draggedHTMLElement.offsetHeight + 'px',
            maxWidth: draggedHTMLElement.offsetWidth + 'px',
            maxHeight: draggedHTMLElement.offsetHeight + 'px'
        });

        await TimeHelper.wait(cloneAnimDurMs);
        draggedHTMLElement.style.opacity = null;
        currentlyDragging.style.opacity = '0';
        await TimeHelper.wait(cloneAnimDurMs * 2);
        renderer.removeClass(document.body, 'animating-drop');
    }

    /**
     * Digs through the whole block tree and unselects each branch and tactile block (except exceptBranch if provided)
     * @param {BlockTree} blockTree
     * @param {Array<BlockTreeBranch | BlockTreeBranchLeaf>} children
     * @param {BlockTree | BlockTreeBranch} exceptBranch
     */
    unselectAll(
        blockTree: BlockTree,
        children: Array<BlockTreeBranch | BlockTreeBranchLeaf>,
        exceptBranch?: BlockTree | BlockTreeBranch
    ): void {
        if (!exceptBranch || exceptBranch !== blockTree) {
            blockTree.isSelected = false;
        }
        children.forEach((child: BlockTreeBranch | BlockTreeBranchLeaf) => {
            if (!exceptBranch || exceptBranch !== child) {
                if (child instanceof BlockTreeBranch) {
                    child.isSelected = false;
                } else if (
                    child.data instanceof TactileBlockItem &&
                    exceptBranch &&
                    exceptBranch.isSelected
                ) {
                    const index = this._tactileBlockService.selected.indexOf(
                        child.data
                    );
                    if (index > -1) {
                        this._tactileBlockService.selected.splice(index, 1);
                    }
                }
            }
            if (child instanceof BlockTreeBranch && child.children.length) {
                this.unselectAll(blockTree, child.children, exceptBranch);
            }
        });
    }

    /**
     * Creates a branch for given children
     */
    createBranch(children: Array<BlockTreeBranch | BlockTreeBranchLeaf>): BlockTreeBranch {
        if (this._createBranchFunction !== undefined) {
            const wrappingBranch = this._createBranchFunction({
                children: children
            });
            if (wrappingBranch instanceof BlockTreeBranch) {
                return wrappingBranch;
            } else {
                throw new TypeError(
                    'Invalid item created. Expecting type BlockTreeBranch.'
                );
            }
        } else {
            throw new TypeError(
                'createBranchFunction not found. Please define one.'
            );
        }
    }

    /**
     * Appends branch or leaf to where it was dropped
     * Creates a new branch if dragged onto a leaf
     *
     * @param {BlockTreeBranch} parent
     * @param {BlockTreeBranch | BlockTreeBranchLeaf} dragged
     * @param {BlockTreeBranch | BlockTreeBranchLeaf} droppedAt
     * @param {Renderer2} renderer
     */
    recursiveIndexOfAppend(
        parent: BlockTreeBranch,
        dragged: BlockTreeBranch | BlockTreeBranchLeaf,
        droppedAt: BlockTreeBranchLeaf,
        renderer: Renderer2
    ) {
        if (parent.children.indexOf(droppedAt) > -1) {
            const wrappingBranch = this.createBranch([droppedAt, dragged]);
            // Get the index on where to append wrapping branch
            const droppedAtIndexForWrappingBranch = this.getIndexToAppendWrappingBranch(
                parent,
                droppedAt
            );

            // Remove the old leaf location which was dropped at
            this.recursiveIndexOfSplice(parent, droppedAt);
            this.appendWrappingBranchToParentsChildren(
                parent,
                wrappingBranch,
                droppedAtIndexForWrappingBranch,
                renderer
            );
        } else {
            // Did not find the index on this level: Continue the search one level down
            parent.children.forEach(child => {
                if (child instanceof BlockTreeBranch) {
                    this.recursiveIndexOfAppend(
                        child,
                        dragged,
                        droppedAt,
                        renderer
                    );
                }
            });
        }
    }

    startFilter(blockTree: BlockTree): void {
        this._blockTree = blockTree;
        this._prevIsDroppable = this._blockTree.isDroppable;
        this._blockTree.isDroppable = false;
        this.filterIsOn = true;
    }

    /**
     * Returns a filtered tree
     * @param {BlockTree} blockTree
     * @param {string} filter
     * @param {Function} filterFunction
     * @param {Function} highlightFunction
     * @returns {BlockTree}
     */
    getFilteredBlockTree(
        blockTree: BlockTree,
        filter: string,
        filterFunction: Function,
        highlightFunction?: Function
    ): BlockTree {
        if (!this.filterIsOn) {
            this.startFilter(blockTree);
        }
        this.fixAnimations();
        this.filterString = filter;
        this.filterFunction = filterFunction;
        this.highlightFunction = highlightFunction;
        this._blockTree.filterChildren = this.iterateTreeWithFilter(
            this._blockTree
        );
        return this._blockTree;
    }

    fixAnimations(): void {
        const style: HTMLStyleElement = document.createElement('style');
        style.innerText =
            '.cui-block-tree, .cui-block-tree * { transition: none!important; }';
        document.body.appendChild(style);
        setTimeout(() => {
            document.body.removeChild(style);
        }, 500);
        clearTimeout(this._timeout);
        this.filterTriggered = true;
        this._timeout = setTimeout(() => {
            this.filterTriggered = false;
        }, 500);
        if (this._blockTree) {
            const selectedBranch = BlockTreeHelper.getSelectedBranch(
                this._blockTree,
                this._blockTree.children
            );
            const selectedTactile = this._tactileBlockService.selected;
            if (selectedBranch || selectedTactile) {
                this.unselectAll(this._blockTree, this._blockTree.children);
                if (selectedBranch) {
                    this.selectChange(selectedBranch);
                }
                if (selectedTactile) {
                    this._tactileBlockService.selected = [];
                }
            }
        }
    }

    onReject(dragged, renderer: Renderer2) {
        this.animateDrop(dragged, renderer);
    }

    onDropOutside(dragged, renderer: Renderer2) {
        this.animateDrop(dragged, renderer);
    }

    /**
     * Call this reset filter just before resetting the block tree to make reset variables and also make sure the
     * tree animation doesn't glitch.
     */
    resetFilter(): void {
        this.fixAnimations();
        this.filterIsOn = false;
        this._blockTree.filterChildren = [];
        this._blockTree.isDroppable = this._prevIsDroppable;
    }

    /**
     * Iterates the tree and all branches, calling itself and running filterFunction/highlightFunction
     * @param {BlockTreeBranch | BlockTree} item
     * @returns {any}
     */
    iterateTreeWithFilter(
        item: any
    ): Array<BlockTreeBranch | BlockTreeBranchLeaf> {
        if (!item.children) {
            return [];
        }
        return item.children.filter((child: any) => {
            if (child instanceof BlockTreeBranch && child.children) {
                child.matchesFilter = this.filterFunction(child);
                child.isExpanded = false;
                let visible = child.matchesFilter;
                child.filterChildren = this.iterateTreeWithFilter(child);
                if (child.filterChildren.length) {
                    visible = true;
                }
                if (visible) {
                    child.parent.isExpanded = true;
                }
                if (child.matchesFilter && this.highlightFunction) {
                    this.highlightFunction(child);
                }
                return visible;
            } else {
                const show = this.filterFunction(child);
                if (child instanceof BlockTreeBranch) {
                    child.isExpanded = false;
                }
                if (show) {
                    child.parent.isExpanded = true;
                    if (this.highlightFunction) {
                        this.highlightFunction(child);
                    }
                }
                return show;
            }
        });
    }

    /**
     * Returns an array with branches of a given type in a block tree
     * @param {BlockTree} parent
     * @returns {Array<BlockTreeBranch>}
     */
    getAllBranchesOfType(
        type: string,
        parent: BlockTree
    ): Array<BlockTreeBranch> {
        this._flattenedBranches = [];
        if (type) {
            return this.recursiveGetAllBranchesOfType(type, parent);
        }
        return [];
    }

    /**
     * Recursively picks up and returns branches of a given type in a block tree
     * @param parent
     * @returns {Array<BlockTreeBranchLeaf>}
     */
    recursiveGetAllBranchesOfType(
        type: string,
        parent: BlockTree | BlockTreeBranch
    ): Array<BlockTreeBranch> {
        if (parent instanceof BlockTreeBranch) {
            this._flattenedBranches.push(parent);
        }
        // Firstly: Check if parent has any branch children ...
        const branchesChildren = parent.children.filter(
            child =>
                child instanceof BlockTreeBranch &&
                child.data.type.indexOf(type) > -1
        );
        // ... If so, keep on looking in these as well
        if (branchesChildren.length) {
            parent.children.forEach(child =>
                this.recursiveGetAllBranchesOfType(type, child)
            );
        }
        // No more levels down - Return all branches in an array
        return this._flattenedBranches;
    }

    /**
     * Returns an array with all branches in a block tree
     * @param {BlockTree} parent
     * @returns {Array<BlockTree | BlockTreeBranch>}
     */
    getAllBranches(parent: BlockTree): Array<BlockTree | BlockTreeBranch> {
        this._flattenedBranches = [];
        return this.recursiveGetAllBranches(parent);
    }

    /**
     * Recursively picks up and returns all branches in a block tree
     * @param parent
     * @returns {Array<BlockTreeBranchLeaf>}
     */
    recursiveGetAllBranches(
        parent: BlockTree | BlockTreeBranch
    ): Array<BlockTreeBranch> {
        if (parent instanceof BlockTreeBranch || parent instanceof BlockTree) {
            this._flattenedBranches.push(parent);
        }
        // Firstly: Check if parent has any branch children ...
        const branchesChildren = (parent.children || []).filter(
            child => child instanceof BlockTreeBranch
        );
        // ... If so, keep on looking in these as well
        if (branchesChildren.length) {
            parent.children.forEach(child =>
                this.recursiveGetAllBranches(child)
            );
        }
        // No more levels down - Return all branches in an array
        return this._flattenedBranches;
    }

    /**
     * Returns an array with leaves of a given type
     *
     * @param {string} type
     * @param parent
     * @param onlyFirstLevel boolean
     * @returns {Array<BlockTreeBranchLeaf>}
     */
    getAllLeavesOfType(
        type: string,
        parent: any,
        onlyFirstLevel?: boolean
    ): Array<BlockTreeBranchLeaf> {
        this._flattenedOfType = [];
        if (type) {
            return this.recursiveGetAllLeavesOfType(
                type,
                parent,
                onlyFirstLevel
            );
        }
        return [];
    }

    /**
     * Recursively picks up and returns all leaves of a given type
     *
     * @param {string} type
     * @param parent
     * @param onlyFirstLevel boolean
     * @returns {Array<BlockTreeBranchLeaf>}
     */
    recursiveGetAllLeavesOfType(
        type: string,
        parent: any,
        onlyFirstLevel: boolean
    ): Array<BlockTreeBranchLeaf> {
        const childrenOfType = (parent.children || []).filter((child: any) => {
            if (child instanceof BlockTreeBranch && !onlyFirstLevel) {
                this.recursiveGetAllLeavesOfType(type, child, onlyFirstLevel);
            }
            return (
                child.data &&
                child instanceof BlockTreeBranchLeaf &&
                child.data.type.indexOf(type) > -1
            );
        });
        childrenOfType.forEach(child => this._flattenedOfType.push(child));

        // Firstly: Check if parent has any branch children ...
        const branchesChildren =
            parent.children && !onlyFirstLevel
                ? parent.children.filter(child => {
                    return child instanceof BlockTreeBranch;
                })
                : [];

        if (branchesChildren.length) {
            parent.children.forEach(child => {
                this.recursiveGetAllLeavesOfType(type, child, onlyFirstLevel);
            });
        }
        // No more levels down - Return all branches in an array
        return <Array<BlockTreeBranchLeaf>>this._flattenedOfType;
    }

    /**
     * Returns a BlockTree | BlockTreeBranch | BlockTreeBranchLeaf that matches provided id
     * @param {string} id
     * @param {BlockTree} tree
     * @param {Array<BlockTreeBranch | BlockTreeBranchLeaf>} children
     * @returns {BlockTree | BlockTreeBranch | BlockTreeBranchLeaf}
     */
    getById(
        id: string,
        tree: BlockTree = this._blockTree,
        children?: Array<BlockTreeBranch | BlockTreeBranchLeaf>
    ): BlockTree | BlockTreeBranch | BlockTreeBranchLeaf {
        if (tree.id === id) {
            return tree;
        }
        if (!children) {
            children = tree.children;
        }
        let _return = null;
        children.forEach((child: BlockTreeBranch | BlockTreeBranchLeaf) => {
            if (child.id === id) {
                _return = child;
            } else if (
                !_return &&
                child instanceof BlockTreeBranch &&
                child.children.length
            ) {
                _return = this.getById(id, tree, child.children);
            }
        });
        return _return;
    }

    /**
     * Returns the index of where to put a created wrapping branch
     *
     * @param {BlockTreeBranch} parent
     * @param {BlockTreeBranchLeaf} droppedAt
     * @returns {number}
     */
    getIndexToAppendWrappingBranch(
        parent: BlockTreeBranch,
        droppedAt: BlockTreeBranchLeaf
    ) {
        return parent.children.indexOf(droppedAt);
    }

    /**
     * Insert the new wrapping branch for the leaf dropped at and the dragged
     *
     * @param {BlockTreeBranch} parent
     * @param {BlockTreeBranch} wrappingBranch
     * @param {droppedAtIndex} droppedAtIndex
     * @param {Renderer2} renderer
     */
    appendWrappingBranchToParentsChildren(
        parent: BlockTreeBranch,
        wrappingBranch: BlockTreeBranch,
        droppedAtIndex: number,
        renderer: Renderer2
    ) {
        parent.children.splice(droppedAtIndex, 0, wrappingBranch);
        wrappingBranch.newlyCreated = true;
        this.animateDrop(wrappingBranch, renderer);
    }

    /**
     * Event handler for when switch is changed
     *
     * @param _model
     * @param {any} _switch
     */
    switchChange(_model: any, _switch: any): void {
        this.onSwitchChange.emit({ model: _model, switch: _switch });
    }

    /**
     * Event handler for when a branch or root node is selected
     *
     * @param _model
     */
    selectChange(_model: BlockTreeBranch | BlockTree): void {
        this.onSelectBranch.emit(_model);
    }

    /**
     * Event handler for when an action menu item is clicked
     *
     * @param {ActionItem} _actionItem
     * @param _model
     */
    actionClick(_actionItem: ActionItem, _model: any): void {
        this.onActionClick.emit({ actionItem: _actionItem, model: _model });
    }
}
