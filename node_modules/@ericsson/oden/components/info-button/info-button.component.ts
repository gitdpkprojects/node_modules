import {
    Component,
    ComponentRef,
    ElementRef,
    HostBinding,
    HostListener,
    Input,
    OnDestroy,
    Renderer2,
    ViewChild,
    ViewEncapsulation
} from '@angular/core';
import { KEYBOARD } from '../../core/constants/keyboard.constants';
import AnimationHelper from '../../core/helpers/animation.helper';
import { IconComponent } from '../icon/icon.component';
import { IOverlayable } from '../overlay/overlayable.interface';
import { BackdropComponent } from '../backdrop/backdrop.component';
import { OverlayHelperService } from '../overlay/overlay-helper.service';
import { DOMHelper } from '../../core/helpers/dom.helper';
import { SIZING } from '../../core/constants/sizing.constants';
import { OVERLAY_CONTEXT } from '../overlay/overlay.constants';
import { BackdropService } from '../backdrop/backdrop.service';

@Component({
    selector: 'cui-info-button',
    templateUrl: './info-button.component.html',
    styleUrls: ['./info-button.component.scss'],
    encapsulation: ViewEncapsulation.None
})

export class InfoButtonComponent implements IOverlayable, OnDestroy {
    @ViewChild('overlayElement') overlayElement: ElementRef;

    openedInOverlay: boolean;
    backdrop: ComponentRef<BackdropComponent>;
    private _scrollArea: HTMLElement;

    @Input() text: string;
    @HostBinding('class.active') active: boolean = false;

    @HostBinding('class.cui-info-button') addClass: boolean = true;
    @HostBinding('tabindex') tabIndex: number;
    @ViewChild('icon') icon: IconComponent;

    constructor(public elementRef: ElementRef,
                public overlayHelperService: OverlayHelperService,
                public renderer: Renderer2,
                private _backdropService: BackdropService) {
    }

    ngOnDestroy(): void {
        this.removeFromOverlay();
    }

    removeFromOverlay(): void {
        if (this.openedInOverlay) {
            this.overlayHelperService.removeFromOverlay(this);
        }
        this.deleteBackdrop();
    }

    openInOverlay(): void {
    }

    /**
     * Clicking on the info button icon toggles the info bubble.
     * @param MouseEvent
     */
    @HostListener('click', ['$event'])
    public onClick(event: MouseEvent): void {
        if (this.active) {
            this.closeInfo();
        } else {
            this.open();
        }
        event.stopPropagation();
    }

    /**
     * When opening we make sure the info bubble is centered above the icon and gets a fixed width.
     */
    open(): void {
        this.active = true;
        this.createBackdrop();
        this.overlayHelperService.appendToOverlay(this, OVERLAY_CONTEXT.ROOT);
    }

    /**
     * Sets the position of the bubble in the overlay. Triggered via OverlayHelperService
     */
    setOverlayPosition(): void {
        const parentRect = this.icon.element.nativeElement.getBoundingClientRect();
        const overlayElement = <HTMLElement> this.overlayElement.nativeElement;
        const scrollArea = DOMHelper.closestParent(this.elementRef.nativeElement, 'scroll-area');
        this._scrollArea = scrollArea ? scrollArea : document.getElementById('cui-application');
        const stickyElement = this._scrollArea.querySelector('.cui-sticky');
        let maxTop: number;
        if (!stickyElement) {
            maxTop = SIZING.SYSTEMBAR_HEIGHT;
        } else {
            maxTop = stickyElement.getBoundingClientRect().bottom + 20;
        }
        if (parentRect.bottom < maxTop) {
            this.closeInfo();
            return;
        }
        const documentWidth = Math.max(document.body.scrollWidth, document.body.offsetWidth,
            document.documentElement.clientWidth, document.documentElement.scrollWidth,
            document.documentElement.offsetWidth);

        // if the overlay is too far down
        let overlayRect = overlayElement.getBoundingClientRect();
        const overlayTop = parentRect.top - overlayRect.height;
        overlayElement.style.top = `${overlayTop}px`;
        overlayRect = overlayElement.getBoundingClientRect();
        if (overlayTop < maxTop) {
            overlayElement.style.top = `${maxTop}px`;
        }

        const overlayLeft = parentRect.left - (overlayRect.width / 2) + parentRect.width / 2;
        // if the overlay is too far to the right

        overlayRect = overlayElement.getBoundingClientRect();
        if (overlayLeft + overlayRect.width > documentWidth) {
            overlayElement.style.left = null;
            overlayElement.style.right = `20px`;
        } else if (overlayLeft < 20) {
            overlayElement.style.right = null;
            overlayElement.style.left = `20px`;
        } else {
            overlayElement.style.left =
                `${parentRect.left - (overlayRect.width / 2) + parentRect.width / 2}px`;
        }
    }

    /**
     * Clicking anywhere on the page should close the info bubble unless we have clicked on the icon itself.
     * @param MouseEvent
     */
    @HostListener('document:click', ['$event'])
    onDocumentClick(event: MouseEvent): void {
        if (this.active && !this.elementRef.nativeElement.contains(event.target)) {
            this.closeInfo();
        }
    }

    /**
     * Clicking on the escape button on the keyboard closes the info bubble.
     * @param KeyboardEvent
     */
    @HostListener('keydown', ['$event'])
    handleKeyboardEvent(event: KeyboardEvent): void {
        if ((event.which === KEYBOARD.ENTER || event.which === KEYBOARD.SPACE) && !this.active) {
            this.open();
        } else if ((event.which === KEYBOARD.ENTER || event.which === KEYBOARD.SPACE || event.which === KEYBOARD.ESCAPE) && this.active) {
            this.closeInfo();
        }
    }

    /**
     * The close function that removes the active class on the button and nullifies our custom left position.
     */
    closeInfo(): void {
        this.active = false;
        AnimationHelper.animationCompleted(this.overlayElement.nativeElement).then(() => {
            this.overlayElement.nativeElement.style.width = null;
            this.overlayElement.nativeElement.style.left = null;
            this.overlayElement.nativeElement.style.right = null;
            this.removeFromOverlay();
        });
        this.deleteBackdrop();
    }

    /**
     * Creates a backdrop unless there is one already
     */
    createBackdrop(): void {
        if (!this.backdrop) {
            this.backdrop = this._backdropService.create(false);
            this.backdrop.instance.onClose.subscribe(() => this.closeInfo());
        }
    }

    /**
     * Deletes the backdrop if there is one
     */
    deleteBackdrop(): void {
        if (this.backdrop) {
            this.backdrop.instance.onClose.unsubscribe();
            this._backdropService.remove(this.backdrop);
            this.backdrop = null;
        }
    }

}
