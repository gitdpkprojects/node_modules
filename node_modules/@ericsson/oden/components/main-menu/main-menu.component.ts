import { Component, ComponentRef, ElementRef, HostBinding, Input, ViewEncapsulation } from '@angular/core';
import { Router } from '@angular/router';
import { BackdropComponent } from '../backdrop/backdrop.component';
import { BackdropService } from '../backdrop/backdrop.service';
import { ProfileModel } from '../../core/models/profile.model';
import { BaseRoute, ParentRoute } from './main-menu-route.model';
import { MainMenuService } from './main-menu.service';
import { DOMHelper } from '../../core/helpers/dom.helper';
import { TabViewService } from '../tab-view/tab-view.service';
import AnimationHelper from '../../core/helpers/animation.helper';
import { OverlayService } from '../overlay/overlay.service';
import { ITaskShortcut } from '../../core/interfaces/task-shortcut.interface';
import { PostMessageService } from '../../core/services/postmessage.service';
import { animate, state, style, transition, trigger } from '@angular/animations';
import { ANIMATION } from '../../core/constants';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../core/classes';
import { NavigationHelper } from '../../core';

@Component({
    selector: 'cui-main-menu',
    templateUrl: 'main-menu.component.html',
    styleUrls: ['main-menu.component.scss'],
    animations: [
        trigger('toggleApp', [
            state('show', style({ height: '*' })),
            state('hide', style({ height: 0, overflow: 'hidden' })),
            transition('hide <=> show', animate('170ms ' + ANIMATION.EASE_OUT_QUAD))
        ]),
        trigger('toggleArrow', [
            state('up', style({ transform: 'rotate(0)' })),
            state('down', style({ transform: 'rotate(180deg)' })),
            transition('up <=> down', animate('170ms ease-in'))
        ])
    ],
    encapsulation: ViewEncapsulation.None
})
@UnSub()
export class MainMenuComponent {
    @HostBinding('class.cui-main-menu') addClass: boolean = true;
    @HostBinding('class.open') private _menuOpen: boolean = false;
    @HostBinding('style.z-index') get zIndex(): number {
        return this._overlayService.highestZindex + 1;
    }
    @Input() profile: ProfileModel;
    @Input() appName: string;
    @Input() appVersion?: string;
    @Input() appProprietor?: string = 'Ericsson';
    @Input() expandableMenu: boolean = false;

    private _backdrop: ComponentRef<BackdropComponent>;
    private _inChildTask: string;
    private _subscriptions: Array<Subscription> = [];
    mainMenuRoutes: Array<ParentRoute>;

    constructor(private _router: Router,
        private _backDropService: BackdropService,
        private _mainMenuService: MainMenuService,
        private _tabViewService: TabViewService,
        private _overlayService: OverlayService,
        private _elementRef: ElementRef,
        private _postMessageService: PostMessageService) {
        this.mainMenuRoutes = this._mainMenuService.getRoutes();
        this._subscriptions.push(this._mainMenuService.onChange.subscribe((routes: Array<ParentRoute>) => {
            this.mainMenuRoutes = routes;
        }));
        this._subscriptions.push(this._mainMenuService.onToggle.subscribe(() => this.toggleMenu()));

        this._subscriptions.push(this._postMessageService.incomingMessage$.subscribe((data: ITaskShortcut) => {
            if (data && data.parent) {
                this._inChildTask = data.parent;
            }
        }));
    }

    /**
     * Navigates to the absolute path.
     * @param route
     */
    navigateToRoute(route: BaseRoute): void {
        // See if there's a tab with this path. If so, navigate via changeTab()
        this.closeMenu();
        NavigationHelper.switchView(route);
        const tabLink = <HTMLElement>document.querySelector(`#tabs-holder [href='${route.path}']`);
        if (tabLink) {
            const index = DOMHelper.getNodeIndex(tabLink.parentElement.parentElement);
            this._tabViewService.setCurrentIndex(index);
        } else {
            this._tabViewService.setCurrentIndex(0);
        }
        // Introducing SELFHOST check for non-angular applications
        const isInternalUrl = NavigationHelper.isInternalURL(route.path);
        const routePath = NavigationHelper.getVaildRoutePath(route.path);
        const openInNewWindow = route.newWindow;
        if (route.externalApp) {
            NavigationHelper.getActiveIFrame().src = routePath;
        } else if (!this._inChildTask && isInternalUrl) {
            // Treat as internal URL and open in this window
            // Wait for main menu closing animation
            AnimationHelper.animationCompleted(this._elementRef.nativeElement).then(() => {
                if (tabLink) {
                    tabLink.click();
                } else {
                    // Scroll to top of application when changing routes
                    // When scroll is finished, do navigate!
                    DOMHelper.scrollTo(document.querySelector('#cui-application'), 0, 200).then(() => {
                        NavigationHelper.navigateToPath(route.path, this._router);
                    });
                }
            });
        } else if (!isInternalUrl && openInNewWindow) {
            // Treat as external URL and open in new window
            window.open(routePath);
        } else if (this._inChildTask || (!isInternalUrl && !openInNewWindow)) {
            // Treat as external URL and open in this window. If we're in a childTask we should also use this method.
            NavigationHelper.navigateWithWindowLocation(routePath);
        }
    }

    /**
     * Closes the menu
     */
    closeMenu() {
        this._menuOpen = false;
        this.closeBackDrop();
    }

    /**
     * Toggles the state of the menu, returns the new state
     * @returns {boolean}
     */
    toggleMenu(): boolean {
        if (this._menuOpen) {
            this.closeMenu();
        } else {
            this.openMenu();
        }
        return this._menuOpen;
    }

    /**
     * Opens the menu
     */
    openMenu() {
        // toggle the current route
        this.mainMenuRoutes.forEach(routes => {
            if (routes && routes.children) {
                routes.children.forEach((appRoute: any) => {
                    if (appRoute && appRoute.children) {
                        let activeFound = false; // Check if any of the child route is active
                        appRoute.children.forEach((childRoute) => {
                            if (this.isActive(childRoute)) {
                                activeFound = true;
                            }
                        });
                        appRoute.active = activeFound;
                    }
                });
            }
        });
        this._menuOpen = true;
        this.openBackDrop();
    }

    /**
     * Creates a backdrop instance
     */
    openBackDrop(): void {
        if (!this._backdrop) {
            this._backdrop = this._backDropService.create();
        }
        this._subscriptions.push(this._backdrop.instance.onClose.subscribe(() => this.closeMenu()));
    }

    /**
     * Removes the backdrop instance
     */
    closeBackDrop(): void {
        if (this._backdrop) {
            this._backDropService.remove(this._backdrop);
            this._backdrop = null;
        }
    }

    /**
     * Helpers for the view
     */
    isActive(route: BaseRoute): boolean {
        const iFrame = NavigationHelper.getActiveIFrame();
        return this.isRouteActive(route, iFrame);
    }

    /**
     * Recursive match of an active route wit iframe support.
     */
    private isRouteActive(route, activeIFrame: HTMLIFrameElement): boolean {
        let active = false;
        if (activeIFrame) {
            const routePath = route.path && NavigationHelper.getVaildRoutePath(route.path);
            active = activeIFrame.name === route.externalApp && this.isIFramePathActive(routePath, activeIFrame);
        } else {
            active = route.path && this._router.isActive(route.path, false);
        }
        if (!active && route.children && route.children.length) {
            active = route.children.some(r => this.isRouteActive(r, activeIFrame));
        }
        return active;
    }

    /**
     * Compare iframe window location with the route path and return true for match.
     */
    private isIFramePathActive(routePath: string, activeIFrame: HTMLIFrameElement): boolean {
        let href;
        try {
            // Security issue risk when parent and iFrame don't have the same origin
            href = activeIFrame.contentWindow.location.href;
        } catch (e) {
            href = activeIFrame.src;
        }
        return href && href.indexOf(routePath) > -1;
    }

    /**
     * Toggles application item in the sidebar
     * @param item
     */
    toggleApp(item) {
        item.active = item.active ? false : true;
    }

    /**
     * Checks if the route has child routes
     * @param route
     */
    hasChildRoutes(route: any) {
        return route.children && route.children.length > 0;
    }
}
