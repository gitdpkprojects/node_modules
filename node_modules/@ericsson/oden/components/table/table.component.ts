/* tslint:disable:component-selector */
import { animate, state, style, transition, trigger } from '@angular/animations';
import {
    AfterViewInit,
    Component,
    ContentChildren,
    ElementRef,
    EventEmitter,
    forwardRef,
    HostBinding,
    Input,
    OnChanges,
    OnDestroy,
    OnInit,
    Output,
    QueryList,
    Renderer2,
    SimpleChanges,
    TemplateRef,
    ViewChild,
    ViewEncapsulation
} from '@angular/core';
import * as _ from 'lodash';
import { Subscription } from 'rxjs/Subscription';
import { ORDER } from '../../core/constants';
import { ANIMATION } from '../../core/constants/animation.constants';
import { DATE_TYPE } from '../../core/constants/date.constants';
import { ORDER_TYPE } from '../../core/constants/order-type.constants';
import { SIZING } from '../../core/constants/sizing.constants';
import { DOMHelper } from '../../core/helpers/dom.helper';
import { OrderHelper } from '../../core/helpers/order.helper';
import { UUID } from '../../core/helpers/uuid.class';
import { ITableHeaderItem } from '../../core/interfaces/table-header.interface';
import { ITableRowData } from '../../core/interfaces/table-row-data.interface';
import { ActionItem, ListControllerCategoryFilterGroup, TableAction, TableOrderEvent, Divider } from '../../core/models';
import { ListControllerDateFilter } from '../../core/models/list-controller-date-filter.model';
import { FIELD_EVENT_TYPE, TableFieldEvent } from '../../core/models/table-field.event';
import { ResizeService } from '../../core/services';
import { SelectComponent } from '../form/select/select.component';
import { ListControllerComponent } from '../list-controller/list-controller.component';
import { OverlayService } from '../overlay/overlay.service';
import { PaginationData } from '../pagination/pagination.model';
import { Base } from './../../core/classes/base';
import { TableRowComponent } from './table-row/table-row.component';
import { TableService } from './table.service';
import { ExportCSVService } from '../export/export-csv';
import { CSVHeaderItem, CSVHelper } from '../../core/helpers/csv.helper';
import { TranslateService } from '@ngx-translate/core';

@Component({
    selector: 'cui-table,cui-list',
    templateUrl: 'table.component.html',
    styleUrls: ['table.component.scss'],
    encapsulation: ViewEncapsulation.None,
    animations: [
        trigger('placeholderRowVisibility', [
            state('fade-in', style({ opacity: 0.35 })),
            state('fade-out', style({ opacity: 0 })),
            transition('fade-out => fade-in', [
                style({ opacity: 0 }),
                animate('300ms ' + ANIMATION.EASE_IN_QUAD)
            ])
        ])
    ],
    providers: [
        TableService,
        { provide: Base, useExisting: forwardRef(() => TableComponent) }
    ]
})
export class TableComponent
    implements OnChanges, OnInit, AfterViewInit, OnDestroy {
    @HostBinding('class.cui-table')
    addClass: boolean = true;
    @HostBinding('class.no-transitions')
    noTransitions: boolean = true;
    @HostBinding('class.has-hidden-rows')
    _hasHiddenRows: boolean = false;
    @Input()
    tableTitle: string = '';
    @Input()
    tableTitleCount: number;
    @Input()
    header: ITableHeaderItem;
    @Input()
    headers: ITableHeaderItem[] = [];
    @Input()
    tableActions: ActionItem[] = [];
    @Input()
    data: Array<ITableRowData> = [];
    @Input()
    batchActions: Array<ActionItem> = [];
    @Input()
    singleActions: Array<ActionItem> = [];
    @Input()
    pagination: boolean = false;
    @Input()
    paginationData: PaginationData;
    @Input()
    showEditAllSwitch: boolean = false;
    @Input()
    editableTable: boolean = false;
    @Input()
    selectable: boolean = false;
    @Input()
    stickyHeaders: boolean = true;
    @Input()
    placeholderRow: boolean = false;
    @Input()
    placeholderRowOverride: boolean;
    @Input()
    rowTemplate: TemplateRef<any>;
    @Input()
    multiRowTemplate: TemplateRef<any>;
    @Input()
    footerRowTemplate: TemplateRef<any>;
    @Input()
    headerTemplate: TemplateRef<any>;
    @Input()
    filterTemplate: TemplateRef<any>;
    @Input()
    titleTemplate: TemplateRef<any>;
    @Input()
    placeholderRowTemplate: TemplateRef<any>;
    @Input()
    singleSelect: boolean = false;
    @Input()
    useBatchActions: boolean = true;
    @Input()
    tableTitleActions: ActionItem[] = [];
    @ContentChildren(forwardRef(() => ListControllerComponent))
    _filterQueryList: QueryList<ListControllerComponent>;
    @Output()
    onColumnVisibilityChanged: EventEmitter<Array<ITableHeaderItem>> = new EventEmitter<
        Array<ITableHeaderItem>>();
    @Output()
    onPagination: EventEmitter<PaginationData> = new EventEmitter<
        PaginationData
    >();
    @Output()
    onBatchClick: EventEmitter<TableAction> = new EventEmitter<TableAction>();
    @Output()
    onTableActionClick: EventEmitter<ActionItem> = new EventEmitter<
        ActionItem
    >();
    @Output()
    onBatchChanged: EventEmitter<Array<ITableRowData>> = new EventEmitter<
        Array<ITableRowData>
    >();
    @Output()
    onSingleClick: EventEmitter<TableAction> = new EventEmitter<TableAction>();
    @Output()
    onTitleActionClick: EventEmitter<TableAction> = new EventEmitter<TableAction>();
    @Output()
    onExportCSV: EventEmitter<CSVHeaderItem[]> = new EventEmitter<CSVHeaderItem[]>();
    @Output()
    onActionMenuDisplay: EventEmitter<ITableRowData> = new EventEmitter<
        ITableRowData
    >();
    @Output()
    onOrderChanged: EventEmitter<TableOrderEvent> = new EventEmitter<
        TableOrderEvent
    >();
    @Output()
    onEditAllChanged: EventEmitter<boolean> = new EventEmitter<boolean>();
    @Output()
    onNextRow: EventEmitter<ITableRowData> = new EventEmitter<ITableRowData>();
    @Output()
    onColumnVisibilityChange: EventEmitter<ITableHeaderItem> = new EventEmitter<
        ITableHeaderItem
    >();
    @Output()
    onRowClick: EventEmitter<ITableRowData> = new EventEmitter<ITableRowData>();
    @Output()
    onRowElementClick: EventEmitter<{ data: ITableRowData, component: TableRowComponent }> =
        new EventEmitter<{ data: ITableRowData, component: TableRowComponent }>();
    /**
     * The following inputs and outputs have been deprecated
     */
    /** @deprecated */
    @Output()
    onFieldChanged: EventEmitter<TableFieldEvent> = new EventEmitter<
        TableFieldEvent
    >();
    /** @deprecated */
    @Output()
    onFieldBlur: EventEmitter<TableFieldEvent> = new EventEmitter<
        TableFieldEvent
    >();
    /** @deprecated */
    @Output()
    onFieldFocus: EventEmitter<TableFieldEvent> = new EventEmitter<
        TableFieldEvent
    >();
    /** @deprecated */
    @Output()
    onFieldEvent: EventEmitter<TableFieldEvent> = new EventEmitter<
        TableFieldEvent
    >();
    /** @deprecated */
    @Output()
    onPeriodDateFilterChanged: EventEmitter<
        Array<ListControllerDateFilter>
    > = new EventEmitter<Array<ListControllerDateFilter>>();
    /** @deprecated */
    @Output()
    onFilterChanged: EventEmitter<string> = new EventEmitter<string>();
    /** @deprecated */
    @Output()
    onCategoryFilterChanged: EventEmitter<any> = new EventEmitter<any>();
    /** @deprecated */
    @Output()
    onDateFilterChanged: EventEmitter<any> = new EventEmitter<any>();
    /** @deprecated */
    @Input()
    periodDateFilterLabel: string = 'Date between';
    /** @deprecated */
    @Input()
    periodDateFilterDelimiterLabel: string;
    /** @deprecated */
    @Input()
    showFilter: boolean = false;
    /** @deprecated */
    @Input()
    filterValue: string = '';
    /** @deprecated */
    @Input()
    showCategoryFilter: boolean = false;
    /** @deprecated */
    @Input()
    categoryFilterGroups: Array<ListControllerCategoryFilterGroup> = [];
    /** @deprecated */
    @Input()
    dateFilters: Array<ListControllerDateFilter> = [];
    /** @deprecated */
    @Input()
    periodDateFilters: Array<ListControllerDateFilter> = [];

    @ViewChild('stickyHeaderElementRef')
    stickyHeaderElementRef: ElementRef;
    @ViewChild('batchActionsElementRef')
    batchActionsElementRef: ElementRef;
    @ViewChild('tableHeaderElementRef')
    tableHeaderElementRef: ElementRef;
    @ViewChild('tableElementRef')
    tableElementRef: ElementRef;
    @ViewChild('stickySelectedColumnsRef')
    stickySelectedColumnsRef: ElementRef;
    @ViewChild('selectedColumnsRef')
    selectedColumnsRef: ElementRef;
    @ViewChild('selectedColumnsDropRef')
    selectedColumnsDropRef: SelectComponent;
    @ViewChild('stickyBatchActionsContainer')
    stickyBatchActionsContainer: ElementRef;
    @ViewChild('batchActionsContainer')
    batchActionsContainer: ElementRef;

    anyRowsInEdit: boolean = false;
    showStickyTableHeader: boolean = false;
    showStickyBatchActions: boolean = false;
    showSticky: boolean = false;
    paddingLeft: any = null;
    tabsStickyRect: ClientRect;
    bottomPosition: number;
    nextTop: number;
    tableRect: ClientRect;
    placeholderRowAnimation = 'fade-in';
    selectedColumns: Array<any> = [];
    columnsSets: Array<Array<ITableHeaderItem>> = [];
    currentColumnSetIndex = 0;
    zIndex: number;
    displayPlaceholderRow: boolean;
    dateType: any = DATE_TYPE;
    titleActions: Array<ActionItem | Divider> = [];
    // A map which stores all rows states. default = not a new row. added = new row.
    // Used for animations on table row component
    private readonly _uuid: string = UUID.create();
    private _tableWidth: number;
    private _placeholderRowOverride: boolean;
    _paginationData: PaginationData;
    private _scrollArea: HTMLElement;
    private _subscriptions: Array<Subscription> = [];
    private _onScrollListener: Function;
    get listControllerColumnSize(): number {
        return this.columnsSets.length > 1 ? 8 : 12;
    }

    constructor(
        private _renderer: Renderer2,
        private _overlayService: OverlayService,
        public tableService: TableService,
        private _resizeService: ResizeService,
        private _exportCSVService: ExportCSVService,
        private translate: TranslateService
    ) { }

    get uuid(): string {
        return this._uuid;
    }

    onSelectRow(row: ITableRowData) {
        if (this.singleSelect) {
            this.deselectAllItems(row);
        }
    }

    /**
     * Emits the onEditAllChanged event.
     * @param editAll
     */
    editAllChange(editAll: boolean): void {
        this.onEditAllChanged.emit(editAll);
    }

    private _setPaginationData(data: Array<ITableRowData>): void {
        if (!this.paginationData) {
            // Creates a new instance of PaginationData with the defaults values.
            this._paginationData = new PaginationData({
                totalItems: data.length
            });
        } else {
            this._paginationData = this.paginationData;
        }
    }

    /**
     * Sets a default value for the editPlaceholder
     */
    ngOnInit(): void {
        this._subscriptions.push(
            this.tableService.onEditableChange.subscribe((edit: boolean) => {
                this.anyRowsInEdit = edit;
            })
        );
        this._subscriptions.push(
            this.tableService.onRowDestroy.subscribe(() => {
                if (this.placeholderRow && !this.displayPlaceholderRow) {
                    this.displayPlaceholderRow = true;
                    this.placeholderRowAnimation = 'fade-in';
                }
            })
        );
        this._subscriptions.push(
            this.tableService.onNewRow.subscribe(() => this.onNewRow())
        );
        this._subscriptions.push(
            this.tableService.onSelectRow.subscribe(this.onSelectRow.bind(this))
        );
        if (this.pagination) {
            this._setPaginationData(this.data);
        }
        if (this.placeholderRow) {
            this.anyRowsInEdit = _.some(this.data, { edit: true });
        }
        this.displayPlaceholderRow = this.placeholderRow;
        this._subscriptions.push(this._resizeService.resize$.subscribe(() => this.onResize()));
        if (this.stickyHeaders) {
            // TODO: Improve how we get the canvas. This is the same method used on sticky component
            // Should not only check for task pane
            const scrollArea = DOMHelper.closestParent(
                this.tableElementRef.nativeElement,
                'scroll-area'
            );
            this._scrollArea = scrollArea
                ? scrollArea
                : document.getElementById('cui-application');
            this._onScrollListener = this._renderer.listen(this._scrollArea, 'scroll', () => {
                this.setStickyPosition();
            });
        }
        if (this.header) {
            this.headers = [this.header];
        }
        if (this.editableTable) {
            this.headers.forEach(header => {
                if (!header.editPlaceholder) {
                    header.editPlaceholder = '';
                }
            });
        }
        const sortHeaders = this.headers.filter(header => {
            return (
                (header.order === ORDER.ASCENDING ||
                    header.order === ORDER.DESCENDING) &&
                header.orderType !== undefined &&
                header.orderType !== null
            );
        });
        if (sortHeaders.length !== 0) {
            this.orderData(sortHeaders[0]);
        }

        this.selectedColumns = this.headers.filter(h => !h.hidden);
        this._setRowsVisibility();
    }

    ngAfterViewInit() {
        setTimeout(() => {
            this.checkTableOverflowed();
            setTimeout(() => {
                this.noTransitions = false;
            });
        });
        if (this.placeholderRow) {
            this.tableService.tableIsNew = false;
        }
        this.zIndex = this._overlayService.zIndex;
        this._setTableTitleActions();
    }

    ngOnChanges(changes: SimpleChanges): void {
        if (
            changes.header &&
            changes.header.currentValue !== changes.header.previousValue
        ) {
            this.headers = [changes.header.currentValue];
            this.checkTableOverflowed();
        }
        if (changes.data && !changes.data.firstChange) {
            this._setPaginationData(changes.data.currentValue);
        }
        this.selectedColumns = this.headers.filter(h => !h.hidden);
        this._setRowsVisibility();
        if (!this.noTransitions) {
            this.checkTableOverflowed();
        }
        if (
            changes['placeholderRowOverride'] &&
            typeof this.placeholderRowOverride === 'boolean'
        ) {
            this._placeholderRowOverride = this.placeholderRowOverride;
            this.placeholderRowAnimation = this.placeholderRowOverride
                ? 'fade-in'
                : 'fade-out';
        }
        // Prevent more than one selected if switching to singleSelect (radiobuttons)
        if (
            changes.singleSelect &&
            !changes.singleSelect.firstChange &&
            this.countSelectedItems() > 1 &&
            this.singleSelect
        ) {
            this.deselectAllItems();
        }
    }

    rowClick(item: ITableRowData, component: TableRowComponent) {
        this.onRowClick.emit(item);
        this.onRowElementClick.emit({ data: item, component: component });
    }
    toggleStickyColumn(item: ITableHeaderItem) {
        item.sticky = !item.sticky;
        this.checkTableOverflowed();
    }
    onResize(): void {
        this.checkTableOverflowed();
        this.setStickyPosition();
    }

    ngOnDestroy(): void {
        if (this._onScrollListener) {
            this._onScrollListener();
        }
        this._subscriptions.forEach((s) => s.unsubscribe());
    }

    /**
     * Return columns labels as a joined comma separated string
     * @param columnSet
     */
    getColumnSetLabels(columnSet): string {
        return columnSet
            .map((elem: ITableHeaderItem) => {
                return elem.label;
            })
            .join(', ');
    }

    /**
     * Checks all columns and if the table should have column sets
     */
    checkTableOverflowed(): void {
        if (!this.tableElementRef.nativeElement) {
            return;
        }
        this._tableWidth = this.tableElementRef.nativeElement.offsetWidth;
        if (this._tableWidth > 0) {
            const stickyColumns = this.tableElementRef.nativeElement.querySelectorAll(
                'th.sticky-column'
            );
            this._tableWidth -= _.sum(
                Array.from(stickyColumns).map((col: HTMLElement) => col.offsetWidth)
            );
            const stickColumnsWidth = _.sum(
                this.headers
                    .filter(header => header.sticky)
                    .map(header => this.getHeaderPxWidth(header))
            );
            const normalColumnsWidth = _.sum(
                this.headers
                    .filter(header => !header.sticky)
                    .map(header => this.getHeaderPxWidth(header))
            );
            const allHeadersHasWidth = !_.includes(
                this.headers
                    .filter(header => !header.sticky)
                    .map(header => {
                        return (
                            typeof header.width === 'string' ||
                            typeof header.width === 'number'
                        );
                    }),
                false
            );
            const hasPxWidths = _.includes(
                this.headers
                    .filter(header => !header.sticky)
                    .map(header => {
                        return (
                            typeof header.width === 'string' &&
                            !header.width.endsWith('%')
                        );
                    }),
                true
            );
            this.columnsSets = [];
            if (
                allHeadersHasWidth && hasPxWidths &&
                this._tableWidth - stickColumnsWidth < normalColumnsWidth
            ) {
                let headersWidth = 0;
                let currentColumnSetIndex = 0;

                this.headers
                    .filter(header => !header.hidden && !header.sticky)
                    .forEach(header => {
                        const width = this.getHeaderPxWidth(header);

                        if (
                            headersWidth !== 0 &&
                            headersWidth + width >
                            this._tableWidth - stickColumnsWidth
                        ) {
                            // cell does not fit in current column set
                            currentColumnSetIndex++;
                            headersWidth = 0;
                        }
                        if (
                            typeof this.columnsSets[currentColumnSetIndex] ===
                            'undefined'
                        ) {
                            this.columnsSets[currentColumnSetIndex] = [];
                        }
                        this.columnsSets[currentColumnSetIndex].push(header);
                        headersWidth += width;
                    });
            } else {
                this.columnsSets = [this.headers];
            }
            this.setColumnSetDisplay();
        }

    }

    /**
     * Checks if placeholder row should be displayed
     * @return {boolean}
     */
    displayPlaceholder(): boolean {
        return (
            this._placeholderRowOverride ||
            (this.displayPlaceholderRow &&
                (this.anyRowsInEdit || this.data.length === 0))
        );
    }

    /**
     * Checks if cell is hidden either via Hidden or overflowed.
     * @return {boolean}
     */
    isCellHidden(item: ITableHeaderItem) {
        return item.hidden || item.overflowed;
    }

    /**
     * Go to previous column set
     */
    prevColumnSet(): void {
        this.changeColumnSet(this.currentColumnSetIndex - 1);
    }

    /**
     * Go to next column set
     */
    nextColumnSet(): void {
        this.changeColumnSet(this.currentColumnSetIndex + 1);
    }

    /**
     * Change to the new column set index, ignores if the index is not a part of the column sets
     * @param index
     */
    changeColumnSet(index: number): void {
        if (this.columnsSets[index]) {
            this.currentColumnSetIndex = index;
        }
        this.setColumnSetDisplay();
    }

    /**
     * Updates which column set that should be displayed.
     */
    setColumnSetDisplay(): void {
        if (
            this.currentColumnSetIndex >= this.columnsSets.length &&
            this.currentColumnSetIndex > 0
        ) {
            this.currentColumnSetIndex = this.columnsSets.length - 1;
        }

        this.headers
            .filter(header => header.sticky)
            .forEach(header => (header.overflowed = false));
        this.columnsSets.forEach((columnSet, index) => {
            columnSet.forEach(header => {
                header.overflowed = index !== this.currentColumnSetIndex;
            });
        });
    }

    /**
     * Returns the headers width in pixels. Compares percent to the current table width.
     * @param header
     * @return {number}
     */
    getHeaderPxWidth(header: ITableHeaderItem): number {
        if (header.hidden) {
            return 0;
        }
        let width = parseInt(header.width, 0);
        if (!width) {
            return 0;
        }
        if (header.width.match(/%$/)) {
            width = (this._tableWidth * width) / 100;
            if (width < 60) {
                width = 60;
            }
        }
        return width;
    }

    /**
     * When the next row is requested, emit the onNextRow event.
     * @param row
     */
    nextRow(row: ITableRowData): void {
        // Find next row
        let nextRow;
        if (row) {
            const index = this.data.indexOf(row) + 1;
            nextRow = this.data[index];
        }
        if (!nextRow) {
            nextRow = null;
        }
        this.onNextRow.emit(nextRow);
    }

    /**
     * Changes order of table. Is sent to <cui-table> in view
     * @param item:ITableHeaderItem
     */
    changeOrder(item: ITableHeaderItem): void {
        let order: ORDER;
        const sortOrders = item.sortOrders;
        if (sortOrders != null) {
            let index = sortOrders.indexOf(item.order);
            if (index + 1 === sortOrders.length || index === -1) {
                index = 0;
            } else {
                index++;
            }
            order = sortOrders[index];
        } else {
            order =
                item.order === ORDER.ASCENDING
                    ? ORDER.DESCENDING
                    : ORDER.ASCENDING;
        }
        if (item.orderType !== undefined) {
            item.order = order;
            this.orderData(item);
        } else {
            this.onOrderChanged.emit(
                new TableOrderEvent({ order: order, field: item.field })
            );
        }
    }

    /**
     * Checks if a cell can be sorted, internally or via event
     * @param {ITableHeaderItem} item
     * @return {boolean}
     */
    isNotOrderableCell(item: ITableHeaderItem): boolean {
        return !(
            (this.onOrderChanged.observers.length > 0 || !!item.orderType) &&
            !(
                !!item.sortOrders &&
                item.sortOrders[0] === ORDER.NONE &&
                item.sortOrders.length === 1
            )
        );
    }

    /**
     * Stops order changes if no-click class is present at the target
     * @param {ITableHeaderItem} item
     * @param {MouseEvent} event
     */
    headerClick(item: ITableHeaderItem, event?: MouseEvent): void {
        if (
            event &&
            event.target &&
            (<HTMLElement>event.target).classList.contains('sorting')
        ) {
            this.changeOrder(item);
        }
    }

    /**
     * Orders the data with the settings from the ITableHeaderItem
     * @param item: ITableHeaderItem
     */
    orderData(item: ITableHeaderItem): void {
        const orderField = !!item.orderField ? item.orderField : item.field;
        if (item.order === ORDER.NONE) {
            return;
        }
        switch (item.orderType) {
            case ORDER_TYPE.DATE:
                OrderHelper.orderByDate(this.data, orderField, item.order);
                break;
            case ORDER_TYPE.NUMBER:
                OrderHelper.orderByNumber(this.data, orderField, item.order);
                break;
            case ORDER_TYPE.STRING:
                OrderHelper.orderByString(this.data, orderField, item.order);
                break;
        }
        this.headers
            .filter(header => header !== item)
            .forEach(header => (header.order = ORDER.NONE));
    }

    /**
     * batchClick EventEmitter. Sends TableAction to EventEmitter.
     * @param action
     */
    batchClick(action: ActionItem): void {
        const tableAction = new TableAction(action);
        tableAction.items = this.getSelectedItems();
        this.onBatchClick.emit(tableAction);
    }

    /**
     * batchClick EventEmitter. Sends TableAction to EventEmitter.
     * @param action
     */
    onTableAction(action: ActionItem): void {
        this.onTableActionClick.emit(action);
    }

    /**
     * Emits the field event emitters
     * @param editEvent
     */
    fieldEvent(editEvent: TableFieldEvent): void {
        this.onFieldEvent.emit(editEvent);
        switch (editEvent.eventType) {
            case FIELD_EVENT_TYPE.BLUR:
                this.onFieldBlur.emit(editEvent);
                break;
            case FIELD_EVENT_TYPE.CHANGE:
                this.onFieldChanged.emit(editEvent);
                if (!this.displayPlaceholderRow && this.placeholderRow) {
                    this.displayPlaceholderRow = this.placeholderRow;
                    this.placeholderRowAnimation = 'fade-in';
                }
                break;
            case FIELD_EVENT_TYPE.FOCUS:
                this.onFieldFocus.emit(editEvent);
                break;
        }
    }

    /**
     * singleClick EventEmitter. Turns param item into [item]. Sends TableAction to EventEmitter.
     * @param action:ActionItem
     */
    singleClick(action: TableAction): void {
        this.onSingleClick.emit(action);
    }

    /**
     * Gets a ngStyle compatible object for TableHeader
     * @param item
     * @returns {{width: string|null}}
     */
    getStyles(item: ITableHeaderItem): any {
        return {
            width: this.getWidth(item)
        };
    }

    /**
     * Returns the width of the item, or null if none
     * @param item
     * @returns string|null
     */
    getWidth(item: ITableHeaderItem): string {
        // TODO: Validate width input
        if (item.width) {
            return item.width;
        } else {
            return null;
        }
    }

    /**
     * Gets icon name corresponding current sorting value of header.
     *
     * @param item:ITableHeaderItem
     * @returns {string} - arrow-up, arrow-down or ''
     */
    getOrderIcon(item: ITableHeaderItem): string {
        if (item.order === ORDER.ASCENDING) {
            return 'arrow-up';
        } else if (item.order === ORDER.DESCENDING) {
            return 'arrow-down';
        }

        return '';
    }

    /**
     * When a checkbox is changed, we update the rows selected data and emits an event
     */
    onRowChange(): void {
        this.onBatchChanged.emit(this.getSelectedItems());
    }

    /**
     * When a context menu is clicked, we emit an event allowing manipulation of the ActionItems.
     * @param row
     */
    onActionMenuClick(row: ITableRowData): void {
        this.onActionMenuDisplay.emit(row);
    }

    /**
     * Validates header array has at least one item
     *
     * @returns {boolean}
     */
    isValidHeaders(): boolean {
        return this.headers.length > 0;
    }

    /**
     * Gets drilldown class if the item has a path property
     * @param item - Your data row
     * @returns {string}
     */
    getDrilldownClass(item: ITableRowData): string {
        if (item.path || this.onRowClick.observers.length + this.onRowElementClick.observers.length > 0) {
            return 'drilldown';
        } else {
            return '';
        }
    }

    /**
     * Gets row-{item.uuid} class if the item has a path property
     * @param {ITableRowData} item
     * @returns {string}
     */
    getRowCssClass(item: ITableRowData): string {
        if (item.path || this.onRowClick.observers.length > 0) {
            return 'row-' + item.uuid;
        } else {
            return '';
        }
    }

    /**
     * Toggle hover state on elements with same uuid class
     * @param {ITableRowData} item
     * @param {boolean} add
     */
    toggleHoverState(item: ITableRowData, add: boolean): void {
        if (add) {
            Array.from(document.querySelectorAll(`.row-${item.uuid}`)).forEach(
                element => this._renderer.addClass(element, 'hover')
            );
        } else {
            Array.from(document.querySelectorAll(`.row-${item.uuid}`)).forEach(
                element => this._renderer.removeClass(element, 'hover')
            );
        }
    }

    /**
     * Checks if any item is selected in table
     * @returns {boolean}
     */
    isAnyItemsSelected(): boolean {
        return this.countSelectedItems() > 0;
    }

    /**
     * Counts how many items that are selected in table
     * @returns {number}
     */
    countSelectedItems(countHidden: boolean = true): number {
        return this.getSelectedItems(countHidden).length;
    }

    /**
     * Returns all selected items in table
     * @returns {Array<ITableRowData>}
     */
    getSelectedItems(countHidden: boolean = true): Array<ITableRowData> {
        return this.paginatedData().filter(row => {
            if (countHidden) {
                return row.selected;
            } else {
                return row.selected && !row.hidden;
            }
        });
    }

    /**
     * Checks if all items are selected
     * @returns {boolean}
     */
    isAllItemSelected(): boolean {
        return (
            this.paginatedData().filter(row => row.selected).length ===
            this.paginatedData().length
        );
    }

    /**
     * Selects all items if not all are selected. And vice versa.
     * @returns {boolean}
     */
    toggleAllItems(): boolean {
        const allSelected = this.isAllItemSelected();
        this.viewData().forEach(i => {
            i.selected = !allSelected;
        });
        this.onRowChange();
        return !allSelected;
    }

    /**
     * Deselect all selected items
     * @param except                - Excluded from deselecting
     */
    deselectAllItems(except?): void {
        this.data.forEach((i: any) => {
            if (!except || except.id !== i.id) {
                i.selected = false;
            }
        });
    }

    /**
     * Is executed when a user uses an pagination method.
     */
    paginationClick(): void {
        if (this.onPagination.observers.length > 0) {
            this.onPagination.emit(this._paginationData);
        }
    }

    /**
     * Returns either paginated data or the user defined data.
     * @returns {Array<ITableRowData>}
     */
    paginatedData(): Array<ITableRowData> {
        if (this.pagination && this.onPagination.observers.length === 0) {
            const pData = this._paginationData;
            const startIndex = pData.currentPage * pData.itemsPerPage;
            let endIndex = startIndex + pData.itemsPerPage;
            if (endIndex > this.data.length) {
                endIndex = this.data.length;
            }
            return this.data.slice(startIndex, endIndex);
        } else {
            return this.data;
        }
    }

    /**
     * When the filter input is changed, we emit an event allowing manipulation of the data for table.
     * @param filter
     */
    onFilterTable(filter: string): void {
        this.onFilterChanged.emit(filter);
    }

    /**
     * When the category filter is changed, we emit an event allowing manipulation of the data for table.
     * @param obj Consists of 'group' and 'ngModel'
     */
    onCategoryFilterTable(obj: any) {
        this.onCategoryFilterChanged.emit(obj);
    }

    /**
     * When the date filter is changed, we emit an event allowing manipulation of the data for table.
     * @param {ListControllerDateFilter} group
     * @param {Date} date
     */
    onDateFilterTable(filter: ListControllerDateFilter, date: Date) {
        this.onDateFilterChanged.emit({ filter: filter, ngModel: date });
    }

    /**
     * When an input in the period date filter is changed, we emit an event allowing manipulation of the data for table.
     * Small timeout before emitting the periodDateFilters, to make sure the group content gets updated.
     */
    onPeriodDateFilterTable() {
        setTimeout(() => {
            this.onPeriodDateFilterChanged.emit(this.periodDateFilters);
        }, 10);
    }

    /**
     * Returns the data that are currently displayed / should be displayed
     * @returns {ITableRowData[]}
     */
    viewData(): Array<ITableRowData> {
        return this.paginatedData().filter(row => !row.hidden);
    }

    /**
     * Sets table headers and batch actions as sticky when the sticky tabs overlap
     */
    setStickyPosition(): void {
        if (this._scrollArea && this._scrollArea.querySelector('.cui-sticky')) {
            this.tabsStickyRect = this._scrollArea
                .querySelector('.cui-sticky')
                .getBoundingClientRect();
            this.bottomPosition =
                this.tabsStickyRect.top + this.tabsStickyRect.height;
        } else {
            this.bottomPosition = SIZING.SYSTEMBAR_HEIGHT;
        }
        this.nextTop = this.bottomPosition;
        this.tableRect = (<HTMLElement>(
            this.tableElementRef.nativeElement
        )).getBoundingClientRect();

        if (this.tableRect.bottom < this.bottomPosition) {
            this.showStickyBatchActions = this.showStickyTableHeader = this.showSticky = false;
            return;
        }

        // check if table headers should be made sticky
        const tableHeaderRect = (<HTMLElement>(
            this.tableHeaderElementRef.nativeElement
        )).getBoundingClientRect();

        // Store latest showStickyTableHeader and prevshowStickyBatchActions status before changing it
        const prevShowStickyTableHeader = this.showStickyTableHeader;
        const prevshowStickyBatchActions = this.showStickyBatchActions;

        this.showStickyTableHeader = this.showStickyBatchActions =
            tableHeaderRect.top < this.nextTop;

        // Move the "Select columns" dropdown to and from the sticky header depending on if it's visible or not
        if (
            !this.editableTable &&
            this.showStickyTableHeader &&
            !prevShowStickyTableHeader
        ) {
            this.stickySelectedColumnsRef.nativeElement.parentNode.insertBefore(
                this.selectedColumnsDropRef.elementRef.nativeElement,
                null
            );
        } else if (
            !this.editableTable &&
            !this.showStickyTableHeader &&
            prevShowStickyTableHeader
        ) {
            this.selectedColumnsRef.nativeElement.parentNode.insertBefore(
                this.selectedColumnsDropRef.elementRef.nativeElement,
                null
            );
        }

        // Move the "Batch actions" dropdown to and from the sticky header depending on if it's visible or not
        if (this.showStickyBatchActions && !prevshowStickyBatchActions && this.stickyBatchActionsContainer) {
            this.stickyBatchActionsContainer.nativeElement.insertBefore(
                this.batchActionsElementRef.nativeElement,
                null
            );
        } else if (!this.showStickyBatchActions && prevshowStickyBatchActions) {
            this.batchActionsContainer.nativeElement.insertBefore(
                this.batchActionsElementRef.nativeElement,
                null
            );
        }

        this.showSticky =
            this.showStickyBatchActions || this.showStickyTableHeader;
        if (this.showSticky && this.stickyHeaderElementRef) {
            this._renderer.setStyle(
                this.stickyHeaderElementRef.nativeElement,
                'top',
                `${this.bottomPosition}px`
            );
            this._renderer.setStyle(
                this.stickyHeaderElementRef.nativeElement,
                'z-index',
                `${this.zIndex}`
            );
            const width = this.tableRect['width'];

            if (this.tableRect['left'] > 0) {
                this._renderer.setStyle(
                    this.stickyHeaderElementRef.nativeElement,
                    'left',
                    `${this.tableRect['left']}px`
                );
            }

            this._renderer.setStyle(
                this.stickyHeaderElementRef.nativeElement,
                'width',
                `${width}px`
            );
        }
    }

    /**
     * Toggles the "Select columns" dropdown
     */
    toggleSelectColumns(): void {
        this.selectedColumnsDropRef.toggleDropdown();
    }

    /**
     * Hides/shows columns based on selected/unselected items in the "Select columns" dropdown
     * @param items
     */
    toggleColumns(items: Array<ITableHeaderItem>): void {
        this.headers.forEach(header => {
            header.hidden = _.findIndex(items, ['id', header['id']]) < 0;
        });
        this.selectedColumns = this.headers.filter(h => !h.hidden);
        this._setRowsVisibility();
        this.checkTableOverflowed();
    }

    /**
     * Function to set the rows visibility based on selected columns
     */
    private _setRowsVisibility(): void {
        this._hasHiddenRows = !(this.selectedColumns.length > 0);
        this.onColumnVisibilityChanged.emit(this.selectedColumns);
    }

    /**
     * Emit onColumnVisibilityChange on selected/unselected items in the "Select columns" dropdown
     * @param items
     */
    itemClicked(item: ITableHeaderItem): void {
        this.onColumnVisibilityChange.emit(item);
    }

    /**
     * Checks if a row is newly added and a placeholder is displayed. In that case a new row will get faded in
     * @return {string}
     */
    onNewRow(): void {
        this.placeholderRowAnimation = 'fade-out';
        this.displayPlaceholderRow = false;
    }

    /**
     * Calculate number of columns used for multiRow
     * @returns {number}
     */
    getColspan(row: ITableRowData): number {
        let length = this.tableElementRef.nativeElement.querySelectorAll('th')
            .length;
        if (this.batchActions.length > 0 || this.selectable) {
            length -= 1;
        }
        if (
            (row && row.rowActions && row.rowActions.length > 0) ||
            this.singleActions.length > 0
        ) {
            length -= 1;
        }
        return length;
    }

    /**
    * Set table title actions with Export mandatory option
    * @returns {void}
    */
    private _setTableTitleActions(): void {
        if (this.tableTitleActions.length > 0) {
            this.titleActions = _.cloneDeep(this.tableTitleActions);
            this.titleActions.push(new Divider());
        }

        if (this._canShowExportAction()) {
            const exportActionItem = new ActionItem({ action: 'export' });
            this.titleActions.push(exportActionItem);
            this._subscriptions.push(
                this.translate.stream(['ODEN.COMMON.EXPORT']).subscribe(res => {
                    exportActionItem.label = `${res['ODEN.COMMON.EXPORT']}...`;
                }));
        }

    }

    private _canShowExportAction() {
        let displayExport = false;

        if (this.onExportCSV.observers.length > 0) {
            // If someone observed
            return true;
        }
        const totalItems = this._paginationData ? this._paginationData.totalItems : -1;

        const totalRows = this.data.length;
        // if pagination component is not provided, then show export
        displayExport = totalItems === -1;
        // if pagination data is in sync, show export
        displayExport = (totalItems === totalRows) || displayExport;

        // if total items is not provided
        if (totalItems === undefined) {
            if (this.onPagination && this.onPagination.observers.length > 0) {
                // if onPagination is subscribed, then hide export
                displayExport = false;
            } else {
                // if onPagination is not subscribed, then show export
                displayExport = true;
            }
        }
        return displayExport;
    }

    /**
     * Table title action event handler.
     * @param {ActionItem} action
     * @param {ITableRowData} item
     * @returns {void}
     */
    titleActionClick(action: ActionItem, item: ITableRowData): void {
        if (action.action === 'export') {
            const headers = this.headers.map((t) => new CSVHeaderItem({
                label: t.label,
                field: t.field
            }));
            // Open the export dialog
            this._subscriptions.push(
                this._exportCSVService.openDialog(headers).subscribe(res => {
                    if (res.export) {
                        headers.forEach(t => {
                            t.hidden = !(res.columns.filter(x => x.label === t.label).length > 0);
                        });

                        if (this.onExportCSV.observers.length > 0) {
                            // Delegate export CSV
                            this.onExportCSV.emit(headers);
                        } else {
                            // Handle export csv
                            const tableData = this._getTableData();
                            this._exportCSVService.doExport(headers, tableData ? tableData.data : []);
                        }
                    }
                }));
        } else {
            const tableAction = new TableAction(action);
            tableAction.items = [item];
            // Emit other actions
            this.onTitleActionClick.emit(tableAction);
        }
    }

    /**
     * Get the table data
     */
    private _getTableData(): {
        headers: CSVHeaderItem[],
        data: string[][]
    } {
        const tableContainerElement: HTMLElement = this.tableElementRef.nativeElement;
        const tableElement = tableContainerElement.getElementsByTagName('table');
        if (tableElement && tableElement.length > 0) {
            return CSVHelper._getTableData(tableElement[0], ['multi-row']);
        }
        return null;
    }
}
