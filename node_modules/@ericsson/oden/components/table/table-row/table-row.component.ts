// tslint:disable:component-selector
import {
    Component,
    ElementRef,
    EventEmitter,
    HostBinding, HostListener,
    Input,
    OnChanges, OnDestroy,
    OnInit,
    Output,
    Renderer2,
    TemplateRef,
    ViewEncapsulation
} from '@angular/core';
import { animate, state, style, transition, trigger } from '@angular/animations';

import { ITableHeaderItem } from '../../../core/interfaces/table-header.interface';
import { EDIT_TYPE } from '../../../core/constants';
import { ANIMATION } from '../../../core/constants/animation.constants';
import { TableAction } from '../../../core/models/table-action.model';
import { ActionItem } from '../../../core/models/action-item.model';
import { ITableRowData } from '../../../core/interfaces/table-row-data.interface';
import { TableEditEvent } from '../../../core/models/table-field.event';
import { TableService } from '../table.service';
import { ALIGNMENT } from '../../../core/constants/alignment.constants';
import { ApplicationService } from '../../../core/services/application.service';
import { DOMHelper } from '../../../core/helpers/dom.helper';
import { NavigationHelper } from '../../../core/helpers/navigation.helper';
import { Router } from '@angular/router';
import { UniversalService } from '../../universal/universal.service';

@Component({
    selector: '[cui-table-row]',
    templateUrl: 'table-row.component.html',
    encapsulation: ViewEncapsulation.None,
    animations: [
        trigger('showError', [
            state('showError', style({ maxHeight: '200px', marginTop: '5px' })),
            transition(':enter', [
                style({ maxHeight: '0', marginTop: '0' }),
                animate('300ms ' + ANIMATION.EASE_IN_OUT_QUINT)
            ]),
            transition(':leave', animate('300ms ' + ANIMATION.EASE_IN_OUT_QUINT, style({
                maxHeight: '0',
                marginTop: '0'
            }))),
        ]),
        trigger('visibility', [
            state('default', style({ opacity: 1 })),
            state('added', style({ opacity: 1 })),
            transition('* => added', [
                style({ opacity: 0.65 }),
                animate('300ms ' + ANIMATION.EASE_IN_QUAD)
            ]),
        ]),
    ]
})

export class TableRowComponent implements OnChanges, OnInit, OnDestroy {
    @HostBinding('class.cui-table-row') addClass: boolean = true;
    @HostBinding('@visibility') visibility: string = 'default';
    @HostBinding('tabindex') tabIndex: number = 0;

    @Input() data: ITableRowData;
    @Input() edit: boolean;
    @Input() focus: boolean;
    @Input() clickable: boolean = false;
    @Input() editableTable: boolean = false;
    @Input() singleActions: Array<ActionItem> = [];
    @Input() hideSingleActions: boolean = false;
    @Input() hasBatchActions: boolean = false;
    @Input() headers: Array<ITableHeaderItem>;
    @Input() selectable: boolean = false;
    @Input() rowTemplate: TemplateRef<any>;
    @Input() singleSelect: boolean = false;
    @Input() rowIndex: number;

    @Output() onBatchChanged: EventEmitter<ITableRowData> = new EventEmitter<ITableRowData>();
    @Output() onSingleClick: EventEmitter<TableAction> = new EventEmitter<TableAction>();
    @Output() onActionMenuDisplay: EventEmitter<ITableRowData> = new EventEmitter<ITableRowData>();
    @Output() onFieldEvent: EventEmitter<TableEditEvent> = new EventEmitter<TableEditEvent>();
    @Output() onNextRow: EventEmitter<ITableRowData> = new EventEmitter<ITableRowData>();
    @Output() onRowClick: EventEmitter<ITableRowData> = new EventEmitter<ITableRowData>();

    /**
     * The following inputs and outputs have been deprecated
     */
    /** @deprecated */
    @Input() useBatchActions: boolean = true;

    private _edit: boolean = false;

    constructor(private _applicationService: ApplicationService, public elementRef: ElementRef,
        private _renderer: Renderer2, private _tableService: TableService,
        private _router: Router, private _universalService: UniversalService) {
        if (_tableService.tableIsNew) {
            this.visibility = 'default';
        } else {
            this.visibility = 'added';
            this._tableService.newRowAdded();
        }
    }

    /**
     * singleClick EventEmitter. Turns param item into [item]. Sends TableAction to EventEmitter.
     * @param action:ActionItem
     * @param item:ITableRowData
     */
    singleClick(action: ActionItem, item: ITableRowData): void {
        const tableAction = new TableAction(action);
        tableAction.items = [item];
        this.onSingleClick.emit(tableAction);
    }

    @HostListener('click', ['$event'])
    click(event: MouseEvent): void {
        if (this.rowTemplate) {
            const closestTd = DOMHelper.closestParentTag((<HTMLElement>event.target), 'td');
            if (closestTd && !closestTd.classList.contains('row-click-disabled')) {
                this.itemClick(this.data);
            }
        }
    }

    /**
     * Emit onNextRow - if the FocusEvent was emitted from a element within this component
     */
    nextRow(event: FocusEvent): void {
        if (this.elementRef.nativeElement.contains(event.relatedTarget)) {
             this.onNextRow.emit(this.data);
        } else {
            // this.elementRef.nativeElement.focus();
            // const inputs = this.elementRef.nativeElement.querySelectorAll('.table-edit-input');
            // if (inputs.length > 0) {
            //    inputs[inputs.length - 1].focus();
            // }
        }
    }
    @HostListener('keyup.enter') onKeyPressEnter() {
        }
    /**
     * itemClick EventEmitter. Passes the item to the callback.
     * @param item: ITableRowData
     */
    itemClick(item: ITableRowData): void {
        if (item.path) {
            if (!item.externalApp) {
                this._applicationService.navigateToPath(item.path);
            } else { // external app navigation
                const route = {
                    path: item.path,
                    externalApp: item.externalApp
                };
                NavigationHelper.navigateToRoute(route, this._router, this._universalService);
            }
        }
        this.onRowClick.emit(item);
    }

    /**
     * Gets alignment class corresponding current align value of header.
     *
     * @param item:ITableHeaderItem
     * @returns {string} - left, center or right
     */
    getAlignClass(item: ITableHeaderItem): string {
        if (item.align == null) {
            item.align = ALIGNMENT.LEFT;
        }
        if (item.align === ALIGNMENT.CENTER) {
            return 'align-center';
        } else if (item.align === ALIGNMENT.RIGHT) {
            return 'align-right';
        }

        return 'align-left';
    }

    /**
     * Set hover styling on row when we hover tds (this does not trigger on the checkbox and actionmenu tds)
     */
    setHoverStyling(): void {
        if (!this.elementRef.nativeElement.classList.contains('hover')) {
            this._renderer.addClass(this.elementRef.nativeElement, 'hover');
        }
    }

    /**
     * Remove hover styling on row when we leave tds (this does not trigger on the checkbox and actionmenu tds)
     */
    unsetHoverStyling(): void {
        this._renderer.removeClass(this.elementRef.nativeElement, 'hover');
    }

    /**
     * Checks if focus is changed
     */
    ngOnChanges(): void {
        if (this.focus) {
            this.setFocus();
        }
        if (this.edit) {
            if (this._edit !== this.edit) {
                this._edit = this.edit;
                if (typeof (this._tableService) !== 'undefined') {
                    this._tableService.updateEditableRows(this.data);
                }
            }
        }
    }

    ngOnDestroy(): void {
        this._tableService.rowDestroyed();
    }

    /**
     * Sets focus to the first input in the row after a short delay. Sets focus to false
     */
    setFocus(): void {
        setTimeout(() => {
            this.elementRef.nativeElement.focus();
            /* const firstInput = this.elementRef.nativeElement.querySelector('.table-edit-input:not(.table-edit-disabled)');
            if (firstInput) {
                firstInput.focus();
            } */
            this.data.focus = false;
        }, 10);
    }

    /**
     * Checks if focus is set
     */
    ngOnInit(): void {
        if (this.data.focus) {
            this.setFocus();
        }
    }

    /**
     * Listener for edit field events. Sets a new value to the editedFields property for this.data
     * @param event
     * @param cell
     */
    fieldEvent(event: TableEditEvent, cell: ITableHeaderItem): void {
        event.row = this.data;
        event.field = this.getEditField(cell);
        if (typeof (this.data.editedFields) === 'undefined') {
            this.data.editedFields = {};
        }
        if (this.data.editedFields[event.field] !== event.value) {
            this.data.editedFields[event.field] = event.value;
        }
        this.onFieldEvent.emit(event);
    }

    /**
     * Checks if field is disabled
     * @param cell
     * @returns {boolean}
     */
    isFieldDisabled(cell: ITableRowData): boolean {
        return this.data.editDisabled !== undefined && this.data.editDisabled.indexOf(this.getEditField(cell)) > -1;
    }

    /**
     * Gets drilldown class if the item has a path property
     * @param {any} - Your data row
     * @returns {string} - left, center or right
     */
    getDrilldownClass(item: ITableRowData): string {
        if (item.path || this.clickable) {
            return 'drilldown';
        } else {
            return '';
        }
    }

    /**
     * Checks if the row is in edit-mode and that this cell can be edited
     * @returns {boolean}
     * @param cell
     */
    isEditable(cell: ITableHeaderItem): boolean {
        if (!this.data.edit) {
            return false;
        }
        return !(cell.editType === EDIT_TYPE.NONE || cell.editType === null);
    }

    getEditField(cell): string {
        if (cell.editField) {
            return cell.editField;
        } else {
            return cell.field;
        }
    }

    /**
     * When a checkbox is changed, we update the rows selected data and emits an event
     * @param event
     * @param row
     */
    onRowChange(event: Event, row: ITableRowData): void {
        row.selected = event.target['checked']; // We know its a checkbox input, but TypeScript doesn't
        this._tableService.rowChecked(row);
        this.onBatchChanged.emit(row);
    }

    /**
     * When a context menu is clicked, we emit an event allowing manipulation of the ActionItems.
     * @param row
     */
    onActionMenuClick(row: ITableRowData): void {
        this.onActionMenuDisplay.emit(row);
    }

    /**
     *
     */
    getEditError(cell: string): string {
        if (this.data.editError) {
            return this.data.editError[this.getEditField(cell)];
        } else {
            return null;
        }
    }
}
