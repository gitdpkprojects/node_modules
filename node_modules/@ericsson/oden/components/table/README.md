[//]: # (title: Table)
[//]: # (category: List & Table)
[//]: # (icon: fa-table)

#Table
* import { 
    ActionItem,
    ListControllerCategoryFilterGroup,
    ListControllerDateFilter,
    ITableHeaderItem,
    ITableRowData,
    PaginationData,
    TableAction,
    TableEditEvent,
    TableModule,
    TableOrderEvent
} from '@ericsson/oden';

```
<cui-table
   [headers]="Array<ITableHeaderItem>"
   [header]="ITableHeaderItem"
   [data]="Array<ITableRowData>"
   [showLoader]="boolean"
   [tableTitle]="string"
   [placeholderRow]="boolean"
   [placeholderRowOverride]="boolean"
   [tableTitleCount]="number"
   [singleActions]="ActionItem[]"
   [batchActions]="ActionItem[]"
   [tableTitleActions]="ActionItem[]"
   (onOrderChanged)="callback($event)"
   (onSingleClick)="callback($event)"
   (onBatchClick)="callback($event)"
   (onTitleActionClick)="callback($event)"
   [pagination]="boolean"
   [paginationData]="PaginationData"
   [selectable]="boolean"
   [stickyHeaders]="boolean"
   (onPagination)="callback(PaginationData)"
   (onBatchChanged)="callback($event)"
   (onActionMenuDisplay)="callback($event)"
   (onRowClick)="callback($event)"
   (onColumnVisibilityChanged)="callback($event)"
   [showEditAllSwitch]="true"
   (onEditAllChanged)="callback($event)"
   [editableTable]="true"
   (onNextRow)="callback($event)"
   [rowTemplate]="TemplateRef"
   [titleTemplate]="TemplateRef"
   [placeholderRowTemplate]="TemplateRef"
   (onColumnVisibilityChange)="callback($event)"
   [multiRowTemplate]="TemplateRef"
   [footerRowTemplate]="TemplateRef"
   [singleSelect]="boolean">
   <cui-list-controller>
   </cui-list-controller>
</cui-table>
```

The following inputs and outputs are deprecated in favour of template inputs:

```
    [filterTemplate]="TemplateRef"
    [showFilter]="boolean"
    (onFieldBlur)="callback(TableEditEvent)"
    (onFieldChanged)="callback(TableEditEvent)"
    (onFieldFocus)="callback(TableEditEvent)"
    [dateFilters]="Array<ListControllerDateFilter>"
    (onDateFilterChanged)="callback($event)"
    [periodDateFilters]="Array<ListControllerDateFilter>"
    [periodDateFilterLabel]="string"
    [periodDateFilterDelimiterLabel]="string"
    [showCategoryFilter]="boolean"
    [categoryFilterGroups]="Array<ListControllerCategoryFilterGroup>"
    (onFilterChanged)="callback($event)"
    (onCategoryFilterChanged)="callback($event)"
    (onPeriodDateFilterChanged)="callback($event)"
```

## Required Inputs
###[headers]:_Array\<ITableHeaderItem\>_ or [header]: ___ITableHeaderItem___ _*_
If you use the property `headers` should be an array of one or more _ITableHeaderItem[s]_. You need to create a model which implements this interface.
_ITableHeaderItem.field_ property is matched to each and every objects in you _data_ array.
If you use `header`, then only only an ITableHeaderItem is expeced.

_Note: Do not use both._

###[data]:_Array&lt;ITableRowData&gt;___*__
Should be an array of the objects you want to display. Your objects should implement the `ITableRowData` interface, or extend the `TableRowData` class.

* **multiRow**: boolean - If true, a row below the specific row will be displayed.
* **multiRowWrap**: boolean - If true, the multirow will be displayed in multiple lines.
* **hidden**: boolean - If true, the row will not be displayed in the table. This is useful when you paginate your own data and have batchActions.
* **selected**: boolean - If the row is selected.
* **focus**: boolean - If the row should be focused. Can be set in runtime, and will always be set to false by the TableComponent after the row is focused.
* **uuid**: string - A unique identifier for this row - be sure to set this value to a app unique value if you don't extend the ``TableRowData`` class.
* **singleActions**: boolean - If false, no single actions will be displayed for this row.
* **rowActions**: ActionItem[] - This property can be used to specify context menu with different action for each row. This property will be given higher priority over singleActions if set.
See an example in `table-inline-button.component` in the demo application.

#### The following properties have been deprecated:

* **path**: string - If defined, the row will be clickable and the user will navigate to that path.
* **edit**: boolean - Set to true to enable editing of this row. See Editable tables further down
* **editError**: {} - Set this to {field: 'error message'} to show a error message under the input if the row is in edit mode.
* **editedFields**: {} - Will be set by the Table Component once an edit has changed the value. Use this to see the changes done for the entire row.

## Optional Inputs

###tableTitle:_string_
Displays a title above the table

###tableTitleCount:_number_
Displays a data count with the number of items you set. Only visible when a `tableTitle` is present.

###placeholderRow:_boolean_
Displays a placeholder row for when using editable tables. The placeholder row is shown when:
    * No rows are present
    * One or more rows have been changed by the user
The placeholder is hidden when:
    * The placeholder is clicked
    * No rows are in edit
    
** note: The behaviour of the placeholder row are set when the table is created,
do not change this value after. If you want to control the behaviour yourself, use `placeholderRowOverride` **

###placeholderRowOverride:_boolean_
Can be toggled to `true` or `false` to show or hide the placeholder row. 
Default value is `null` to avoid animation fade in or fade out.
**note: do not use in combination with `placeholderRow`=true**

###[singleActions][batchActions]:_ActionItem[]_
singleActions and batchActions should be an Array of ActionItem(s). These will be sent back to your callback (_onSingleClick_ or _onBatchClick_) as a _TableActionItem_ when that action is called.
* If batchActions is specified, each row will have a column with a checkbox inside; Representing the _selected: boolean_ value.
* If singleActions is specified, each row will have a secondary action menu on the right side.

###(onSingleClick)(onBatchClick):_function($event: TableActionItem)_
A callback which is sent when an action is pressed by the user.
_TableActionItem_ is an extension of _ActionItem_ that also contains the effect items from your _data_.
The effected items from your _data_ is always in an Array in _TableActionItem.items_ property - **even** if it goes to the _onSingleClick_ callback.

###(onOrderChanged):_function($event: TableOrderEvent)_
_onOrderChanged_ is called when a user presses a header which is sortable. You can disable sorting for a specific field by setting _ITableHeaderItem.sortOrders_ to _[ORDERS.NONE]_

###(onCategoryFilterChanged):_function($event)_
_onCategoryFilterChanged_ is called when a user checks an item in the category filter. 
This event emits an object that consists of `group` (the chosen `ListControllerCategoryFilterGroup`) and `ngModel` (the selected combo box items).

###[showLoader]:_boolean_
**DEPRECATED!** Use the [cuiLoader](#/readme/loader.md) directive instead.

If true, a loader will overlay this component. Defaults to false.

###[pagination]:_boolean_
An optional setter, defaults to false.
If set to true this table will display a `PaginationComponent`.
Even if this is set to true, it is _not_ required to specify `onPagionation` nor `paginationData` -
the component will handle pagination within itself.

###(onPagination): callback(PaginationData)
If this is set, the TableComponent will not handle any pagination within itself.
Sends the PaginationData whenever a user changes the PaginationData
Note: The PagionationComponent edits the same object as you specify, meaning that any changes the users has made should already be present in your PaginationData.
#### Handling batchSelect with your own pagination service
To follow the standard way of handling batchSelect, where the selected rows are kept between different pages you should use `TableRow.hidden` property.
Hidden rows are not displayed, but will still be sent to your `onBatchClick` when ever a user does a batchAction

###(paginationData): PaginationData
Enables you to specify how the user can Paginate your data.
If you set this value, you are required to specify how many total rows there are in your data.
The only reason you should set this should be if you want to change the rowsPerViewAlternatives or currentPage properties.
See PaginationComponent for more information.

###[selectable]:_boolean_
An optional setter, defaults to false.
If set to true this table will allow for selecting rows. When selecting a row `onBatchChanged` will be emitted and data can be handled without the use of batch actions.

###[stickyHeaders]:_boolean_
An optional setter, defaults to false.
ONLY use this for a table placed directly on canvas and with a full width.
If set to true table column headers and batch actions will stick to top of screen when scrolling in table.

###(onBatchChanged): callback(Array<ITableRowData>)
If you listen to this event, you can manipulate the ActionItems used for batchActions, creating the possibility to change values for them such as disabling them.
The parameter is an Array of `ITableRowsData` is all the selected rows.

###(onActionMenuDisplay): callback(ITableRowData)
If you listen to this event, you can manipulate the ActionItems used for singleActions, creating the possibility to change values for them such as disabling them.
The parameter is the `ITableRowsData` which the action menu is displayed for.

###(onRowClick): callback(ITableRowData)
This callback triggers when a user clicks a table row. If the `ITableRowData` doesn't have a `path` assigned, rows will normally not be clickable - using this input changes that.

If you're using `[rowTemplate]` and want a certain `<td>` in it to not fire the `(onRowClick)` - set `class="row-click-disabled"` on it.

###(onColumnVisibilityChanged): callback(ITableHeaderItem)
This callback triggers when user hide/unhide the table columns.
The parameter is an Array of `ITableHeaderItem` is all the selected columns to display.

###onFieldBlur: callback(TableEditEvent)
Emits when a field is blurred

###onFieldFocus: callback(TableEditEvent)
Emits when a field is focused

###onFieldChanged: callback(TableEditEvent)
Emits when a field is changed, or keyup is pressed in text-input

###onFieldEvent: callback(TableEditEvent)
Emits when a field is blurred, changed/keyup or is focused.

###showEditAllSwitch: boolean
Shows a "Edit all" switch. Use the ``onEditAllChanged`` event to listen to this change.

###onEditAllChanged: function(boolean)
Emits when the Edit all switch is toggled

###editableTable: boolean
Set this to true to enable some features in the table, such as tab-support.

###onNextRow: function(ITableDataRow|null)
Emits when a user tabs to the next row. Can be used to add new rows, or enable editing of rows.

###onColumnVisibilityChange: function(ITableHeaderItem|null)
Emits when a user selects/unselects items in the ``Select columns`` dropdown.

### [headerTemplate]:_TemplateRef_
A TemplateRef which you can define in your view, to control the content of your headers. 
Your header is accessed via `let-x="header"` where `x` is your preferred name of the variable. 

This template will be used for each header (`<TH>`), unlike the rowTemplate.

```
     <ng-template #headerTemplate let-header="header">
        <span cui-table-sorting>{{header.label}}</span>
        <cui-info-button *ngIf="header.field === 'age'" class="no-click" [text]="'Age is only a number'"></cui-info-button>
    </ng-template>
```

Note: add the directive `cui-table-sorting` to tell the table component that the default click behaviour should be applied.

### [rowTemplate]:_TemplateRef_
A TemplateRef which you can define in your view, to control the content of your rows. 
Your row is accessed via `let-x="row"` where `x` is your preferred name of the variable. 

```
    <ng-template #rowTemplate let-row="row">
        <td [innerHTML]="row.property"></td>
    </ng-template>
```
See `table-simple.component`

There is no limitation for what each TD can contain, but the table component doesn't support everything.

To handle editable table, add `*ngIf="row.edit"` to separate edit and non-edit modes.

Each input needs the class `table-edit-input` to handle focus events.

You can display an edit error with `<p class="error-text">message</p>` in your cell.

By default TD text is truncated, use the class `show-full-text` show full text of TD without truncation.

See `editable-table-2.component` and `editable-table-1.component`

### [titleTemplate]:_TemplateRef_
A TemplateRef which you can define in your view, to control the content of the table title.
See `table-simple.component`

```
<ng-template #titleTemplate>
    Table Header
    <span>(100)</span>
</ng-template>
```

### [multiRowTemplate]:_TemplateRef_
A TemplateRef which you can define in your view, to control the content of a multi-row of the table.
See an example in `table-simple.component` in the demo application

```
<ng-template #multiRowTemplate let-row="row" let-colspan="colspan">
    <td [innerHTML]="row.description" [attr.colspan]="colspan"></td>
</ng-template>
```

### [footerRowTemplate]:_TemplateRef_
A TemplateRef which you can define in your view, to control the content of a custom table footer.

### [singleSelect]: boolean
If set to true only one row per table can be selected at the same time (singleSelect boolean outputs radiobutton (true) or checkboxes (false)).

### [useBatchActions]: boolean
If set to false the table batch bar will not be displayed. 
```
<ng-template #footerRowTemplate>
    <td>Totals</td>
    <td>70 EUR</td>
</ng-template>
```


### [placeholderRowTemplate]:_TemplateRef_
A TemplateRef which you can define in your view, to control the content of the placeholder row.
See `table-simple.component`

## The following inputs and outputs have been deprecated

###[showFilter]:_boolean_
If true, a filter will show above the table headers.

###(onFilterChanged):_function($event: string)_
_onFilterChanged_ is called when a user types text in to the filter input

###[showCategoryFilter]:_boolean_
If true, a category filter combobox will show above the table headers.

###[categoryFilterGroups]:_Array&lt;ListControllerCategoryFilterGroup&gt;_
An array of `ListControllerCategoryFilterGroup` containing label and items (`ListControllerCategoryFilterItem`) for the category filter.
Each group will result in a combo box in the list controller area above the table. 


###[dateFilters]:_Array&lt;ListControllerDateFilter&gt;_
An array of `ListControllerDateFilter`s, each will result in a date/datetime/time component in the list controller area above the table. 

```
export class ListControllerDateFilter {
    label: string;
    field?: string;
    type: DATE_TYPE; // DATE_TYPE.DATE, DATE_TYPE.DATETIME or DATE_TYPE.TIME
    value?: Date | string;
}
```

###(onDateFilterChanged):_function($event)_
_onDateFilterChanged_ is called when a user changes the date/time in one of the date filter components.
This event emits an object that consists of `filter` (the chosen `ListControllerDateFilter`) and `ngModel` (the value of the date component).

###[periodDateFilters]:_Array&lt;ListControllerDateFilter&gt;_
An array of `ListControllerDateFilter`s (needs to be exactly 2) that together will result in a date range picker in the list controller area above the table.

###(onPeriodDateFilterChanged):_function($event)_
_onPeriodDateFilterChanged_ is called when a user changes the date/time in one of the date range picker components.
This event emits the `periodDateFilters`.

###[periodDateFilterLabel]:_string_
The text that goes before the period range picker (default is `'Date between'`)

###[periodDateFilterLabel]:_string_
The text that goes between the two date components in the period range picker (default is `'to'`).

### [filterTemplate]:_TemplateRef_
A TemplateRef which you can define in your view, to control the content of the filter.
Use `<cui-list-controller>` directly inside `<cui-table>` instead, see `table-simple.component`

##ITableHeaderItem

###Required data
* **label**:_string_ - A label which is shown in the header of the table or list
* **order**:_ORDER_ - the order which the data is sorted by. ASC, DESC or NONE
* **field**:_string_ - The field from which the data should be fetched from your specified _data_ input

###Optional data
* **sortOrders**:_ORDER[]_ - Limits sorting to specific set of sort orders
* **tooltip**:_string_ - Shows up if you hover the header - Not implemented yet
* **align**:_ALIGNMENT_ - Align your text RIGHT, LEFT or CENTER.
* **width**:_string_ - The width of the cell in px or percent(eg. '100px' or '15%') - Required for column set
* **orderType**: _ORDER_TYPE_ - Enable built in ordering for common types: STRING, NUMBER and DATE. See *Ordering*
* **orderField**: _string_ - Order the data on a different field then the display value. See *Ordering*

### The following properties have been deprecated
* **fieldType**: _FIELD_TYPE_ - See *Table cell types* - ** Deprecated **
* **editData**: _any_ - See further down - ** Deprecated ** 
* **editRequired**: _boolean_ - Sets the ``required`` attribute on the input - ** Deprecated ** 
* **editPlaceholder**: _string_ - A Placeholder used on text-inputs - ** Deprecated **
* **editType**: _EDIT_TYPE_ - Kind of input, see further down - ** Deprecated **
* **editField**: _string_ - If the data displayed in the table isn't the same as the one that should be changed, for example in a select where the displayed value and selected valued are different. ** Deprecated **

####EDIT_TYPE - ** Deprecated **
This value must be set for a field to be editable - null or EDIT_TYPE.NONE will result in a uneditable field.
* NONE - No input will be shown for this field
* TEXT - A regular input for text is displayed
* SELECT - A select dropdown is shown, set your values in the editData property
* MULTISELECT - A multi select dropdown is shown, set your values in the editData property
* CHECKBOX - True or False checkbox
* TEXTAREA - A textarea

####editData - ** Deprecated **
An object which can be used to change behaviour. See further down for usage.
*note: The select options cannot be different per row since it's defined in the header.*

##TableEditEvent ** Deprecated **
A table edit event is sent when a field is focused, blurred or changed.
You can either get these events with the collected event emitter ``onFieldEvent`` or their separate events.
Values:
* **element**: Element - The element which emitted the event
* **row**: ITableRowData - The row which the element belongs to
* **field**: string - The field that was changed. If you defined an ``editField`` for the header, this value will be present here
* **eventType**: FIELD_EVENT_TYPE - What type of event (blur, focus et c)

To get the new value, check your row.`field`

##TableActionItem _extends ActionItem_
This model is sent to events triggered by _singleClick_ and _batchClick_
* **items**:_Array<any>_ - The affect rows

####table-action.model.ts
```
export class TableAction extends ActionItem {
    items: Array<any>;
}
```

####action-item.model.ts
```
export class ActionItem extends QuickAssign {
    label: string;
    action: string;
    disabled: boolean = false;
    tooltip?: string;
}
```
## Ordering

To order your data you can either use the built in methods or a custom method.
To use the built in method, simply set your `TableHeaderItem`.`orderType` to one of the following:

* ORDER_TYPE.NUMBER
* ORDER_TYPE.STRING
* ORDER_TYPE.DATE

`Number` and `string` is both simple, but Date has an built in method to handle `Date strings`.
If you set Order Type to date, but the data for the date is a `string` the Table Component (via `OrderHelper`) will attempt to create Dates objects from your string.
However - it's highly recommended that you provide a Date object for performance. If you have your date in a timestamp number format, use `ORDER_TYPE.NUMBER` instead.

To order on data in your row that is different from your display data, use `orderField` property. This is useful when you want to display in on Date format, but want to order on for example a timestamp.

If your order methods are more complex - or even uses Backend services, you need to listen to the `onOrderChanged`.

*Note: If you have defined `orderType` for a table header, when that table header is ordered it will not emit an onOrderChanged event*


# **The following section is deprecated, use templates instead**
## Editable Tables

To use editable tables there are a couple of values which you need to define, and a certain workflow which you need to implement in your component.
The Oden TableComponent doesn't set the `edit` or `focused` values, this is something your component must handle.

To see the editable tables, see editable-table-1 and editable-table-2 components in the Oden library demo.

### Step 1
#### Define edit types
To use editable tables, you first must define at least one value in your headers (`ITableHeaderItem`).

    editType: EDIT_TYPE;

Set this value one of the following:

* EDIT_TYPE.NONE - No field will be shown, only the regular output.
* EDIT_TYPE.TEXT - Regular Text input
* EDIT_TYPE.TEXTAREA - A Textarea
* EDIT_TYPE.SELECT - A Select box (Be sure to set you `ITableHeaderItem`.`editData` property, see example under editData in the documentation)
* EDIT_TYPE.CHECKBOX - A Checkbox which will return either true or false.
* EDIT_TYPE.DATE - A Input for date with optional picker
* EDIT_TYPE.TIME - A Input for time with optional picker
* EDIT_TYPE.DATETIME - A Input for date and time with optional picker
* EDIT_TYPE.DATETIME_PERIOD - Two Inputs for date and time (From and To) with optional picker. Requires the editField value to follow {to: Date, from: Date} format.

### The `editData` property
Some Edit types can use this property to change behaviour. Here are the available options:

* `SELECT` & `MULTISELECT`
    * editData: `[ { label: string, value: any } ]`
    * Default: `[]`
    * Example:
        ```
        [
            {
                label: 'The label of the option',
                value: 'The value of the option'
            },
        ]
        ```

* `TIME` & `DATETIME`
    * editData: `{ showSeconds: boolean, showPicker: boolean }
        * `showSeconds` - If true, the picker will display a slider for seconds. Also affects placeholder and validation
        * `showPicker` - If false, no picker will be shown - Only a input
    * Default: { showSeconds: false, showPicker: true }

* `DATETIME_PERIOD`
    * editData: `{ showSeconds: boolean, showPicker: boolean, text: string }
        * `showSeconds` - If true, the picker will display a slider for seconds. Also affects placeholder and validation
        * `showPicker` - If false, no picker will be shown - Only a input
    * Default: { showSeconds: false, showPicker: true, text: 'to'}
    * editField: The value of the editField property should be an object typed as `{to: Date, from: Date}`

* `DATE`
    * editData: `{ showPicker: boolean }`
            * `showPicker` - If false, no picker will be shown - Only a input
    * Default: { showPicker: true }

* `TEXT` & `TEXTAREA`
    * editData: `{ strictPattern: RegExp, maxLength: number }`
        * `strictPattern` - If the input string does not match the RegExp, the last input will be ignored
        * example: `{ strictPattern: /^\d*$/ }` - When a user inputs anything but a number, the input will be ignored.
        * `maxLength` - The maximum length of the string.
    * Default: `{}`

### Step 2
####Prepare your data
The property `ITableRowData`.`editField` can be used to let the user change some data that is not the same data as you present.
Can be useful when you want to display Yes / No instead of true / false.
It can also be helpful when you use a select, since the select values might differ from the display values:

For example:
You want the user to change an Entity name, but if the user tries to save a name which is not valid, you can easily change back the name.
This field is also useful in selects, where the data-value of the select might not be the same as the displayed value.

Lets use this select's editData as en example:

````
{
    editType: EDIT_TYPE.SELECT,
    label: 'Location',
    field: 'location',
    editField: 'locationValue',
    editData: [
        {
            label: 'Chennai',
            value: 'india-chennai'
        }, {
            label: 'Karlskrona',
            value: 'sweden-karlskrona'
        },
    ]
}
````
the `ITableRowdata`:
````
export class LocationRow extends TableRowData {
    location: string;
    locationValue: string;
}
````

By doing like this, the selector will use the `locationValue` when matching to the array of options.

If for some reason you need to disable editing on certain fields on certain rows - use the `editDisabled` `array`. The array should contain strings with names of field that are disabled on each row.
For example, to disable the location selector on a row - set `editDisabled` to `['locationValue']`

*note: The disabled field should be the same as the editField if any*


### Step 3
####Setup your component

An editable table many useful listeners, and some which is vital to your application. The basic of these methods are covered at the top of this documentation,
but we will look at what we can use this events for.

##### The field events - onFieldBlur, onFieldFocus, onFieldChanged and onFieldEvent

Emits when blurred, focused or when a field is changed (keyup for text-inputs).
With these methods we can easily add some validation to our fields - which is covered later in this documentation.

**note**: `DATE`, `DATETIME` & `TIME` does not emit `blur` or `focus`.

#### The Edit All Switch - onEditAllChanged: function(boolean)
Emits when the Edit all switch is toggled, be sure to set the property `showEditAllSwitch` to get this event.
Since the TableComponent don't handle when a row is set to edit mode or when it's suppose to go out of edit mode, we need to be sure to do this.
We can also invalidate and put focus to a row that doesn't pass validation.

#### The Tab-key: onNextRow: function(ITableDataRow|null)
When a row is in edit mode, and the user tabs to the next row, we can use this event to enable editing of the next row (provided by the emitter), or create a new row (if the emitted value was null)
**note**: the actual tab-listener is on the row above the row that is emitted. There is a hidden input which receives the focus event, and after that the TableComponent gets and emits the next row or null

#### Make the table editable - [editableTable]:boolean
Set the [editableTable] attribute to `true` for the <cui-table> tag.
This adds some hidden functionality in the table, such as the hidden tab-focus element

### Step 4

#### Scenario A: Editing a row in a table with predefined data
If we have a collection of rows that we can edit, we simply add an `ActionItem` to the `singleActions` input/property for the `TableComponent`.
We listen to the `onSingleAction`-event from the TableComponent, and when the save action is received we set the `ITableRowData`.`edit` to true.
After we do this, the row will become editable. Directly after this, we also want the user to get focus on he row, and this is done with the `ITableRowData`.`focus` property.
When `focus` is set to true, the `TableComponent` will notice this change, and change focus to this row. After this, the `TableComponent` will change the value of `focus` to `false`.

For these kind of tables, it is important to listen to `onNextRow` event to make the next row editable when the user tabs to a new row.

This behaviour is shown in editable-tables-1 component

#### Scenario B: Show the user an empty table with one editable row
By only providing an collection of one `ITableRowData` which has the property `edit` set to `true`, the row will be editable directly after it is rendered.
The `focus` property should only be set if you want the user to have focus on this row from the page load.
For these kinds of tables, you may want to add a function in your `onNextRow` to add a new row if the argumented value is `null`.

This behaviour is shown in editable-tables-2 component

### Step 5
#### Validating and saving
When you listen to the events emitted by `onFieldEvent` (or the more specific events) you can validate your fields inside your function.
The `field` and `row` is emitted in the `TableEditEvent`, see further up for a specification.
With these values, you can validate the input. Either hard or soft(`TableEditEvent.row.field` for hard or `TableEditEvent.row[field]` for a soft generic validation)

If something is invalid, use the `ITableRowData`.`editError` property. For example, we don't allow the name field to be less then three chars:
````
    onFieldEvent(event: TableEditEvent) {
        row = <OurTypeOfRow>event.row;
        if (event.field === 'name' && event.row.name.length < 3) {
            row.editError['name'] = 'Name must be at least three chars';
        }
        if (row.editError['name'] !== null && event.field === 'name' && event.row.name.length >= 3) {
            row.editError['name'] = null;
        }
    }
````
**Note**: We need to cast to our type of row, since the returned type will be generic.

To save, send the data available in the `ITableRowdata`.`editedFields` property to your service and set the `ITableRowData`.`edit` to `false`
The ITableRowdata`.`editedFields` is in the format of [string]=value.

### Table cell types
`ITableHeaderItem`.`fieldType` FIELD_TYPE

By using this, the `field` on the row is expected to be a specific class

* STATE: `EntityVersion` - Only `state`, `tooltip`, `label` and `extra` properties are used
* VERSION: `EntityVersion` - Only `label`, `tooltip` and `extra` properties is used
* DATE: `Date` - Will display a date in the browsers locale
* DATETIME: `Date` - Will display a date with time in the browsers locale
* BUTTON: `TableButtonAction` - `ActionItem` with `description` property
* CHECKBOX: `boolean` - Will display a checkbox.
