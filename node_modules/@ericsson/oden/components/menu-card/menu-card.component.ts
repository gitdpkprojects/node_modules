import {
    Component,
    ElementRef,
    EventEmitter,
    HostBinding, HostListener,
    Input,
    OnDestroy,
    AfterViewInit,
    Output,
    Renderer2,
    ViewEncapsulation
} from '@angular/core';
import { Router } from '@angular/router';
import { UniversalService } from '../universal/universal.service';
import { UnSub } from '../../core/classes/subscription.decorator';
import { Subscription } from 'rxjs/Subscription';
import AnimationHelper from '../../core/helpers/animation.helper';
import { NavigationHelper } from '../../core/helpers/navigation.helper';

export type MenuCardItem = {
    label: string,
    path: string,
    externalApp: string,
    newWindow: boolean,
    favorite: boolean
};

@Component({
    selector: 'cui-menu-card',
    templateUrl: './menu-card.component.html',
    styleUrls: ['./menu-card.component.scss'],
    encapsulation: ViewEncapsulation.None
})
@UnSub()
export class MenuCardComponent implements OnDestroy, AfterViewInit {
    @HostBinding('class.cui-menu-card') addClass: boolean = true;
    @HostBinding('class.active') active: boolean = false;
    @HostBinding('attr.id') get _id(): string {
        return this.id ? this.id.replace(/\W/g, '_') : null;
    }
    @Input() id: string;
    @Input() title: string;
    @Input() category: string;
    @Input() menuItems: Array<MenuCardItem>;
    @Input() newWindow: boolean = false;
    @Input() favoritesEnabled: boolean;
    @Input() loadingId: string;

    @HostBinding('class.clickable') @Input() clickable: boolean;

    @Output() onOpen: EventEmitter<MenuCardComponent> = new EventEmitter<MenuCardComponent>();
    @Output() onClick: EventEmitter<any> = new EventEmitter<any>();
    @Output() onClose: EventEmitter<MenuCardComponent> = new EventEmitter<MenuCardComponent>();
    @Output() onMenuSelected: EventEmitter<MenuCardItem> = new EventEmitter<MenuCardItem>();

    @Input() favorite: boolean = false;
    @Output() onFavoriteChange = new EventEmitter<boolean>();

    loadingClass: boolean = false;
    animationDone: boolean = false;
    private _subscriptions: Array<Subscription> = [];
    private _timeouts = [];

    constructor(
        private _universalService: UniversalService,
        private _renderer: Renderer2,
        private _elementRef: ElementRef,
        private _router: Router
    ) {
        this._subscriptions.push(this._universalService.onShowUniversalOverlay.subscribe(() => {
            this.openOnLoad();
        }));
        this._subscriptions.push(this._universalService.onFilterApps.subscribe(() => {
            this._timeouts.push(setTimeout(() => {
                this.openOnLoad();
            }));
        }));
    }

    ngAfterViewInit(): void {
        this._timeouts.push(setTimeout(() => {
            this.openOnLoad();
        }));
    }

    trackBy({ }, item: MenuCardItem) {
        return item.path;
    }

    @HostListener('click', ['$event'])
    onClickListener(event) {
        if (this.clickable) {
            this.toggleMenu();
            this.onClick.emit(event);
        }
    }

    isSitemap(): boolean {
        return this._universalService.showSitemap;
    }

    get filteredMenuItems(): any {
        let filteredItems = this.menuItems;
        // If user is filtering on freetext
        if (this._universalService.appFilterString !== '') {
            filteredItems = this.menuItems.filter((item: MenuCardItem) => {
                return item.label.toLowerCase().indexOf(this._universalService.appFilterString.toLowerCase()) > -1;
            });
        }
        // If user is filtering on favorites
        if (this._universalService.showOnlyFavorites) {
            return filteredItems.filter((item: MenuCardItem) => item.favorite);
        }
        return filteredItems;
    }

    ngOnDestroy() {
        if (this._subscriptions.length) {
            this._subscriptions.forEach((subscription: Subscription) => {
                subscription.unsubscribe();
            });
        }
    }

    /**
     * If a card has an active item that is external the current active page should not be marked as active
     *
     * @param itemPath
     * @returns {boolean}
     */
    isPathActive(itemPath: string) {
        if (NavigationHelper.getActiveIFrame()) {
            const url = NavigationHelper.getVaildRoutePath(itemPath);
            const iframeSrcTrimHash = NavigationHelper.getActiveIFrame().src;
            return iframeSrcTrimHash === window.location.origin + url;
        } else {
            return this._router.isActive(itemPath, false);
        }
    }

    /**
     * Checks if an iframe for an external app opened internal exists
     *
     * @returns {boolean}
     */
    externalAppIframeExists(): boolean {
        return NavigationHelper.getActiveIFrame() ? true : false;
    }

    /**
     * Auto open menu card if it contains an active link or if user filtered on favorites
    */
    openOnLoad(): void {
        this._renderer.addClass(this._elementRef.nativeElement.querySelector('.menu-card-menu'), 'visible');
        const activeLinkInside = this._elementRef.nativeElement.querySelectorAll('.menu-card-menu-item.active').length;
        const isSitemap = !this._universalService.showSitemap;
        const cardMenuItems = Array.from(this._elementRef.nativeElement.querySelectorAll('.menu-card-menu-item'));
        if (!isSitemap && !this.active) {
            cardMenuItems.forEach((cardMenuItem: HTMLElement) => {
                cardMenuItem.removeAttribute('tabindex');
            });
        }
        if ((activeLinkInside
            || this._universalService.appFilterString !== ''
            || this._universalService.showOnlyFavorites)
            && !this.active && this.filteredMenuItems.length > 0) {
            this.animationDone = false;
            this.clearTimeouts();
            this._renderer.addClass(this._elementRef.nativeElement, 'no-transition');
            this.toggleMenu();
            this._timeouts.push(setTimeout(() => {
                this._renderer.removeClass(this._elementRef.nativeElement, 'no-transition');
            }, 600));
        } else if (this.active && (this.filteredMenuItems.length < 1 || !(activeLinkInside
            || this._universalService.appFilterString !== ''
            || this._universalService.showOnlyFavorites))) {
            this.animationDone = false;
            this.clearTimeouts();
            this._renderer.addClass(this._elementRef.nativeElement, 'no-transition');
            this.toggleMenu();
            this._timeouts.push(setTimeout(() => {
                this._renderer.removeClass(this._elementRef.nativeElement, 'no-transition');
            }, 600));
        }
    }

    clearTimeouts(): void {
        this._timeouts.forEach((timeout) => {
            clearTimeout(timeout);
        });
        this._timeouts = [];
    }

    /**
     * If there is an onOpen function specified in the <cui-menu-card> we run it here.
     */
    open(): void {
        this.clearTimeouts();
        this._renderer.addClass(this._elementRef.nativeElement.querySelector('.menu-card-menu'), 'visible');
        const menuItemElements: Array<HTMLElement> = Array.from(this._elementRef.nativeElement.querySelectorAll('.menu-card-menu-item'));
        menuItemElements.forEach((itemElem) => {
            itemElem.setAttribute('tabindex', '0');
        });
        AnimationHelper.animateItemsStepped(this._renderer, menuItemElements, 25, false)
            .then(() => this.animationDone = true);

        this.onOpen.emit(this);
    }

    /**
     * If there is an onClose function specified in the <cui-menu-card> we run it here.
     */
    close(): void {
        const menuItemElements = <Array<HTMLElement>>Array.from
            (this._elementRef.nativeElement.querySelectorAll('.menu-card-menu-item')).reverse();
        menuItemElements.forEach((itemElem) => {
            itemElem.removeAttribute('tabindex');
        });
        AnimationHelper.animateItemsStepped(this._renderer, menuItemElements, 25, false)
            .then(() => {
                this.animationDone = false;
                this._timeouts.push(setTimeout(() => {
                    this._renderer.removeClass(this._elementRef.nativeElement.querySelector('.menu-card-menu'), 'visible');
                }, 300));
            });

        this._renderer.addClass(this._elementRef.nativeElement, 'clickable');
        this.onClose.emit(this);
    }

    /**
     * Toggles the state (active/inactive) of a card.
     */
    toggleMenu(event?: MouseEvent): void {
        if (event) {
            event.stopPropagation();
        }
        this.active = !this.active;
        if (this.active) {
            this.open();
        } else {
            this.close();
        }
    }

    /**
     * Set this card as favorite
     *
     * @param favorite boolean to set as favorite or not
     * @param event
     */
    toggleFavorite(event?: MouseEvent): void {
        if (event) {
            event.stopPropagation();
        }
        this.favorite = !this.favorite;
        this.onFavoriteChange.emit(this.favorite);
        this._universalService.toggleAppFavorites(this.id, this.favorite);
    }

    toggleItemFavorite(event: MouseEvent, item: MenuCardItem): void {
        event.stopPropagation();
        this._universalService.toggleFavorite(item.path);
    }

    isItemFavorite(item: MenuCardItem): boolean {
        return item.favorite;
    }

    hasAppAnyItemFavorite(): boolean {
        return this.filteredMenuItems.some(item => this.isItemFavorite(item));
    }

    /**
     * Handle menu click
     *
     * @param event
     * @param item
     */
    selectMenuItem(event: Event, item: MenuCardItem): void {
        event.stopPropagation();
        this.onMenuSelected.emit(item);
    }
}
