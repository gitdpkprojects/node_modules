import {
    Component,
    ComponentRef,
    ElementRef,
    EventEmitter,
    HostListener,
    Input,
    OnChanges,
    OnDestroy,
    OnInit,
    Output,
    Renderer2,
    SimpleChanges,
    ViewChild,
    ViewEncapsulation
} from '@angular/core';
import { KEYBOARD } from '../../core/constants/keyboard.constants';
import { Tag } from '../../core/models/tag.model';
import { DOMHelper } from '../../core/helpers';
import { OverlayHelperService } from '../overlay/overlay-helper.service';
import { IOverlayable } from '../overlay/overlayable.interface';
import { BackdropComponent } from '../backdrop/backdrop.component';
import { BackdropService } from '../backdrop/backdrop.service';
import { OVERLAY_CONTEXT } from '../overlay/overlay.constants';

enum Direction {
    UP,
    DOWN,
    RIGHT,
    LEFT
}

@Component({
    selector: 'cui-tags',
    templateUrl: 'tags.component.html',
    styleUrls: ['tags.component.scss'],
    encapsulation: ViewEncapsulation.None
})
export class TagsComponent implements OnInit, OnDestroy, IOverlayable, OnChanges {
    @Input() promotedTags: Array<Tag>;
    @Input() selectedTags: Array<Tag>;
    @Input() placeholder: string = 'Add new tags with ","';
    @Input() readonly: boolean = false;
    @Input() acceptNewTags: boolean = true;
    @Input() limit: number = 0;
    @Input() required: boolean;

    @Output() onAdd: EventEmitter<Tag> = new EventEmitter<Tag>();
    @Output() onRemove: EventEmitter<Tag> = new EventEmitter<Tag>();
    @Output() onSearch: EventEmitter<string> = new EventEmitter<string>();

    @ViewChild('input') input;
    searchTerm: string = '';
    index: number = 0;
    isFocused: boolean = false;
    focusListener: () => void;
    blurListener: () => void;
    private _hiddenValue: Array<Tag>;

    // Overlay
    public overlayHelperService: OverlayHelperService;
    @ViewChild('dropdownContent') overlayElement: ElementRef;
    @ViewChild('overlayTarget') elementRef: ElementRef;
    openedInOverlay: boolean = false;
    backdrop: ComponentRef<BackdropComponent>;

    get isReadOnlyOrFull(): boolean {
        return this.readonly || (this.limit > 0 && this.selectedTags.length === this.limit);
    }

    // hiddenValue only used to get valid or invalid state for the hidden input field
    get hiddenValue(): Array<Tag> {
        return this.selectedTags.length > 0 ? this.selectedTags : null;
    }
    set hiddenValue(tags: Array<Tag>) {
        this._hiddenValue = tags;
    }


    constructor(
        public renderer: Renderer2,
        private _elementRef: ElementRef,
        overlayHelperService: OverlayHelperService,
        private _backdropService: BackdropService
    ) {
        this.overlayHelperService = overlayHelperService;
    }

    ngOnInit(): void {
        this.focusListener = this.renderer.listen(this.input.nativeElement, 'focus', () => {
            this.isFocused = true;
        });
        this.blurListener = this.renderer.listen(this.input.nativeElement, 'blur', () => {
            this.isFocused = false;
        });
    }

    ngOnDestroy(): void {
        this.focusListener();
        this.blurListener();
        this.removeFromOverlay();
    }

    ngOnChanges(changes: SimpleChanges): void {
        if (changes['promotedTags']) {
            if (this.promotedTags.length > 0 && !this.openedInOverlay) {
                this.openInOverlay();
            }
        }
    }

    @HostListener('keydown', ['$event'])
    onKeydown(event): void {
        const { selectionStart: start, selectionEnd: end } = event.target;
        switch (event.keyCode) {
            case KEYBOARD.ENTER:
                event.preventDefault();
                if (this.promotedTags && this.promotedTags[this.index]) {
                    this.add(this.promotedTags[this.index]);
                } else if (this.acceptNewTags && this.searchTerm) {
                    const tag: Tag = new Tag({ label: this.searchTerm, value: this.searchTerm });
                    this.add(tag);
                }
                break;
            case KEYBOARD.DOWN_ARROW:
                event.preventDefault();
                this.moveIndex(Direction.DOWN);
                break;
            case KEYBOARD.UP_ARROW:
                event.preventDefault();
                this.moveIndex(Direction.UP);
                break;
            case KEYBOARD.BACKSPACE:
            case KEYBOARD.DELETE:
                const focusedTag = this._elementRef.nativeElement.querySelector('.cui-tag:focus');
                if (focusedTag) {
                    event.preventDefault();
                    this.selectedTags.splice(DOMHelper.getNodeIndex(focusedTag), 1);
                    Promise.resolve().then(() => {
                        this.input.nativeElement.focus();
                    });
                } else if (start === end && start === 0 && this._elementRef.nativeElement.querySelectorAll('.cui-tag').length) {
                    this._elementRef.nativeElement.querySelectorAll('.cui-tag')
                    [this._elementRef.nativeElement.querySelectorAll('.cui-tag').length - 1].focus();
                }
                break;
            case KEYBOARD.COMMA:
            case KEYBOARD.SEMICOLON:
                if (this.acceptNewTags && this.searchTerm) {
                    event.preventDefault();
                    const tag: Tag = new Tag({ label: this.searchTerm, value: this.searchTerm });
                    this.add(tag);
                }
                break;
        }
    }

    @HostListener('input', ['$event'])
    onInput(event): void {
        this.searchTerm = event.target.value;
        const tempCanvas = document.createElement('canvas');
        const textLength: number = DOMHelper.getTextWidth(tempCanvas, this.searchTerm);
        const input = this._elementRef.nativeElement.querySelector('.input').getBoundingClientRect();
        this.overlayElement.nativeElement.style.left = `${input.left + textLength + 5}px`;
        this.overlayElement.nativeElement.style.top = `${input.top}px`;
        this.onSearch.emit(event.target.value);
        this.index = 0;
    }

    moveIndex(direction: Direction): void {
        switch (direction) {
            case Direction.DOWN:
                if (this.promotedTags[this.index + 1]) {
                    this.index += 1;
                } else {
                    // Unless there is a next one: start over
                    this.index = 0;
                }
                break;
            case Direction.UP:
                if (this.promotedTags[this.index - 1]) {
                    this.index -= 1;
                } else {
                    // Unless there is a previous one: start from the end
                    this.index = this.promotedTags.length - 1;
                }
                break;
        }
    }

    /**
     * Used from the view to set index on hover
     * @param {number} index
     */
    setIndex(index: number): void {
        this.index = index;
    }

    /**
     * Emit onRemove with removed tag unless readonly is set to true
     * @param {Tag} tag
     */
    remove(tag: Tag): void {
        if (!this.readonly) {
            this.onRemove.emit(tag);
        }
    }

    /**
     * Checks for duplicates and limit before emiting an event according to spec
     * @param {Tag} tag
     * @param {MouseEvent} event
     */
    add(tag: Tag, event?: MouseEvent): void {
        const isDuplicate = this.selectedTags.find(selectedTag => selectedTag.value === tag.value);
        if (!isDuplicate && !this.isReadOnlyOrFull && !this.readonly) {
            this.onAdd.emit(tag);
        }
        this.searchTerm = '';
        this.onSearch.emit('');
        this.removeFromOverlay();
        if (event) {
            event.stopPropagation();
        }
    }

    removeFromOverlay(): void {
        if (this.overlayElement && this.openedInOverlay) {
            this.overlayHelperService.removeFromOverlay(this);
        }
        this.deleteBackdrop();
    }

    openInOverlay(): void {
        this.createBackdrop();
        this.overlayHelperService.appendToOverlay(this, OVERLAY_CONTEXT.ROOT);
    }

    /**
     * Creates a backdrop unless there is one already
     */
    createBackdrop(): void {
        if (!this.backdrop) {
            this.backdrop = this._backdropService.create(false);
            this.backdrop.instance.onClose.subscribe(() => {
                this.onSearch.emit('');
                this.removeFromOverlay();
            });
        }
    }

    /**
     * Deletes the backdrop if there is one
     */
    deleteBackdrop(): void {
        if (this.backdrop) {
            this.backdrop.instance.onClose.unsubscribe();
            this._backdropService.remove(this.backdrop);
            this.backdrop = null;
        }
    }

    setOverlayPosition(): void {
        const input = this._elementRef.nativeElement.querySelector('.input').getBoundingClientRect();
        if (!this.overlayElement.nativeElement.classList.contains('overlay-this')) {
            this.renderer.addClass(
                this.overlayElement.nativeElement,
                'overlay-this'
            );
        }

        const scrollArea = DOMHelper.closestParent(this.elementRef.nativeElement, 'scroll-area');
        const windowHeight = document.body.offsetHeight;
        const documentWidth = Math.max(document.body.scrollWidth, document.body.offsetWidth,
            document.documentElement.clientWidth, document.documentElement.scrollWidth,
            document.documentElement.offsetWidth);

        let newTop;
        this.overlayElement.nativeElement.style.top = `${input.top}px`;
        let overlayRect = this.overlayElement.nativeElement.getBoundingClientRect();
        if (!scrollArea) {
            // if the overlay is too far down
            if (overlayRect.bottom > windowHeight && input.top <= windowHeight) {
                newTop = overlayRect.top - (overlayRect.bottom - windowHeight + 20);
                this.overlayElement.nativeElement.style.top = `${newTop}px`;
            }
        } else {
            // to high up in scrollarea?
            if (overlayRect.top < scrollArea.getBoundingClientRect().top &&
                DOMHelper.checkInView(scrollArea, this.elementRef.nativeElement)) {
                newTop = scrollArea.getBoundingClientRect().top;
                this.overlayElement.nativeElement.style.top = `${newTop}px`;
                this.overlayElement.nativeElement.style.display = 'block';
            } else if (!DOMHelper.checkInView(scrollArea, this.elementRef.nativeElement)) {
                this.overlayElement.nativeElement.style.display = 'none';
            }
            // to far down in scrollarea?
            overlayRect = this.overlayElement.nativeElement.getBoundingClientRect();
            if (overlayRect.bottom > scrollArea.getBoundingClientRect().bottom &&
                DOMHelper.checkInView(scrollArea, this.elementRef.nativeElement)) {
                newTop = scrollArea.getBoundingClientRect().bottom - overlayRect.height;
                this.overlayElement.nativeElement.style.top = `${newTop}px`;
            }
        }

        // if the overlay is too far to the right
        const tempCanvas = document.createElement('canvas');
        const textLength: number = DOMHelper.getTextWidth(tempCanvas, this.searchTerm);
        this.overlayElement.nativeElement.style.left =
            `${input.left + textLength + 5}px`;
        setTimeout(() => {
            overlayRect = this.overlayElement.nativeElement.getBoundingClientRect();
            if (overlayRect.right > documentWidth) {
                const newLeft = overlayRect.left - (overlayRect.right - documentWidth + 20);
                this.overlayElement.nativeElement.style.left = `${newLeft}px`;
            }
        });
    }
}
