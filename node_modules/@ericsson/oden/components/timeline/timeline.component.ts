import { Component, HostBinding, Input, OnChanges, OnInit, ViewEncapsulation } from '@angular/core';

import { EntityVersion } from '../../core/models';
import * as moment from 'moment';
import { ORDER } from '../../core/constants/order.constants';
import { TIME } from '../../core/constants/date.constants';
import { OrderHelper } from '../../core/helpers/order.helper';
import { VersionsService } from '../../core/services/versions.service';
const momentInstance = (typeof moment === 'object') ? (<any>moment).default : moment;

@Component({
    selector: 'cui-timeline',
    templateUrl: 'timeline.component.html',
    styleUrls: ['timeline.component.scss'],
    encapsulation: ViewEncapsulation.None
})
export class TimelineComponent implements OnChanges, OnInit {
    @HostBinding('class.cui-timeline') addClass: boolean = true;

    planned: EntityVersion[] = [];
    valid: EntityVersion[] = [];
    previous: EntityVersion[] = [];
    maxItems = 3;
    currentValue = 0;

    @Input() versions: EntityVersion[] = [];

    constructor(private _versionsService: VersionsService) { }

    ngOnInit(): void {
        this.sortEntities();
    }

    ngOnChanges(): void {
        this.sortEntities();
        this.currentValue = 0;
    }

    getFormattedDate(date: Date): string {
        return this._versionsService.entityDateToString(date);
    }

    getAdditionalItems(array: Array<EntityVersion>): number {
        return Math.max(0, array.length - this.maxItems);
    }

    getMax(array: Array<EntityVersion>): EntityVersion[] {
        return array.slice(0, this.maxItems);
    }

    sortEntities(): void {
        if (this.versions) {
            this.planned = [];
            this.previous = [];
            this.valid = [];
            OrderHelper.orderByDate(this.versions, 'validFrom', ORDER.DESCENDING);
            this.versions.forEach((version: EntityVersion) => {
                const now = momentInstance();
                const from = momentInstance(version.validFrom);
                const to = momentInstance(version.validTo);
                if (to.isBefore(now, 'day') && version.validTo !== TIME.END_OF_TIME) {
                    this.previous.push(version);
                } else if (from.isAfter(now, 'day') && (to.isAfter(now, 'day') || version.validTo === TIME.END_OF_TIME)) {
                    this.planned.push(version);
                } else if ((!from.isAfter(now, 'day') || version.validFrom === TIME.BEGINNING_OF_TIME )
                    && (to.isAfter(now, 'day') || version.validTo === TIME.END_OF_TIME)) {
                    this.valid.push(version);
                }
            });
        }
    }
}
