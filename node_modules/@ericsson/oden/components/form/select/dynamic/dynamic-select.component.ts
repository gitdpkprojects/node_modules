/* tslint:disable:directive-selector-name */
import {
    AfterViewInit,
    Component,
    ComponentRef,
    ElementRef,
    EventEmitter,
    forwardRef,
    HostBinding, HostListener,
    Input,
    OnChanges,
    OnDestroy,
    OnInit,
    Output,
    QueryList,
    Renderer2,
    SimpleChanges,
    ViewChild,
    ViewChildren,
    ViewEncapsulation
} from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';
import * as _ from 'lodash';
import { OverlayHelperService } from '../../../overlay/overlay-helper.service';
import { IOverlayable } from '../../../overlay/overlayable.interface';
import { SelectService } from '../select.service';
import { KeyboardAccessibility } from '../../../../core/classes/keyboard-accessibility';
import { BackdropComponent } from '../../../backdrop/backdrop.component';
import { DOMHelper } from '../../../../core/helpers/dom.helper';
import { OptionComponent } from '../option/option.component';
import { OptionItem } from '../../../../core/models/option-item.model';
import { KEYBOARD } from '../../../../core/constants/keyboard.constants';
import { ArrayHelper } from '../../../../core/helpers/array.helper';
import { OVERLAY_CONTEXT } from '../../../overlay/overlay.constants';
import { BackdropService } from '../../../backdrop';

@Component({
    selector: 'cui-dynamic-select',
    templateUrl: './dynamic-select.component.html',
    providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => DynamicSelectComponent),
        multi: true
    }, SelectService],
    styleUrls: ['./dynamic-select.component.scss'],
    encapsulation: ViewEncapsulation.None
})

export class DynamicSelectComponent extends KeyboardAccessibility implements OnDestroy,
    AfterViewInit,
    ControlValueAccessor,
    IOverlayable, OnChanges, OnInit {
    renderer: Renderer2;
    public elementRef: ElementRef;
    public overlayHelperService: OverlayHelperService;
    openedInOverlay: boolean = false;
    backdrop: ComponentRef<BackdropComponent>;
    globalListener: Function;
    keydownListener: Function;
    filterListener: Function;
    tabListener: Function;
    useOverlay: boolean = true;
    visible: boolean = false;
    filterValue: string = '';
    isPlaceHolder: boolean = false;
    selectableQuerySelector = 'cui-option';
    filterWarningHeading: string;
    filterWarningMessage: string;
    displayComboData: Array<OptionItem> = [];
    addButtonDisabled: boolean = true;

    private onResizeBind: EventListener = this.resizeDropDown.bind(this);
    private _addButton: HTMLElement;
    private _filterField: HTMLElement;
    private _dataProvider: Array<OptionItem> = [];
    // The internal data model
    private _value: any = null;
    // The previouly selected value
    private _previousValue: any = null;

    @Input() multiple: boolean = true;
    @Input() placeholder: string = '';
    @Input() filterPlaceholder: string;
    @Input() width: string = '100%';
    @Input() ngModel: any;
    @Input() deletable: boolean = false;
    @Input() addable: boolean = false;
    @Input() filterable?: boolean = true;
    @Input() set dataProvider(v: Array<OptionItem>)  {
        this._dataProvider = _.cloneDeep(v);
    }
    get dataProvider()  {
        return this._dataProvider;
    }

    /**
     * Getter and setter for _value
     */
    get value(): any {
        return this._value;
    }

    // set accessor including call the onchange callback
    @Input() set value(v: any) {
        if (!_.isEqual(v, this._value)) {
            this._value = v;
            this.isPlaceHolder = this.getSelectedOptions().length < 1;
        }
    }

    @HostBinding('class.cui-dynamic-select') addClass: boolean = true;
    @HostBinding('class.disabled') @Input() disabled: boolean = false;
    @HostBinding('tabindex') tabIndex: number = 0;

    @Output() onFilterChanged: EventEmitter<string> = new EventEmitter<string>();
    @Output() onAddItem: EventEmitter<any> = new EventEmitter<any>();
    @Output() onDeleteItem: EventEmitter<any> = new EventEmitter<any>();
    @Output() onChange: EventEmitter<any> = new EventEmitter<any>();
    @Output() onClose: EventEmitter<any> = new EventEmitter<any>();

    @ViewChild('dropdownContent') overlayElement: ElementRef;
    @ViewChildren(OptionComponent) options: QueryList<OptionComponent> = new QueryList<OptionComponent>();

    // Placeholders for the callbacks
    private _onTouchedCallback: (_: any) => void = () =>  {};
    private _onChangeCallback: (_: any) => void = () => {};

    constructor(
        public selectService: SelectService,
        renderer: Renderer2,
                elementRef: ElementRef,
                overlayHelperService: OverlayHelperService,
                private _backdropService: BackdropService
                ) {
        super(renderer, elementRef);
        this.elementRef = elementRef;
        this.overlayHelperService = overlayHelperService;
    }

    ngOnInit(): void {
        this.displayComboData = _.cloneDeep(this._dataProvider);
        this.selectService.multiple = this.multiple;
    }

    ngOnDestroy(): void {
        window.removeEventListener('resize', this.onResizeBind);
        this.removeFromOverlay();
    }

    ngOnChanges(changes: SimpleChanges): void {
        if (changes['ngModel'] || changes['dataProvider']) {
            if (changes['ngModel'] && !changes['ngModel'].firstChange && !_.isEqual(this._previousValue, changes['ngModel'].currentValue)) {
                this.value = changes['ngModel'].currentValue;
                this._onChangeCallback(changes['ngModel'].currentValue);
            }
            if (changes['ngModel']) {
                this._previousValue = changes['ngModel'].currentValue;
            }

            Promise.resolve().then(() => {
                this.setOptionsAndData();
                this.setWidth();
                this.setFilteredDisplayData();
                this.setWarningMessage();
            });
        }
    }

    @HostListener('focus')
    addActive(): void {
        if (!this.visible) {
            this.selectRadioElement();
        }
    }

    /**
     * Check if we're inside a radiobutton's label, if so then make the radio button active
     * Click it per default, otherwise we add some css classes (this happens one time, in afterviewinit)
     * @param {Boolean} click
     */
    selectRadioElement(click: Boolean = true): void {
        const radios_label = DOMHelper.closestParentTag(this.elementRef.nativeElement, 'label');
        if (radios_label) {
            let radio = <HTMLInputElement> document.getElementById(radios_label.getAttribute('for'));
            // "click" the radio (setting checked = true won't update models)
            if (!radio) {
                // find radio by checking previous sibling in DOM tree
                const previousElement = radios_label.previousElementSibling;
                if (previousElement && previousElement.classList.contains('cui-radio')) {
                    radio = previousElement;
                }
            }
            if (radio && radio.classList.contains('cui-radio')) {
                if (click) {
                    radio.click();
                } else {
                    this.renderer.addClass(this.elementRef.nativeElement, 'next-to-radio');
                    this.renderer.addClass(radios_label, 'next-to-select');
                }
            }
        }
    }


    /**
     * Call this function after you have set the elementRef and overlayElement
     */
    openInOverlay(): void {
        this.createBackdrop();
        this.overlayHelperService.appendToOverlay(this, OVERLAY_CONTEXT.ROOT);
    }

    /**
     * Sets selected data from ngModel
     */
    setOptionsAndData(): void {
        if (this.ngModel && this.options.length > 0) {
            if (this.multiple) {
                this.options.forEach((o) => {
                    o.selected = false;
                    if (o.data.selected !== undefined) {
                        o.data.selected = false;
                    }
                });
                this._dataProvider.forEach((opt) => {
                    opt.selected = false;
                });
                this.ngModel.forEach((_item) => {
                    if (_item.selected !== undefined) {
                        _item.selected = true;
                    }
                    this.options.forEach((opt) => {
                        if (opt.id === _item.id && !opt.disabled) {
                            opt.selected = true;
                        }
                    });
                    this._dataProvider.forEach((opt) => {
                        if (opt.id === _item.id) {
                            opt.selected = true;
                        }
                    });
                });
            } else {
                this.options.forEach((o) => {
                    if (!o.disabled) {
                        o.selected = o.data.id === this.ngModel.id;
                        if (o.data.selected !== undefined) {
                            o.data.selected = o.selected;
                        }
                    }
                });
                this._dataProvider.forEach((opt) => {
                    opt.selected = opt.id === this.ngModel.id;
                    if (opt.selected && this.ngModel.selected !== undefined) {
                        this.ngModel.selected = true;
                    }
                });
            }
        }
        this.isPlaceHolder = this.getSelectedOptions().length < 1;
    }

    /**
     * Removes overlay from the DOM
     */
    removeFromOverlay(): void {
        // unlisten the keydownListener
        if (typeof(this.keydownListener) !== 'undefined') {
            this.keydownListener();
        }
        // unlisten the filterListener
        if (typeof(this.filterListener) !== 'undefined') {
            this.filterListener();
        }
        // unlisten the tabListener
        if (typeof(this.tabListener) !== 'undefined') {
            this.tabListener();
        }
        if (this.overlayElement && this.openedInOverlay) {
            this.overlayHelperService.removeFromOverlay(this);
        }
        this.deleteBackdrop();
    }


    /**
     * Overrides KeyboardAccessibility.
     * @param event
     */
    triggerTab(event): void {
        if (this.visible) {
            if (!event.shiftKey) {
                this.closeDropdown();
            } else if (this.filterable || this.addable) {
                setTimeout(() => {
                    if (this.addable && !this.addButtonDisabled) {
                        this._addButton.focus();
                    } else {
                        this._filterField.focus();
                    }
                }, 1);
            }
        }
    }
    /**
     * Overrides KeyboardAccessibility
     * @returns {boolean}
     */
    canNavigate(): boolean {
        return this.visible;
    }

    /**
     * Overrides KeyboardAccessibility
     * @returns {ElementRef}
     */
    getSelectableItemContainer(): ElementRef {
        return this.overlayElement;
    }

    /**
     * Overrides KeyboardAccessibility
     */
    openContextMenu() {
        this.openDropdown();
    }

    /**
     * Overrides KeyboardAccessibility
     */
    closeContextMenu() {
        this.closeDropdown();
    }

    /**
     * Is called when we leave the dropdown overlay
     */
    onBlur(): void {
        this._onTouchedCallback(null);
        this.overlayElement.nativeElement.style.bottom = 'auto';
        this.overlayElement.nativeElement.style.right = 'auto';
        this.removeFromOverlay();
    }

    /**
     * ControlValueAccessor implentations
     * This function is only to be called via NG_VALUE_ACCESSOR
     */
    writeValue(value: any): void {
        this._value = value;
    }

    /**
     * ControlValueAccessor implentations
     * This function is only to be called via NG_VALUE_ACCESSOR
     */
    registerOnChange(fn: any): void {
        this._onChangeCallback = fn;
    }

    /**
     * ControlValueAccessor implentations
     * This function is only to be called via NG_VALUE_ACCESSOR
     */
    registerOnTouched(fn: any): void {
        this._onTouchedCallback = fn;
    }

    /**
     * OnInit implementation
     */
    ngAfterViewInit(): void {
        super.ngAfterViewInit();
        this.selectService.setOrigin(this.elementRef.nativeElement);
        this.selectRadioElement(false);
        this.setWidth();
        Promise.resolve().then(() => {
            this.setWarningMessage();
        });
    }

    /**
     * Figure out the longest string (placeholder included) and set the .cui-select width equal to it
     * (unless a static width has been set)
     */
    setWidth(): void {
        // are we inside .with-post-field-text or a List Controller, then width should be dynamic to content
        const inWithPostFieldText = DOMHelper.closestParent(this.elementRef.nativeElement, 'with-post-field-text');
        const inListController = DOMHelper.closestParent(this.elementRef.nativeElement, 'cui-list-controller-component')
            && this.elementRef.nativeElement.previousElementSibling
            && this.elementRef.nativeElement.previousElementSibling.classList.contains('left');
        let selectWidth: string;
        if (this.width && !inWithPostFieldText && !inListController) {
            selectWidth = this.width.indexOf('%') > 0 ? this.width : parseInt(this.width, 10) + 'px';
        } else {
            const tempCanvas = document.createElement('canvas');
            let biggestLength: number = this.getDefaultTextLength(tempCanvas);
            this._dataProvider.forEach((o) => {
                const textwidth = DOMHelper.getTextWidth(tempCanvas, o.label);
                biggestLength = textwidth > biggestLength ? textwidth : biggestLength;
            });
            // (32px is the left+right padding on .dynamic-dropdown-content li > span. double it if multiple is true,
            // because of checkbox that takes space)
            let padding = this.multiple ? 64 : 32;
            padding += this.deletable ? 24 : 0;
            biggestLength = biggestLength > (100 - padding) ? biggestLength + padding : 100;
            selectWidth = biggestLength + 'px';
        }
        this.elementRef.nativeElement.style.width = selectWidth;
        if (!this.visible) {
            this.resizeDropDown();
        }
    }

    /**
     * Returns text length (in pixels) of a select components default value
     * @param canvas
     * @returns {number}
     * @private
     */
    getDefaultTextLength(canvas): number {
        return this.multiple ? DOMHelper.getTextWidth(canvas, this.getMultipleDisplayValue()) :
            DOMHelper.getTextWidth(canvas, this.getSingleDisplayValue());
    }

    /**
     * For Selects with Muliple=true
     * get the display value for the select items, or the placeholder
     * @returns {string}
     */
    getMultipleDisplayValue(): string {
        const selectedOptions = this.getSelectedOptions();
        if (selectedOptions.length > 0) {
            return (selectedOptions.map((o) => o['label'])).join(', ');
        } else {
            return this.placeholder;
        }
    }

    /**
     * For Selects with Muliple=false
     * get the display value for the select item, or the placeholder
     * @returns {string}
     */
    getSingleDisplayValue(): string {
        const selectedOption = this.getSelectedOption();
        return selectedOption ? selectedOption.label : this.placeholder;
    }

    /**
     * Gets the value that should be displayed in the view
     * depending on value of bool multiple
     * @return string
     */
    getDisplayValue(): string {
        if (this.multiple) {
            return this.getMultipleDisplayValue();
        } else {
            return this.getSingleDisplayValue();
        }
    }

    /**
     * For Selects with Muliple=false
     * get the selected option
     * @return OptionItem
     */
    getSelectedOption(): OptionItem {
        return this._dataProvider.filter((o) => o.selected)[0];
    }

    /**
     * For Selects with Muliple=true
     * get the selected options
     * @return Array<any>
     */
    getSelectedOptions(): Array<any> {
        return this._dataProvider.filter((o) => o.selected);
    }

    /**
     * For Selects
     * selects this option
     * @param option
     */
    onSelectingItem(option: OptionComponent): void {
        if (this.multiple) {
            this.selectMultipleOption(option);
        } else {
            this.selectSingleOption(option);
        }
        // to compare value to previous value to make form controls to dirty/ not dirty
        if (this._previousValue !== this.value) {
            this.onChange.emit(this.value);
            this._previousValue = this.value;
            this._onChangeCallback(this.value);
        }
    }

    /**
     * For Selects with Muliple=true
     * selects this option, then sets value
     * @param option
     */
    selectMultipleOption(option: OptionComponent): void {
        option.selected = !option.selected;
        this._dataProvider.filter((d) => {
            return d.id === option.id;
        }).forEach((d) => d.selected = option.selected);
        this.value = this.getSelectedOptions().map((o) => o);
    }

    /**
     * For Selects with Muliple=false
     * selects this option
     * @param option
     */
    selectSingleOption(option: OptionComponent): void {
        this.options.forEach((o) => o.selected = false);
        this._dataProvider.forEach((d) => {
            d.selected = false;
        });
        this.options.filter((o) => o.id === option.id).forEach((o) => o.selected = true);
        option.selected = true;
        this._dataProvider.filter((d) => {
            return d.id === option.id;
        }).forEach((d) => {
            d.selected = true;
            this.value = d;
        });
    }

    /**
     * Toggles the visibility of the dropdown/select overlay
     */
    toggleDropdown() {
        if (this.disabled) {
            return;
        }
        if (!this.visible) {
            this.openDropdown();
        } else {
            this.closeDropdown();
        }
    }

    closeDropdown() {
        window.removeEventListener('resize', this.onResizeBind);
        this.visible = false;
        this.addButtonDisabled = true;
        this.filterValue = '';
        // If the select dropdown never was opened, do not attempt to unbind
        if (typeof(this.globalListener) !== 'undefined') {
            this.globalListener();
        }
        this.contextMenuClosed();
        this.onBlur();
        setTimeout(() => {
            this.elementRef.nativeElement.focus();
        }, 100);
        this.deleteBackdrop();
        this.onClose.emit(this.value);
    }

    openDropdown() {
        window.addEventListener('resize', this.onResizeBind);
        this.selectRadioElement();
        this.displayComboData = _.cloneDeep(this._dataProvider);
        this.contextMenuOpened();
        this.setWidth();
        this.visible = true;
        setTimeout(() => {
            this._setClickListener();
        }, 1);
        if (this.useOverlay) {
            this.createBackdrop();
            this.overlayHelperService.appendToOverlay(this, OVERLAY_CONTEXT.ROOT);
        }
        if (this.filterable || this.addable) {
            setTimeout(() => {
                this._filterField = this.overlayElement.nativeElement.querySelector('.filter-container input');
                this._filterField.focus();
                this.keydownListener = this.renderer.listen('document', 'keydown', (event: KeyboardEvent) => {
                    if (event.keyCode === KEYBOARD.ESCAPE) {
                        this.closeDropdown();
                    }
                });
                if (this.addable) {
                    this._addButton = this.overlayElement.nativeElement.querySelector('.filter-container .cui-button');
                    this.filterListener = this.renderer.listen(this._filterField, 'keydown', (event: KeyboardEvent) => {
                        if (event.keyCode === KEYBOARD.ENTER && !this.addButtonDisabled) {
                            this.addItem();
                        }
                    });
                }
                this.tabListener = this.renderer.listen(this.overlayElement.nativeElement, 'keydown', (event: KeyboardEvent) => {
                    if (this.visible && event.keyCode === KEYBOARD.TAB) {
                        if (this.displayComboData.length > 0 && !event.shiftKey &&
                            ((this.addable && (<HTMLElement>event.target) === this._addButton) || this.addButtonDisabled)) {
                            // Sets focus on select component in order to make it work with the KeyboardAccessibility keydown listeners
                            this.elementRef.nativeElement.focus();
                            this.setElementIndex(-1);
                            this.changeIndex(event, true);
                            const selectedElement = this.getSelectedElement();
                            if (selectedElement) {
                                selectedElement.focus();
                            }
                        } else if ((!event.shiftKey && !this.addable && (<HTMLElement>event.target) === this._filterField &&
                            this.displayComboData.length < 1) ||
                            (!event.shiftKey && this.addable && (<HTMLElement>event.target) === this._addButton &&
                            this.displayComboData.length < 1) ||
                            (event.shiftKey && (<HTMLElement>event.target) === this._filterField)) {
                            this.closeDropdown();
                        }
                    }
                });
            }, 100);
        }
    }

    /**
     * Make the dropdown overlay as wide as the select box.
     */
    resizeDropDown(): void {
        const dropDownContent = this.overlayElement.nativeElement;
        if (dropDownContent) {
            dropDownContent.style.width = DOMHelper.getOuterWidth(this.elementRef.nativeElement) + 'px';
        }
    }

    /**
     * If we click anywhere but in the select box we close it
     * (unless it's non-multiple, then we always close on click)
     */
    private _setClickListener(): void {
        this.globalListener = this.renderer.listen('document', 'click', (event) => {
            if (!event.target.classList.contains('clear')) {
                const clickInsideDropdown = DOMHelper.closestParent(event.target, 'dropdown-option');
                const clickFilterContainer = DOMHelper.closestParent(event.target, 'filter-container');
                if (this.visible && !event.target.classList.contains('disabled')
                    && ((!this.multiple && !clickFilterContainer)
                    || (this.multiple && !clickInsideDropdown && !clickFilterContainer))) {
                    this.closeDropdown();
                }
            }
        });
    }

    /**
     * Sends the filter: string to the onFilterChange callback and setFilteredDisplayData
     * @param filter
     */
     filterKey(filter: string): void {
         this.onFilterChanged.emit(filter);
         if (filter.trim() !== '' && this.addable) {
            this.addButtonDisabled = this._dataProvider.some((obj) => obj.label.toLowerCase() === this.filterValue.toLowerCase());
         } else {
            this.addButtonDisabled = true;
         }
         this.filterValue = filter;
         this.setFilteredDisplayData();
     }

    /**
     * Functions for filtering
     */
     setFilteredDisplayData(): void {
        if (this.filterValue === undefined || this.filterValue === '') {
            this.displayComboData = this._dataProvider;
            return;
        }
        this.displayComboData = ArrayHelper
            .filterOnKeys(this._dataProvider, this.filterValue, ['label'])
            .map((d) => {
                if (this.filterValue === undefined || this.filterValue === '') {
                    return d;
                }
                return {
                    ...d,
                    label: DOMHelper.highlightString(this.filterValue, d.label),
                };
            });
     }

    /**
     * When Add button is clicked, the onAddItem event will be emit
     */
     addItem(): void {
         if (this.filterValue.trim() !== '') {
             this.addButtonDisabled = true;
             if (!this.displayComboData.some((obj) => obj.label.toLowerCase() === this.filterValue.toLowerCase())) {
                 const newItem = new OptionItem({ label: this.filterValue, selected: true });
                 this.onAddItem.emit(newItem);
                 this.displayComboData = this._dataProvider;
                 this.displayComboData.splice(0, 0, newItem);
                 this._dataProvider = this.displayComboData;
                 if (this.multiple) {
                     this.value = this.getSelectedOptions().map((o) => o);
                 } else {
                     this._dataProvider.forEach((d) => {
                         d.selected = false;
                     });
                     this._dataProvider.filter((d) => {
                         return d.id === newItem.id;
                     }).forEach((d) => {
                         d.selected = true;
                         this.value = d;
                     });
                 }
                 this.setWidth();
                 this.resizeDropDown();
             }
             this.filterValue = '';
             this._filterField.focus();
         }
     }

    /**
     * Functions to delete selected item from dropdown list
     * @param option: OptionComponent
     */
    onDeleteingItem(option: OptionComponent): void {
        const itemIndex = _.findIndex(this._dataProvider, ['id', option.data['id']]);
         if (itemIndex !== -1) {
             const itemToDelete = this._dataProvider[itemIndex];
             this.onDeleteItem.emit(_.cloneDeep(itemToDelete));
             this._dataProvider.splice(itemIndex, 1);
             this.displayComboData = this._dataProvider;
             if (this.multiple) {
                 this.value = this.getSelectedOptions().map((o) => o);
             } else {
                 this.value = this.getSelectedOption();
             }
         }
        // to compare value to previous value to make form controls to dirty/ not dirty
        if (this._previousValue !== this.value) {
            this._onChangeCallback(this.value);
            this._previousValue = this.value;
        }
     }

     /**
     * Sets the default warning messsages for filters.
     */
     setWarningMessage() {
         if (this.filterable && !this.addable) {
            this.filterWarningMessage = this.selectService.filterMessage;
            this.filterWarningHeading = this.selectService.noMatchMessage;
        } else if (this.addable) {
            this.filterWarningMessage = this.selectService.dynamicMessage;
            this.filterWarningHeading = this.selectService.noMatchMessage;
        } else {
            this.filterWarningMessage = '';
            this.filterWarningHeading = this.selectService.noDataMessage;
        }
     }

    /**
     * Creates a backdrop unless there is one already
     */
    createBackdrop(): void {
        if (!this.backdrop) {
            this.backdrop = this._backdropService.create(false);
            this.backdrop.instance.onClose.subscribe(() => this.closeDropdown());
        }
    }

    /**
     * Deletes the backdrop if there is one
     */
    deleteBackdrop(): void {
        if (this.backdrop) {
            this.backdrop.instance.onClose.unsubscribe();
            this._backdropService.remove(this.backdrop);
            this.backdrop = null;
        }
    }
}
