import {
    AfterViewInit,
    Component,
    ComponentRef,
    ContentChildren,
    ElementRef,
    EventEmitter,
    forwardRef,
    HostBinding,
    HostListener,
    Input,
    OnChanges,
    OnDestroy,
    OnInit,
    Output,
    QueryList,
    Renderer2,
    SimpleChanges,
    ViewChild,
    ViewEncapsulation
} from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';
import { TranslateService } from '@ngx-translate/core';
import * as _ from 'lodash';
import { Subscription } from 'rxjs/Subscription';

import { UnSub } from '../../../core/classes';
import { KeyboardAccessibility } from '../../../core/classes/keyboard-accessibility';
import { KEYBOARD } from '../../../core/constants/keyboard.constants';
import { DOMHelper } from '../../../core/helpers/dom.helper';
import { OptionItem } from '../../../core/models/option-item.model';
import { BackdropService } from '../../backdrop';
import { BackdropComponent } from '../../backdrop/backdrop.component';
import { OverlayHelperService, OverlayService } from '../../overlay';
import { OVERLAY_CONTEXT } from '../../overlay/overlay.constants';
import { IOverlayable } from '../../overlay/overlayable.interface';
import { OptionComponent } from './option/option.component';
import { SelectService } from './select.service';

/* tslint:disable:directive-selector */

@Component({
    selector: 'cui-select',
    templateUrl: 'select.component.html',
    providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => SelectComponent),
        multi: true
    }, SelectService],
    styleUrls: ['select.component.scss'],
    encapsulation: ViewEncapsulation.None
})
@UnSub()
export class SelectComponent extends KeyboardAccessibility implements OnDestroy,
    AfterViewInit,
    ControlValueAccessor,
    IOverlayable, OnChanges, OnInit {
    renderer: Renderer2;
    public elementRef: ElementRef;
    public overlayHelperService: OverlayHelperService;
    openedInOverlay: boolean = false;
    backdrop: ComponentRef<BackdropComponent>;
    globalListener: Function;
    keydownListener: Function;
    private onResizeBind: EventListener = this.resizeDropDown.bind(this);
    private _subscriptions: Array<Subscription> = [];
    noneOptionItem: OptionItem = new OptionItem();
    @Input() noneLabel: string;
    @Input() placeholder: string = '';
    @Input() width: string = '100%';
    @Input() ngModel: any;
    @Input() multiple: boolean = false;
    @Input() showNoneIfNull: boolean = false;
    @Input() selectAll: boolean = false;
    @HostBinding('tabindex') tabIndex: number = 0;
    @HostBinding('class.cui-select') addClass: boolean = true;
    @HostBinding('class.auto-width') get hasAutoWidth(): boolean {
        return this.width === 'auto';
    }
    @HostBinding('class.disabled') @Input() disabled: boolean = false;
    @HostBinding('attr.required') @Input() required: boolean = false;
    @Output() onChange: EventEmitter<any> = new EventEmitter<any>();
    @Output() onSetValue: EventEmitter<any> = new EventEmitter<any>();
    @Output() onClose: EventEmitter<any> = new EventEmitter<any>();

    @ViewChild('dropdownContent') overlayElement: ElementRef;

    @HostBinding('class.open') visible: boolean = false;

    @ContentChildren(forwardRef(() => OptionComponent))
    options: QueryList<OptionComponent>;

    isPlaceHolder: boolean = false;
    displayValue: string = '';

    selectableQuerySelector = 'cui-option';
    /**
     * Getter and setter for _value
     */
    get value(): any {
        return this._value;
    }

    // set accessor including call the onchange callback
    @Input() set value(v: any) {
        this.onSetValue.emit(v);
        if (!_.isEqual(v, this._value)) {
            this._value = v;
            if (!v || (v && !v.newWindow)) {
                this.onChange.emit(v);
                this.isPlaceHolder = this.getSelectedOptions().length < 1 && !this.showNoneIfNull;
            }
        }
    }
    // The internal data model
    private _value: any = null;
    // The previouly selected value
    private _previousValue: any;
    // Placeholders for the callbacks
    private _onTouchedCallback: (_: any) => void = () => { };
    private _onChangeCallback: (_: any) => void = () => { };

    constructor(public selectService: SelectService, renderer: Renderer2,
                elementRef: ElementRef,
                overlayHelperService: OverlayHelperService,
                private _overlayService: OverlayService,
                private _translate: TranslateService,
                private _backdropService: BackdropService
    ) {
        super(renderer, elementRef);
        // Get the translation string for all and reset the display values.
        _translate.stream([
            'ODEN.COMMON.ALL'
        ]).subscribe(() => {
            this.displayValue = this.getDisplayValue();
        });

        this.overlayHelperService = overlayHelperService;
        this.elementRef = elementRef;
        selectService.multiple = this.multiple;
        this._subscriptions.push(selectService.onSelect.subscribe((option) => this.selectSingleOption(option)));
        this._subscriptions.push(selectService.onMultiSelect.subscribe((option) => this.selectMultipleOption(option)));
        this._subscriptions.push(selectService.onSelectAll.subscribe(() => {
            const selectedOrNot = this.options.filter((i) => !i.selectAll && !i.disabled).length !== this.ngModel.length;
            this.options.filter((i) => !i.selectAll && !i.disabled).forEach((item) => {
                item.onSelectItem.emit(item);
                item.selected = selectedOrNot;
            });
            this.options.filter((i) => !i.selectAll && !i.disabled).forEach((_option) => {
                if (typeof (_option.data) === 'object' && _option.data && _option.data.selected !== undefined) {
                    _option.data.selected = _option.selected;
                }
            });
            this.value = this.getSelectedOptions().map((o) => o.data);
            this.displayValue = this.getDisplayValue();
            // to compare value to previous value to make form controls to dirty/ not dirty
            if (this._previousValue !== this.value) {
                this._onChangeCallback(this.value);
                this._previousValue = this.value;
            }
        }));
        this._subscriptions.push(this._overlayService.onZIndexChange$.subscribe((zIndex) => {
            // change zindex so this is always on top if it's a hidden select in the app tab
            if (DOMHelper.closestParent(this.elementRef.nativeElement, 'cui-app-header-wrapper')) {
                this.renderer.setStyle(this.overlayElement.nativeElement, 'zIndex', zIndex + 1);
            }
        }));
    }

    ngOnDestroy(): void {
        window.removeEventListener('resize', this.onResizeBind);
        this.removeFromOverlay();
    }

    ngOnChanges(changes: SimpleChanges) {
        if (changes['ngModel'] && !_.isEqual(changes['ngModel'].currentValue, changes['ngModel'].previousValue)) {
            setTimeout(() => {
                this.setOptionsAndData();
                this.setWidth();
                if (!changes['ngModel'].firstChange && this._previousValue && this._previousValue !== this.value) {
                    this._onChangeCallback(this.value);
                }
                this._previousValue = this.value;
            }, 1);
        }
        if (changes['noneLabel']) {
            this.noneOptionItem.label = this.noneLabel;
        }
    }

    @HostListener('focus')
    addActive(): void {
        this.selectRadioElement();
    }

    /**
     * Check if we're inside a radiobutton's label, if so then make the radio button active
     * Click it per default, otherwise we add some css classes (this happens one time, in afterviewinit)
     * @param {Boolean} click
     */
    selectRadioElement(click: Boolean = true): void {
        const radios_label = DOMHelper.closestParentTag(this.elementRef.nativeElement, 'label');
        if (radios_label) {
            let radio = <HTMLInputElement>document.getElementById(radios_label.getAttribute('for'));
            // "click" the radio (setting checked = true won't update models)
            if (!radio) {
                // find radio by checking previous sibling in DOM tree
                const previousElement = radios_label.previousElementSibling;
                if (previousElement && previousElement.classList.contains('cui-radio')) {
                    radio = previousElement;
                }
            }
            if (radio && radio.classList.contains('cui-radio')) {
                if (click) {
                    radio.click();
                } else {
                    this.renderer.addClass(this.elementRef.nativeElement, 'next-to-radio');
                    this.renderer.addClass(radios_label, 'next-to-select');
                }
            }
        }
    }

    /**
     * Sets selected data from ngModel
     */
    setOptionsAndData(): void {
        if (this.options && this.options.length > 0) {
            if (this.multiple) {
                this.options.filter((i) => !i.selectAll).forEach((o) => {
                    o.selected = false;
                    if (typeof (o.data) === 'object' && o.data && o.data.selected !== undefined) {
                        o.data.selected = false;
                    }
                });
                if (!!this.ngModel) {
                    this.ngModel.filter((i) => !i.selectAll).forEach((_item) => {
                        if (typeof (_item) === 'object') {
                            if (_item.selected !== undefined) {
                                _item.selected = true;
                            }
                            this.options.forEach((opt) => {
                                if (opt.id === _item.id && !opt.disabled) {
                                    opt.selected = true;
                                }
                            });
                        } else {
                            this.options.forEach((opt) => {
                                if (opt.data === _item && !opt.disabled) {
                                    opt.selected = true;
                                }
                            });
                        }
                    });
                }
            } else {
                this.options.forEach((opt) => {
                    opt.selected = false;
                });
                if (this.ngModel === false || typeof (this.ngModel) === 'object') {
                    this.options.forEach((o) => {
                        if (!o.disabled) {
                            o.selected = !!this.ngModel && o.data && o.data.id === this.ngModel.id;
                            if (o.selected && !!this.ngModel && this.ngModel.selected !== undefined) {
                                this.ngModel.selected = true;
                            }
                            if (typeof (o.data) === 'object' && o.data && o.data.selected !== undefined) {
                                o.data.selected = o.selected;
                            }
                        }
                    });
                } else {
                    this.options.forEach((opt) => {
                        if (opt.data === this.ngModel && !opt.disabled) {
                            opt.selected = true;
                        }
                    });
                }
            }
            this.displayValue = this.getDisplayValue();
        }
        if (this.displayValue === '') {
            this.displayValue = this.placeholder;
        }
        this.isPlaceHolder = this.getSelectedOptions().length < 1 && !this.showNoneIfNull;
    }

    /**
     * Call this when ever you want to remove the overlayElement - e.g on scroll.
     */
    removeFromOverlay(): void {
        // unlisten the keydownListener
        if (typeof (this.keydownListener) !== 'undefined') {
            this.keydownListener();
        }
        if (this.overlayElement && this.openedInOverlay) {
            this.overlayHelperService.removeFromOverlay(this);
        }
        this.deleteBackdrop();
    }

    /**
     * Call this function after you have set the elementRef and overlayElement
     */
    openInOverlay(): void {
        this.createBackdrop();
        this.overlayHelperService.appendToOverlay(this, OVERLAY_CONTEXT.ROOT);
        setTimeout(() => {
            this.keydownListener = this.renderer.listen('document', 'keydown', (event: KeyboardEvent) => {
                if (event.keyCode === KEYBOARD.ESCAPE) {
                    this.closeDropdown();
                }
            });
        }, 100);
    }

    /**
     * Overrides KeyboardAccessibility
     * @returns {boolean}
     */
    canNavigate(): boolean {
        return this.visible;
    }

    /**
     * Overrides KeyboardAccessibility
     * @returns {ElementRef}
     */
    getSelectableItemContainer(): ElementRef {
        return this.overlayElement;
    }

    /**
     * Overrides KeyboardAccessibility
     */
    openContextMenu() {
        this.openDropdown();
    }

    /**
     * Overrides KeyboardAccessibility
     */
    closeContextMenu() {
        this.closeDropdown();
    }

    /**
     * Is called when we leave the dropdown overlay
     */
    onBlur(): void {
        this._onTouchedCallback(null);
        this.overlayElement.nativeElement.style.bottom = 'auto';
        this.overlayElement.nativeElement.style.right = 'auto';
        this.removeFromOverlay();
    }

    /**
     * ControlValueAccessor implentations
     * This function is only to be called via NG_VALUE_ACCESSOR
     */
    writeValue(value: any): void {
        this._value = value;
    }

    /**
     * ControlValueAccessor implentations
     * This function is only to be called via NG_VALUE_ACCESSOR
     */
    registerOnChange(fn: any): void {
        this._onChangeCallback = fn;
    }

    /**
     * ControlValueAccessor implentations
     * This function is only to be called via NG_VALUE_ACCESSOR
     */
    registerOnTouched(fn: any): void {
        this._onTouchedCallback = fn;
    }

    ngOnInit(): void {
        this.selectService.multiple = this.multiple;
        this.displayValue = this.getDisplayValue();
        this.noneOptionItem.label = this.noneLabel;
        this.isPlaceHolder = this.getSelectedOptions().length < 1 && !this.showNoneIfNull;
    }

    ngAfterViewInit(): void {
        super.ngAfterViewInit();
        this.selectService.setOrigin(this.elementRef.nativeElement);
        this.selectRadioElement(false);
        this.setWidth();
        setTimeout(() => {
            this.setOptionsAndData();
        }, 1);
        // to update the placeholder for new dataset
        this._subscriptions.push(this.options.changes.subscribe(() => {
            setTimeout(() => {
                this.setWidth();
                this.setOptionsAndData();
            }, 1);
        }));
    }

    /**
     * Figure out the longest string (placeholder included) and set the .cui-select width equal to it
     * (unless a static width has been set)
     */
    setWidth(): void {
        // are we inside .with-post-field-text, app-header or a List Controller, then width should be dynamic to content
        const inWithPostFieldText = DOMHelper.closestParent(this.elementRef.nativeElement, 'with-post-field-text');
        const inAppHeader = DOMHelper.closestParent(this.elementRef.nativeElement, 'cui-app-header');
        const inListController = DOMHelper.closestParent(this.elementRef.nativeElement, 'cui-list-controller-component')
            && this.elementRef.nativeElement.previousElementSibling
            && this.elementRef.nativeElement.previousElementSibling.classList.contains('left');
        let selectWidth: string;
        if (this.width && this.width !== 'auto' && !inWithPostFieldText && !inListController && !inAppHeader) {
            selectWidth = this.width.indexOf('%') > 0 ? this.width : parseInt(this.width, 10) + 'px';
        } else {
            const tempCanvas = document.createElement('canvas');
            let biggestLength: number = this._getDefaultTextLength(tempCanvas);
            if (this.width === 'auto') {
                const placeholderWidth = DOMHelper.getTextWidth(tempCanvas, this.displayValue);
                biggestLength = placeholderWidth > biggestLength ? placeholderWidth : biggestLength;
                biggestLength += 20;
            } else if (this.options) {
                this.options.forEach((o) => {
                    const textwidth = DOMHelper.getTextWidth(tempCanvas, o.displayValue.trim());
                    biggestLength = textwidth > biggestLength ? textwidth : biggestLength;
                });
            }
            if (this.width !== 'auto') {
                // (42px is the left+right padding on .dropdown-content li > span. double it if multiple is true,
                // because of checkbox that takes space)
                const padding = this.multiple ? 84 : 42;
                biggestLength = biggestLength > (100 - padding) ? biggestLength + padding : 100;
            }
            selectWidth = biggestLength + 'px';
        }
        this.elementRef.nativeElement.style.width = selectWidth;
        if (!this.visible) {
            this.resizeDropDown();
        }
    }

    /**
     * Returns text length (in pixels) of a select components default value
     * @param canvas
     * @returns {number}
     * @private
     */
    private _getDefaultTextLength(canvas): number {
        return this.multiple ? DOMHelper.getTextWidth(canvas, this.getMultipleDisplayValue()) :
            DOMHelper.getTextWidth(canvas, this.getSingleDisplayValue());
    }

    /**
     * Gets the value that should be displayed in the view
     * depending on value of bool multiple
     * @return string
     */
    getDisplayValue(): string {
        if (this.multiple) {
            return this.getMultipleDisplayValue();
        } else {
            return this.getSingleDisplayValue();
        }
    }

    /**
     * For Selects with Muliple=true
     * selects this option, then sets value
     * @param option
     */
    selectMultipleOption(option: OptionComponent): void {
        option.selected = !option.selected;
        this.options.filter((i) => !i.selectAll).forEach((_option) => {
            if (typeof (_option.data) === 'object' && _option.data && _option.data.selected !== undefined) {
                _option.data.selected = _option.selected;
            }
        });
        this.displayValue = this.getDisplayValue();
        this.value = this.getSelectedOptions().map((o) => o.data);
        // to compare value to previous value to make form controls to dirty/ not dirty
        if (this._previousValue !== this.value) {
            this._onChangeCallback(this.value);
            this._previousValue = this.value;
        }
    }

    /**
     * For Selects with Muliple=false
     * get the selected option
     * @return OptionComponent
     */
    getSelectedOption(): OptionComponent {
        if (!this.options) {
            return null;
        }
        return this.options.filter((o) => o.selected)[0];
    }

    /**
     * For Selects with Muliple=true
     * get the display value for the select items, or the placeholder
     * @returns {string}
     */
    getMultipleDisplayValue(): string {
        const selectedOptions = this.getSelectedOptions();
        if (this.selectAll && this.options && selectedOptions.length === this.options.filter((i) => !i.selectAll ).length) {
            return this._translate.instant('ODEN.COMMON.ALL');
        } else if (selectedOptions.length > 0) {
            return (selectedOptions.map((o) => o.displayValue.trim())).join(', ');
        } else {
            return this.placeholder;
        }
    }

    /**
     * For Selects with Muliple=false
     * selects this option
     * @param option
     */
    selectSingleOption(option: OptionComponent): void {
        this.options.forEach((o) => o.selected = false);
        if (option.displayValue === this.noneLabel) {
            this.displayValue = this.getDisplayValue();
            this.ngModel = null;
            this.value = null;
        } else {
            this.options.filter((o) => o.id === option.id).forEach((o) => o.selected = true);
            option.selected = true;
            if (typeof (option.data) === 'object' && option.data && option.data.selected !== undefined) {
                option.data.selected = true;
            }
            this.displayValue = this.getDisplayValue();
            this.value = option.data;
        }

        // to compare value to previous value to make form controls to dirty/ not dirty
        if (this._previousValue !== this.value) {
            this._onChangeCallback(this.value);
            this._previousValue = this.value;
        }
    }

    /**
     * For Selects with Muliple=true
     * get the selected options
     * @return OptionComponent
     */
    getSelectedOptions(): Array<OptionComponent> {
        return this.options ? this.options.filter((i) => !i.selectAll).filter((o) => o.selected) : [];
    }

    /**
     * For Selects with Muliple=false
     * get the display value for the select item, or the placeholder
     * @returns {string}
     */
    getSingleDisplayValue(): string {
        const selectedOption = this.getSelectedOption();
        return selectedOption && selectedOption.displayValue.length > 0 ? selectedOption.displayValue.trim() : (
            this.showNoneIfNull ? this.noneLabel : this.placeholder);
    }

    /**
     * Toggles the visibility of the dropdown/select overlay
     */
    toggleDropdown() {
        // Small timeout to make sure we don't clash with the _setClickListener
        setTimeout(() => {
            if (this.disabled) {
                return;
            }
            if (!this.visible) {
                this.openDropdown();
            } else {
                this.closeDropdown();
            }
        }, 1);
    }

    closeDropdown() {
        window.removeEventListener('resize', this.onResizeBind);
        this.visible = false;
        // If the select dropdown never was opened, do not attempt to unbind
        if (typeof (this.globalListener) !== 'undefined') {
            this.globalListener();
        }
        this.contextMenuClosed();
        this.onBlur();
        this.deleteBackdrop();
        this.onClose.emit(this.value);
    }

    openDropdown() {
        this.setWidth();
        this.selectRadioElement();
        window.addEventListener('resize', this.onResizeBind);
        this.contextMenuOpened();
        this.visible = true;
        this._setClickListener();
        this.openInOverlay();
    }

    /**
     * Make the dropdown overlay as wide as the select box.
     */
    resizeDropDown(): void {
        const dropDownContent = this.overlayElement.nativeElement;
        if (dropDownContent) {
            dropDownContent.style.width = this.width === 'auto' ? 'auto' : DOMHelper.getOuterWidth(this.elementRef.nativeElement) + 'px';
        }
    }

    /**
     * If we click anywhere but in the select box we close it
     * (unless it's non-multiple, then we always close on click)
     */
    private _setClickListener(): void {
        this.globalListener = this.renderer.listen('document', 'click', (event) => {
            const clickInsideDropdown = DOMHelper.closestParent(event.target, 'dropdown-content');
            if (this.visible && !event.target.classList.contains('disabled') && (!this.multiple || !clickInsideDropdown)) {
                this.closeDropdown();
            }
        });
    }

    /**
     * Creates a backdrop unless there is one already
     */
    createBackdrop(): void {
        if (!this.backdrop) {
            this.backdrop = this._backdropService.create(false);
            this.backdrop.instance.onClose.subscribe(() => this.closeDropdown());
        }
    }

    /**
     * Deletes the backdrop if there is one
     */
    deleteBackdrop(): void {
        if (this.backdrop) {
            this.backdrop.instance.onClose.unsubscribe();
            this._backdropService.remove(this.backdrop);
            this.backdrop = null;
        }
    }

}
