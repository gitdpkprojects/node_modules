import { TranslateService } from '@ngx-translate/core';
import {
    Component,
    ComponentRef,
    ElementRef,
    EventEmitter,
    HostBinding,
    HostListener,
    Input,
    OnDestroy,
    Output,
    Renderer2,
    ViewChild,
    ViewEncapsulation
} from '@angular/core';
import * as moment from 'moment';
import 'moment/locale/en-gb';
import { ModalActionItem } from '../../../core/models/button-action-item.model';
import { IOverlayable } from '../../overlay/overlayable.interface';
import { ActionItem } from '../../../core/models/action-item.model';
import { OverlayHelperService } from '../../overlay/overlay-helper.service';
import { BackdropComponent } from '../../backdrop/backdrop.component';
import { DateTimeService } from '../date-time/date-time.service';
import { DateHelper } from '../../../core/helpers/date.helper';
import AnimationHelper from '../../../core/helpers/animation.helper';
import { OVERLAY_CONTEXT } from '../../overlay/overlay.constants';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../../core/classes';
import { DateRange } from '../../../core/models/date-range.model';
import { BackdropService } from '../../backdrop';
import { KEYBOARD } from '../../../core/constants/keyboard.constants';
import { ResizeService } from '../../../core/services';
import { ScreenSize, IWindowSize } from '../../../core/interfaces/window-size';

const momentInstance = (typeof moment === 'object') ? (<any>moment).default : moment;

@Component({
    selector: 'cui-date-time-picker',
    templateUrl: 'date-time-picker.component.html',
    styleUrls: ['date-time-picker.component.scss'],
    encapsulation: ViewEncapsulation.None
})
@UnSub()
export class DateTimePickerComponent implements IOverlayable, OnDestroy {
    @Output() onActionClick: EventEmitter<ActionItem> = new EventEmitter<ActionItem>();

    @HostBinding('class.cui-date-time-picker') addClass: boolean = true;

    // Values are fetched via DateTimeService
    time: string;
    date: Date;

    @Input() showDate: boolean = true;
    @Input() showTime: boolean = true;
    @Input() showSeconds: boolean = true;
    @Output() onClose: EventEmitter<null> = new EventEmitter();
    @Input() steps: number = 5;
    @Input() fromDate: Date;
    @Input() toDate: Date;
    @Input() ranges: DateRange[];

    get displayTime(): string {
        return !this.time ? '' : (this.showSeconds || this.time.length < 6 ? this.time : this.time.substr(0, 5));
    }

    globalListener: Function;
    actions: ModalActionItem[] = [];
    onAction: EventEmitter<ModalActionItem> = new EventEmitter<ModalActionItem>();
    open: boolean = false;
    shown: boolean = false;
    openedInOverlay: boolean = false;
    backdrop: ComponentRef<BackdropComponent>;
    private _subscriptions: Array<Subscription> = [];
    private _windowSize: IWindowSize;
    @ViewChild('pickerWrapper') overlayElement: ElementRef;

    constructor(public overlayHelperService: OverlayHelperService,
                public renderer: Renderer2, public elementRef: ElementRef,
                private _dateTimeService: DateTimeService,
                private _backdropService: BackdropService,
                private _resizeService: ResizeService,
            translate: TranslateService) {
                translate.stream([
                    'ODEN.COMMON.APPLY',
                    'ODEN.COMMON.CANCEL'
                ]).subscribe(res => {
                    this.actions = [
                        new ModalActionItem({
                            label: res['ODEN.COMMON.CANCEL'],
                            action: 'cancel',
                            cssClass: 'discard'
                        }),
                        new ModalActionItem({
                            label: res['ODEN.COMMON.APPLY'],
                            action: 'apply',
                            cssClass: 'primary'
                        })
                    ];
                });
        this.date = this._dateTimeService.date;
        this.time = this._dateTimeService.time;
        this._subscriptions.push(this._dateTimeService.date$.subscribe((date) => {
            this.date = date;
        }));
        this._subscriptions.push(this._dateTimeService.time$.subscribe((time) => {
            this.time = time;
        }));
        this._subscriptions.push(this._resizeService.resize$.subscribe((size) => {
            this._windowSize = size;
            this.setBackdropVisability();
        }));
        this._subscriptions.push(this.onAction.subscribe((actionItem) => {
            switch (actionItem.action) {
                case 'apply':
                    if (this.date && this.time) {
                        this._dateTimeService.date = this.date;
                        this._dateTimeService.time = this.time;
                    } else if (this.date) {
                        this._dateTimeService.date = this.date;
                    } else if (this.time) {
                        this._dateTimeService.time = this.time;
                    }
                    this.closePicker();
                    break;
                case 'cancel':
                    this.cancelPicker();
                    break;
            }
        }));
    }

    /**
     * Call this when ever you want to remove the overlayElement.
     */
    removeFromOverlay(): void {
        if (this.overlayElement && this.openedInOverlay) {
            this.overlayHelperService.removeFromOverlay(this);
        }
        this.deleteBackdrop();
    }

    /**
     * Call this function after you have set the elementRef and overlayElement
     */
    openInOverlay(): void {
        const extraClass = 'date-time-picker-overlay' + (this.bothComponents ? '-big' : '');
        this.createBackdrop();
        this.overlayHelperService.appendToOverlay(this, OVERLAY_CONTEXT.ROOT, extraClass).then(() => {
            this.overlayHelperService.setPosition(this, extraClass);
        });
    }

    /**
     * Dispatches the clicked action
     * @param action
     */
    actionClick(action: ActionItem): void {
        if (action.disabled) {
            return;
        }
        this.onActionClick.emit(action);
    }

    ngOnDestroy(): void {
        this.removeFromOverlay();
    }

    /**
     * Outputs the appropriate icon depending on what kind of picker(s) are shown
     * @returns {string|string}
     */
    get icon(): string {
        return this.showTime && this.showDate ? 'calendar-clock' : (this.showTime && !this.showDate ? 'clock' : 'calendar');
    }

    /**
     * Listens to keyboard events and closes the picker if pressed key is escape.
     */
    @HostListener('document:keyup', ['$event'])
    bindKeyboardShortcuts(event: KeyboardEvent) {
        if (event && event.keyCode === KEYBOARD.ESCAPE && this.open) {
            this.closePicker();
        }
    }

    /**
     * Returns true if both components are used
     * @returns {boolean}
     */
    get bothComponents(): boolean {
        return this.date !== undefined && this.time !== undefined;
    }

    /**
     * Opens the datetimepicker overlay and sets a default date/time if it's null
     */
    openPicker(): void {
        this.shown = true;
        // if date is null (but specified in component), use today's date as default
        if (this.showDate && (this.date === null || typeof(this.date) === 'undefined')) {
            this.date = new Date();
        }
        // if time is null (but specified in component), use current time as default
        if (this.showTime && (this.time === null || typeof(this.time) === 'undefined')) {
            this.time = DateHelper.getTimeStringFromDate(new Date(), this.showSeconds);
        }

        this.open = true;
        if (!this.openedInOverlay) {
            this.openInOverlay();
        }
        setTimeout(() => {
            this._dateTimeService.openPicker();
        }, 10);
    }

    /**
     * Closes the datetime picker
     */
    closePicker(): void {

        this.open = false;
        this.onClose.emit();
        if (typeof(this.globalListener) === 'function') {
            this.globalListener(); // Unbinds to any events
        }
        this.deleteBackdrop();
        AnimationHelper.animationCompleted(this.overlayElement.nativeElement).then(() => {
            this.removeFromOverlay();
        });
    }

    /**
     * Emits ModalActionItem to the listener
     * @param item
     */
    actionClicked(item: ModalActionItem): void {
        this.onAction.emit(item);
    }

    /**
     * Returns a header for the datetime picker - time if no date is defined, otherwise the date
     * @returns {string}
     */
    getHeader(): string {
        if (this.date === undefined) {
            return this.time;
        }
        return momentInstance(this.date).clone().format('YYYY - MMM - DD');
    }

    /**
     * Closes the picker and resets the date/time pickers to their inital value
     */
    cancelPicker(): void {
        this.closePicker();
        // Reset the pickers to initial value when we cancel
        AnimationHelper.animationCompleted(this.overlayElement.nativeElement).then(() => {
            this.time = this._dateTimeService.time;
            this.date = this._dateTimeService.date;
        });
    }

    /**
     * Creates a backdrop unless there is one already
     */
    createBackdrop(): void {
        if (!this.backdrop) {
            this.backdrop = this._backdropService.create(false);
            this.backdrop.instance.onClose.subscribe(() => this.cancelPicker());
            this.setBackdropVisability();
        }
    }

    /**
     * Deletes the backdrop if there is one
     */
    deleteBackdrop(): void {
        if (this.backdrop) {
            this.backdrop.instance.onClose.unsubscribe();
            this._backdropService.remove(this.backdrop);
            this.backdrop = null;
        }
    }
    setBackdropVisability(): void {
        if (this.backdrop && this._windowSize) {
            this.backdrop.instance.isHidden = this._windowSize.size === ScreenSize.LARGE;
        }
    }
}
