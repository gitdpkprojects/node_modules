import { Component, ElementRef, forwardRef, HostBinding, Input, ViewEncapsulation } from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';
import { NumberHelper } from '../../../../core/helpers/number.helper';
import * as moment from 'moment';
import { DateTimeService } from '../../date-time/date-time.service';
import { DATE_FORMAT } from '../../../../core/constants/date.constants';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../../../core/classes';
import { DateRange } from '../../../../core/models/date-range.model';

const momentInstance = (typeof moment === 'object') ? (<any>moment).default : moment;

@Component({
    selector: 'cui-time-picker',
    templateUrl: 'time-picker.component.html',
    styleUrls: [ 'time-picker.component.scss' ],
    encapsulation: ViewEncapsulation.None,
    providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => TimePickerComponent),
        multi: true
    }]
})
@UnSub()
export class TimePickerComponent implements ControlValueAccessor {
    @HostBinding('class.cui-time-picker') addClass: boolean = true;
    @Input() disabled: boolean = false;
    @Input() steps: number = 5;
    @Input() isOpen: boolean = false;
    @Input() showSeconds: boolean = false;
    @Input() fromDate: Date;
    @Input() toDate: Date;
    @Input() ranges: DateRange[];
    @Input() datePickerIsVisible: boolean = false;

    restrictFrom: boolean = false;
    restrictTo: boolean = false;
    restrictedFromDate: Date;
    restrictedToDate: Date;

    get displayTime(): string {
        return !this.time ? '' : (this.showSeconds || this.time.length < 6 ? this.time : this.time.substr(0, 5));
    }

    // The internal data model
    private time: any = null;
    private _hours: any = '';
    private _minutes: any = '';
    private _seconds: any = '';
    private _calendarDate: moment.Moment;
    private _subscriptions: Array<Subscription> = [];

    // Placeholders for the callbacks which are later provided
    // by the Control Value Accessor
    private _onTouchedCallback: () => void = () => {};
    private _onChangeCallback: (_: any) => void = () => {};

    constructor(public elementRef: ElementRef, private _dateTimeService: DateTimeService) {
        this._subscriptions.push(this._dateTimeService.calendarDate$.subscribe((date: moment.Moment) => {
            this._calendarDate = momentInstance(date);
            this.setTimeFromRestrictions();
        }));
        this._subscriptions.push(this._dateTimeService.pickerOpened.subscribe(() => {
            this.setTimeFromRestrictions();
        }));
    }

    // get/sets year accessor
    get hours(): any { return this._hours; }
    set hours(v: any) {
        this._hours = v;
        this.updateControllerValue();
    }

    // get/sets month accessor
    get minutes(): any { return this._minutes; }
    set minutes(v: any) {
        this._minutes = v;
        this.updateControllerValue();
    }

    // get/sets day accessor
    get seconds(): any { return this._seconds; }
    set seconds(v: any) {
        this._seconds = v;
        this.updateControllerValue();
    }

    updateControllerValue(): void {
        if (this.isTimeInRange(this._hours, this._minutes, this._seconds)) {
            this.time = NumberHelper.fixLeadingZero(this._hours) + ':' +
                NumberHelper.fixLeadingZero(this._minutes) +
                (this.showSeconds && this._seconds != null ? ':' + NumberHelper.fixLeadingZero(this._seconds) : '');
        } else {
            this.time = null;
        }
        this._onChangeCallback(this.time);
    }

    // From ControlValueAccessor interface
    registerOnChange(fn: any): void {
        this._onChangeCallback = fn;
    }

    // From ControlValueAccessor interface
    registerOnTouched(fn: any): void {
        this._onTouchedCallback = fn;
    }

    // From ControlValueAccessor interface
    writeValue(time: string): void {
        if (time) {
            const hours = parseInt(time.substr(0, 2), 10);
            const minutes = parseInt(time.substr(3, 5), 10);
            const seconds = time.length > 5 ? parseInt(time.substr(6, 8), 10) : null;
            if (this.isTimeInRange(hours, minutes, seconds)) {
                const previousTime = this.time;
                this.time = time;
                this._hours = hours;
                this._minutes = minutes;
                this._seconds = seconds;
                if (previousTime !== this.time) {
                    this._onChangeCallback(this.time);
                }
            } else {
                throw new Error(`Time '${time}' is not valid`);
            }
        }
    }

    /**
     * Check if our hours, minutes and seconds are in the correct range (0-24, 0-59)
     * @param hours
     * @param minutes
     * @param seconds
     * @returns {boolean}
     */
    isTimeInRange(hours: Number, minutes: Number, seconds: Number): boolean {
        return hours != null && minutes != null  &&
            hours > -1 && hours < 24 &&
            minutes > -1 && minutes < 60 &&
            (seconds == null || (seconds != null && seconds > -1 && seconds < 60));
    }

    /**
     * Updates the time from sliders, get called from the sliders (onSlide)
     * @param sliderHours
     * @param sliderMinutes
     * @param sliderSeconds
     */
    updateTimeFromSliders(sliderHours?: number, sliderMinutes?: number, sliderSeconds?: number): void {

        this._hours = NumberHelper.fixLeadingZero(sliderHours != null ? sliderHours : this.hours);
        this._minutes = NumberHelper.fixLeadingZero(sliderMinutes != null ? sliderMinutes : this.minutes);
        this._seconds = this.seconds != null ? NumberHelper.fixLeadingZero(sliderSeconds != null ? sliderSeconds : this.seconds) : null;

        this.setTimeFromRestrictions();
        setTimeout(() => {
            this.updateControllerValue();
        }, 0);
    }

    /**
     * Re-sets hours/minutes/seconds based on our from / to inputs IF they are too high/low
     */
    setTimeFromRestrictions(): void {
        if (this.fromDate) {
            this.restrictFrom = this.checkRestriction(this.fromDate);
            if (this.restrictFrom) {
                this.restrictedFromDate = this.fromDate;
            }
        }
        if (this.toDate) {
            this.restrictTo = this.checkRestriction(this.toDate);
            if (this.restrictTo) {
                this.restrictedToDate = this.toDate;
            }
        }
        if (this.ranges && this.ranges.length > 0) {
            this.restrictFrom = false;
            this.restrictTo = false;
            const restrictedFromRange = this.ranges.find((range) => this.checkRestriction(range.fromDate));
            const restrictedToRange = this.ranges.find((range) => this.checkRestriction(range.toDate));
            if (restrictedFromRange) {
                this.restrictedFromDate = restrictedFromRange.fromDate;
                this.restrictFrom = true;
            }
            if (restrictedToRange) {
                this.restrictedToDate = restrictedToRange.toDate;
                this.restrictTo = true;
            }
        }
        // Is the hour later than max hours?
        if (this.restrictTo && this.restrictedToDate && this.hours >= this.restrictedToDate.getHours()) {
            this.hours = this.restrictedToDate.getHours();
            // Are the minutes later than max minute?
            if (this.minutes > this.restrictedToDate.getMinutes()) {
                this.minutes = this.restrictedToDate.getMinutes();
                // Are the seconds later than max seconds?
                if (this.seconds > this.restrictedToDate.getSeconds()) {
                    this.seconds = this.restrictedToDate.getSeconds();
                }
            }
        } else if (this.restrictFrom && this.restrictedFromDate && this.hours <= this.restrictedFromDate.getHours()) {
            // Is the hour earlier than min hours?
            this.hours = this.restrictedFromDate.getHours();
            // Are the minutes earlier than min minute?
            if (this.minutes < this.restrictedFromDate.getMinutes()) {
                this.minutes = this.restrictedFromDate.getMinutes();
                // Are the seconds earlier than min second?
                if (this.seconds < this.restrictedFromDate.getSeconds()) {
                    this.seconds = this.restrictedFromDate.getSeconds();
                }
            }
        }
    }

    /**
     * Check if the fromDate/toDate/date ranges has to be resticted or not
     * @param date
     */
    checkRestriction(date: Date) {
        return !this.datePickerIsVisible ||
        this._calendarDate.format(DATE_FORMAT.YEAR_MONTH_DAY) === momentInstance(date).format(DATE_FORMAT.YEAR_MONTH_DAY);
    }
}
