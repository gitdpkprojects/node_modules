import { TranslateService, LangChangeEvent } from '@ngx-translate/core';
import { Component, HostBinding, ViewEncapsulation, Input, forwardRef, OnChanges, SimpleChanges, OnDestroy} from '@angular/core';
import { NG_VALUE_ACCESSOR, ControlValueAccessor } from '@angular/forms';
import * as moment from 'moment';
import 'moment/locale/en-gb';
import { DateHelper } from '../../../../core/helpers/date.helper';
import { DateTimeService } from '../../date-time/date-time.service';
import { DATE_FORMAT } from '../../../../core/constants/date.constants';
import { DateRange } from '../../../../core/models/date-range.model';
import { Subscription } from 'rxjs';
const momentInstance = (typeof moment === 'object') ? (<any>moment).default : moment;

@Component({
    selector: 'cui-date-picker',
    templateUrl: 'date-picker.component.html',
    styleUrls: ['date-picker.component.scss'],
    encapsulation: ViewEncapsulation.None,
    providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => DatePickerComponent),
        multi: true
    }]
})

export class DatePickerComponent implements ControlValueAccessor, OnChanges, OnDestroy {
    @HostBinding('class.cui-date-picker') addClass: boolean = true;
    // tslint:disable-next-line:no-input-rename
    @Input('disabled') disabled: boolean = false;
    @Input() fromDate: Date;
    @Input() toDate: Date;
    @Input() ranges: DateRange[] = [];
    private _date: Date = null;
    fromDateMoment: moment.Moment = null;
    toDateMoment: moment.Moment = null;
    rangesMoment: Array<any> = [];
    weekDays: Array<any> = [];
    weeks: Array<Array<any>> = [];
    get calendarDate(): moment.Moment {
        return this._dateTimeService.calendarDate;
    }

    // Placeholders for the callbacks which are later provided
    // by the Control Value Accessor
    private _onTouchedCallback: () => void = () => { };
    private _onChangeCallback: (_: any) => void = () => { };
    private _subscriptions: Subscription[] = [];
    constructor(private _dateTimeService: DateTimeService, translate: TranslateService) {
        this._subscriptions.push(translate.onLangChange.subscribe((language: LangChangeEvent) => {
            moment.locale(language.lang);
            const monentData =  momentInstance(this._date);
            this.setCalendar(monentData);
            this.weekDays = moment.weekdaysShort(true);
        }));
        moment.locale(translate.currentLang.toLocaleLowerCase());
    }

    // get/sets year accessor
    get date(): Date { return this._date; }
    set date(v: Date) {
        if (v !== this._date) {
            this._date = v;
            this.weekDays = moment.weekdaysShort(true);
            this.setCalendar(momentInstance(v));
            this._onChangeCallback(v);
        }
    }

    ngOnChanges(changes: SimpleChanges) {
        if (changes['fromDate']) {
            this.fromDateMoment = changes['fromDate'].currentValue ? momentInstance(this.fromDate) : null;
        }
        if (changes['toDate']) {
            this.toDateMoment = changes['toDate'].currentValue ? momentInstance(this.toDate) : null;
        }
        if (changes['ranges']) {
            this.rangesMoment = this.ranges ? this.ranges.map((obj: DateRange) => {
                return { fromDate: momentInstance(obj.fromDate), toDate: momentInstance(obj.toDate) };
            }) : [];
        }
    }
    ngOnDestroy(): void {
        this._subscriptions.forEach((subscription) => {
            subscription.unsubscribe();
        });
    }

    /**
     * Returns true if the day is selectable depending on if it's earlier/later than fromDate/toDate
     * @param {moment.Moment} day
     * @returns {boolean}
     */
    isSelectable(day: moment.Moment): boolean {
        if (this.ranges && this.ranges.length > 0) {
            let isInRange = false;
            this.rangesMoment.forEach(range => {
                if (!isInRange) {
                    isInRange = this.validateRange(range.fromDate, range.toDate, day);
                }
            });
            return isInRange && this.validateRange(this.fromDateMoment, this.toDateMoment, day);
        }
        return this.validateRange(this.fromDateMoment, this.toDateMoment, day);
    }

    /**
     * Validates whether the day is in the valid range
     * @param fromDateMoment
     * @param toDateMoment
     * @param day
     */
    validateRange(fromDateMoment, toDateMoment, day): boolean {
        return ((fromDateMoment && day >= fromDateMoment) || !fromDateMoment ||
            fromDateMoment.format(DATE_FORMAT.YEAR_MONTH_DAY) === day.format(DATE_FORMAT.YEAR_MONTH_DAY))
            && ((toDateMoment && day <= toDateMoment) || !toDateMoment ||
                toDateMoment.format(DATE_FORMAT.YEAR_MONTH_DAY) === day.format(DATE_FORMAT.YEAR_MONTH_DAY));
    }
    // From ControlValueAccessor interface
    registerOnChange(fn: any) {
        this._onChangeCallback = fn;
    }

    // From ControlValueAccessor interface
    registerOnTouched(fn: any) {
        this._onTouchedCallback = fn;
    }

    // From ControlValueAccessor interface
    writeValue(date: string) {
        if (date) {
            this.date = momentInstance(date).toDate();
        }
    }

    /**
     * Initialize the calendar, sets weeks with days etc
     * @param momentDate
     */
    setCalendar(momentDate: moment.Moment): void {
        this._dateTimeService.calendarDate = momentDate.clone();

        const firstDay = this._dateTimeService.calendarDate.startOf('month');
        const firstDayInCalendar = firstDay.clone().startOf('week');
        const nmbWeeks = this.getWeekNums(this._dateTimeService.calendarDate);

        this.weeks = [];
        for (let week = 1; week <= nmbWeeks; week++) {
            const days = [];
            for (let day = ((week - 1) * 7); day < (((week - 1) * 7) + 7); day++) {
                days.push(firstDayInCalendar.clone().add(day, 'days'));
            }
            this.weeks.push(days);
        }
    }

    /**
     * Changes the date's year (accepts negative values)
     * @param int
     */
    goYear(int: number): void {
        this.setCalendar(this._dateTimeService.calendarDate.add(int, 'years'));
    }

    /**
     * Changes the date's month (accepts negative values)
     * @param int
     */
    goMonth(int: number): void {
        this.setCalendar(this._dateTimeService.calendarDate.add(int, 'months'));
    }

    /**
     * Sets date, happens when the user clicks on a day in the calendar.
      * @param day
     * @param event
     */
    setDate(day: moment.Moment, event: Event): void {
        if (this.isSelectable(day)) {
            this.date = day.toDate();
            event.stopPropagation();
        }
    }

    /**
     * Returns true if the day is active (the same as the chosen date)
     * @param day
     * @param date
     * @returns {boolean}
     */
    dayIsActive(day: moment.Moment, date: Date): boolean {
        return day.format(DATE_FORMAT.YEAR_MONTH_DAY) === DateHelper.getStringFromDate(date, false);
    }

    /**
     * Returns number of weeks there is in a month
     * @param date
     * @returns {number}
     */
    getWeekNums(date: moment.Moment): number {
        const clonedMoment = momentInstance(date);
        // get week number for first day of month
        let first = clonedMoment.startOf('month').week();
        // get week number for last day of month
        let last = clonedMoment.endOf('month').week();

        // In case we are in December and last week is in next year
        if (first > last && clonedMoment.month() === 11) {
            last = clonedMoment.endOf('month').subtract(1, 'week').week() + 1;
        } else if (first > last && clonedMoment.month() === 0) {
            // In case we are in January and first week is in the year before
            first = 0;
        }
        return last - first + 1;
    }

}
