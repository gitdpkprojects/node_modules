import {
    Component,
    ElementRef,
    EventEmitter,
    forwardRef,
    HostBinding,
    HostListener,
    Input,
    Output,
    ViewEncapsulation
} from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';
import { KEYBOARD } from '../../../core/constants/keyboard.constants';
import { NumberHelper } from '../../../core/helpers/number.helper';
import { IHammerInput } from '../../../core/interfaces/gesture.interface';
import { SliderRenderer } from './slider-renderer.class';
import { SliderChange } from './slider-change.class';

/** Gap size for a disabled slider. */
const DISABLED_THUMB_GAP = 7;
/** Gap size for a non-active slider at its minimum value. */
const MIN_VALUE_NONACTIVE_THUMB_GAP = 7;
/** Gap size for an active slider at its minimum value. */
const MIN_VALUE_ACTIVE_THUMB_GAP = 10;

export const SLIDER_VALUE_ACCESSOR: any = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => SliderComponent),
    multi: true
};

@Component({
    selector: 'cui-slider',
    providers: [SLIDER_VALUE_ACCESSOR],
    templateUrl: 'slider.component.html',
    styleUrls: ['slider.component.scss'],
    encapsulation: ViewEncapsulation.None
})
export class SliderComponent implements ControlValueAccessor {
    @HostBinding('attr.role') role = 'slider';
    @HostBinding('class.cui-slider-active') _isActive: boolean = false;
    @HostBinding('class.cui-slider') addClass: boolean = true;
    @HostBinding('class.cui-slider-sliding') _isSliding: boolean = false;
    // tslint:disable-next-line:no-input-rename
    @HostBinding('attr.tabindex') @Input('tabindex') tabindex = 0;

    /** Event emitted when the slider value has changed. */
    @Output() onChange = new EventEmitter<SliderChange>();

    /** Event emitted when the slider thumb moves. */
    @Output() onSlide = new EventEmitter<SliderChange>();

    private _renderer: SliderRenderer = null;
    private _sliderDimensions: ClientRect = null;
    private _disabled: boolean = false;
    private _thumbLabel: boolean = true;
    private _lastChangeValue: number = null;
    private _lastInputValue: number = null;
    private _roundLabelTo: number;
    private _step: number = 1;
    private _percent: number = 0;
    private _value: number = null;
    private _min: number = 0;
    private _max: number = 100;
    private _invert = false;
    private _vertical = false;
    private _controlValueAccessorChangeFn: (value: any) => void = () => {};

    /** Whether or not the slider is disabled. */
    @HostBinding('class.cui-slider-disabled')
    @Input()
    get disabled(): boolean { return this._disabled; }
    set disabled(value) { this._disabled = value != null && `${value}` !== 'false'; }

    /** Whether or not to show the thumb label. */
    @HostBinding('class.cui-slider-thumb-label-showing')
    @Input('thumbLabel')
    get thumbLabel(): boolean { return this._thumbLabel; }
    set thumbLabel(value) { this._thumbLabel = value != null && `${value}` !== 'false'; }

    /** onTouch function registered via registerOnTouch (ControlValueAccessor). */
    onTouched: () => any = () => {};

    /** The values at which the thumb will snap. */
    @Input()
    get step(): number { return this._step; }
    set step(v) {
        this._step = NumberHelper.coerceNumberProperty(v, this._step);
        if (this._step % 1 !== 0) {
            this._roundLabelTo = this._step.toString().split('.').pop().length;
        }
    }

    /** The percentage of the slider that coincides with the value. */
    get percent(): number { return this._clamp(this._percent); }

    /** Value of the slider. */
    @Input()
    get value(): number {
        // If the value needs to be read and it is still uninitialized, initialize it to the min.
        if (this._value === null) {
            this.value = this._min;
        }
        return this._value;
    }
    set value(v: number) {
        this._value = NumberHelper.coerceNumberProperty(v, this._value);
        this._percent = this._calculatePercentage(this._value);
    }


    /** The minimum value that the slider can have. */
    @Input()
    get min(): number {
        return this._min;
    }
    set min(v: number) {
        this._min = NumberHelper.coerceNumberProperty(v, this._min);

        // If the value wasn't explicitly set by the user, set it to the min.
        if (this._value === null) {
            this.value = this._min;
        }
        this._percent = this._calculatePercentage(this.value);
    }


    /** The maximum value that the slider can have. */
    @Input()
    get max(): number {
        return this._max;
    }
    set max(v: number) {
        this._max = NumberHelper.coerceNumberProperty(v, this._max);
        this._percent = this._calculatePercentage(this.value);
    }

    /** Whether the slider is inverted. */
    @Input()
    get invert(): any { return this._invert; }
    set invert(value: any) { this._invert = value != null && `${value}` !== 'false'; }

    /** Whether the slider is horizontal. */
    @HostBinding('class.cui-slider-horizontal')
    get isHorizontal(): boolean { return !this.vertical; }

    /** Whether the slider is vertical. */
    @HostBinding('class.cui-slider-vertical')
    @Input()
    get vertical(): any { return this._vertical; }
    set vertical(value: any) { this._vertical = value != null && `${value}` !== 'false'; }

    /** The value to be used for display purposes. */
    get displayValue(): string|number {
        if (this._roundLabelTo && this.value % 1 !== 0) {
            return this.value.toFixed(this._roundLabelTo);
        }

        return this.value;
    }

    /**
     * Whether the axis of the slider is inverted.
     * (i.e. whether moving the thumb in the positive x or y direction decreases the slider's value).
     */
    @HostBinding('class.cui-slider-axis-inverted')
    get invertAxis(): boolean {
        return this.vertical ? !this.invert : this.invert;
    }

    /**
     * Whether mouse events should be converted to a slider position by calculating their distance
     * from the right or bottom edge of the slider as opposed to the top or left.
     */
    get invertMouseCoords(): boolean {
        return (this.direction === 'rtl' && !this.vertical) ? !this.invertAxis : this.invertAxis;
    }

    /** Whether the slider is at its minimum value. */
    @HostBinding('class.cui-slider-min-value')
    get _isMinValue(): boolean {
        return this.percent === 0;
    }

    /**
     * The amount of space to leave between the slider thumb and the track fill & track background
     * elements.
     */
    get _thumbGap(): number {
        if (this.disabled) {
            return DISABLED_THUMB_GAP;
        }
        if (this._isMinValue && !this.thumbLabel) {
            return this._isActive ? MIN_VALUE_ACTIVE_THUMB_GAP : MIN_VALUE_NONACTIVE_THUMB_GAP;
        }
        return 0;
    }

    /** CSS styles for the track background element. */
    get trackBackgroundStyles(): { [key: string]: string } {
        const axis = this.vertical ? 'Y' : 'X';
        const sign = this.invertMouseCoords ? '-' : '';
        return {
            'transform': `translate${axis}(${sign}${this._thumbGap}px) scale${axis}(${1 - this.percent})`
        };
    }

    /** CSS styles for the track fill element. */
    get trackFillStyles(): { [key: string]: string } {
        const axis = this.vertical ? 'Y' : 'X';
        const sign = this.invertMouseCoords ? '' : '-';
        return {
            'transform': `translate${axis}(${sign}${this._thumbGap}px) scale${axis}(${this.percent})`
        };
    }

    /** CSS styles for the thumb container. */
    get thumbContainerStyles(): { [key: string]: string } {
        const axis = this.vertical ? 'Y' : 'X';
        const invertOffset =
            (this.direction === 'rtl' && !this.vertical) ? !this.invertAxis : this.invertAxis;
        const offset = (invertOffset ? this.percent : 1 - this.percent) * 100;
        return {
            'transform': `translate${axis}(-${offset}%)`
        };
    }

    /** The language direction for this slider element. */
    get direction(): string {
        return 'ltr';
    }

    constructor(elementRef: ElementRef) {
        this._renderer = new SliderRenderer(elementRef);
    }

    @HostListener('mouseenter')
    _onMouseenter() {
        if (this.disabled) {
            return;
        }
        this._sliderDimensions = this._renderer.getSliderDimensions();
    }

    @HostListener('mousedown', ['$event'])
    _onMouseDown(event: MouseEvent) {
        if (this.disabled) {
            return;
        }
        if ((<HTMLElement>event.target).classList.contains('cui-slider-thumb')) {
            this._isActive = true;
        }
    }

    @HostListener('mouseup')
    _onMouseUp() {
        this._isActive = false;
    }

    @HostListener('click', ['$event'])
    _onClick(event: MouseEvent) {
        if (this.disabled) {
            return;
        }

        this._isSliding = false;
        this._renderer.addFocus();
        this._updateValueFromPosition({x: event.clientX, y: event.clientY});

        /* Emits a change and input event if the value changed. */
        this._emitInputEvent();
        this._emitValueIfChanged();
    }

    @HostListener('slide', ['$event'])
    _onSlide(event: IHammerInput) {
        if (this.disabled) {
            return;
        }

        // Prevent the slide from selecting anything else.
        event.preventDefault();
        this._updateValueFromPosition({x: event.center.x, y: event.center.y});

        // Native range elements always emit `input` events when the value changed while sliding.
        this._emitInputEvent();
    }

    @HostListener('slidestart', ['$event'])
    _onSlideStart(event: IHammerInput) {
        if (this.disabled) {
            return;
        }

        // Simulate mouseenter in case this is a mobile device.
        this._onMouseenter();

        event.preventDefault();
        this._isSliding = true;
        this._isActive = true;
        this._renderer.addFocus();
        this._updateValueFromPosition({x: event.center.x, y: event.center.y});
    }

    @HostListener('slideend')
    _onSlideEnd() {
        this._isSliding = false;
        this._isActive = false;
        this._emitValueIfChanged();
    }

    @HostListener('blur')
    _onBlur() {
        this._isActive = false;
        this.onTouched();
    }

    @HostListener('keydown', ['$event'])
    _onKeydown(event: KeyboardEvent) {
        if (this.disabled) { return; }

        switch (event.keyCode) {
            case KEYBOARD.LEFT_ARROW:
                this._increment(this.direction === 'rtl' ? 1 : -1);
                break;
            case KEYBOARD.UP_ARROW:
                this._increment(1);
                break;
            case KEYBOARD.RIGHT_ARROW:
                this._increment(this.direction === 'rtl' ? -1 : 1);
                break;
            case KEYBOARD.DOWN_ARROW:
                this._increment(-1);
                break;
            default:
                return;
        }

        this._isSliding = true;
        event.preventDefault();
    }

    @HostListener('keyup')
    _onKeyup() {
        this._isSliding = false;
    }

    /** Increments the slider by the given number of steps (negative number decrements). */
    private _increment(numSteps: number) {
        this.value = this._clamp(this.value + this.step * numSteps, this.min, this.max);
        this._emitInputEvent();
        this._emitValueIfChanged();
    }

    /** Calculate the new value from the new physical location. The value will always be snapped. */
    private _updateValueFromPosition(pos: {x: number, y: number}) {
        if (!this._sliderDimensions) {
            return;
        }

        const offset = this.vertical ? this._sliderDimensions.top : this._sliderDimensions.left;
        const size = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;
        const posComponent = this.vertical ? pos.y : pos.x;

        // The exact value is calculated from the event and used to find the closest snap value.
        let percent = this._clamp((posComponent - offset) / size);
        if (this.invertMouseCoords) {
            percent = 1 - percent;
        }
        const exactValue = this._calculateValue(percent);

        // This calculation finds the closest step by finding the closest whole number divisible by the
        // step relative to the min.
        const closestValue = Math.round((exactValue - this.min) / this.step) * this.step + this.min;
        // The value needs to snap to the min and max.
        this.value = this._clamp(closestValue, this.min, this.max);
    }

    /** Emits a change event if the current value is different from the last emitted value. */
    private _emitValueIfChanged() {
        if (this.value !== this._lastChangeValue) {
            const event = this._createChangeEvent();
            this._lastChangeValue = this.value;
            this._controlValueAccessorChangeFn(this.value);
            this.onChange.emit(event);
        }
    }

    /** Emits an input event when the current value is different from the last emitted value. */
    private _emitInputEvent() {
        if (this.value !== this._lastInputValue) {
            const event = this._createChangeEvent();
            this._lastInputValue = this.value;
            this.onSlide.emit(event);
        }
    }

    /** Creates a slider change object from the specified value. */
    private _createChangeEvent(value = this.value): SliderChange {
        const event = new SliderChange();

        event.source = this;
        event.value = value;

        return event;
    }

    /** Calculates the percentage of the slider that a value is. */
    private _calculatePercentage(value: number) {
        return (value - this.min) / (this.max - this.min);
    }

    /** Calculates the value a percentage of the slider corresponds to. */
    private _calculateValue(percentage: number) {
        return this.min + percentage * (this.max - this.min);
    }

    /** Return a number between two numbers. */
    private _clamp(value: number, min = 0, max = 1) {
        return Math.max(min, Math.min(value, max));
    }

    /**
     * Sets the model value. Implemented as part of ControlValueAccessor.
     * @param value
     */
    writeValue(value: any) {
        this.value = value;
    }

    /**
     * Registers a callback to eb triggered when the value has changed.
     * Implemented as part of ControlValueAccessor.
     * @param fn Callback to be registered.
     */
    registerOnChange(fn: (value: any) => void) {
        this._controlValueAccessorChangeFn = fn;
    }

    /**
     * Registers a callback to be triggered when the component is touched.
     * Implemented as part of ControlValueAccessor.
     * @param fn Callback to be registered.
     */
    registerOnTouched(fn: any) {
        this.onTouched = fn;
    }

    /**
     * Sets whether the component should be disabled.
     * Implemented as part of ControlValueAccessor.
     * @param isDisabled
     */
    setDisabledState(isDisabled: boolean) {
        this.disabled = isDisabled;
    }
}
