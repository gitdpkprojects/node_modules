/* tslint:disable:directive-selector-name */
import {
    AfterViewInit, Directive, DoCheck, ElementRef, HostBinding, HostListener, Input,
    Renderer2
} from '@angular/core';
import { DOMHelper } from '../../../core/helpers/dom.helper';
import { FORM } from './../../../core/constants';

@Directive({
    selector: '[cui-textarea]'
})

export class TextareaDirective implements AfterViewInit, DoCheck {
    lastHeight: number = 0;
    label: HTMLLabelElement;
    value: string;

    @Input() wordwrap = false;
    @HostBinding('style.white-space') get _wordwrap() {
        return this.wordwrap ? 'auto' : 'pre';
    }
    @Input() resize = false;
    @HostBinding('style.resize') get _resize() {
        return this.resize ? 'auto' : 'none';
    }
    @HostBinding('style.height') get _height() {
        return this.resize ? 'auto' : '30px';
    }
    @HostBinding('class.cui-textarea') addClass: boolean = true;
    @HostBinding('class.no-transition') noTransition: boolean = true;
    @HostBinding('class.has-value') get hasValue(): boolean {
        // Autogrow function, setting the textareas height according to its content
        if (!this.resize && this._element && this._element.nativeElement) {
            const height = this._element.nativeElement.scrollHeight;
            if (this.lastHeight !== height) {
                this._element.nativeElement.style.height = 0;
                this._element.nativeElement.style.height = this._element.nativeElement.scrollHeight + 'px';
                this.lastHeight = height;
            }
        }

        return this._element && this._element.nativeElement && !!this._element.nativeElement.value;
    }

    constructor(private _element: ElementRef, private _renderer: Renderer2) {}

    /**
     * Create a character counter after the <label> if needed.
     * Also resize label to fit into the form element (when it's pretending to be a placeholder)
     */
    ngAfterViewInit(): void {
        const id: string = this._element.nativeElement.id;
        if (id) {
            this.label = <HTMLLabelElement> document.querySelector(`label[for='${id}']`);
        }
        if (!this.label) {
            const closest_label = <HTMLLabelElement> this._element.nativeElement.parentNode.querySelector('label');
            if (closest_label) {
                this.label = closest_label;
            }
        }
        if (this.label) {
            this.label.setAttribute('undefinedMessage', FORM.NO_FORM_VALUE);
        }
        this.selectRadioElement(false);
        setTimeout(() => {
            this.noTransition = false;
        }, 100);
    }

    /**
     * Check if we're inside a radiobutton's label on focus
     */
    @HostListener('focus')
    addActive(): void {
        this.selectRadioElement();
    }

    /**
     * Check if we're inside a radiobutton's label, if so then make the radio button active
     * Click it per default, otherwise we add some css classes (this happens one time, in afterviewinit)
     * @param {Boolean} click
     */
    selectRadioElement(click: Boolean = true): void {
        const radios_label = DOMHelper.closestParentTag(this._element.nativeElement, 'label');
        if (radios_label) {
            let radio = <HTMLInputElement> document.getElementById(radios_label.getAttribute('for'));
            // "click" the radio (setting checked = true won't update models)
            if (!radio) {
                // find radio by checking previous sibling in DOM tree
                const previousElement = radios_label.previousElementSibling;
                if (previousElement && previousElement.classList.contains('cui-radio')) {
                    radio = previousElement;
                }
            }
            if (radio && radio.classList.contains('cui-radio')) {
                if (click) {
                    radio.click();
                } else {
                    this._renderer.addClass(this._element.nativeElement, 'next-to-radio');
                    this._renderer.addClass(radios_label, 'next-to-textarea');
                }
            }
        }
    }

    ngDoCheck() {
        if (this.value !== this._element.nativeElement.value) {
            this.value = this._element.nativeElement.value;
            DOMHelper.updateChartCounterValue(this._element);
        }
    }
}
