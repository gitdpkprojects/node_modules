import {
    Component,
    ElementRef,
    EventEmitter,
    forwardRef,
    HostBinding,
    Input,
    OnChanges,
    OnInit,
    Output,
    Renderer2,
    ViewChild,
    ViewEncapsulation
} from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';
import { UUID } from '../../../core/helpers/uuid.class';
import { DateTimeService } from './date-time.service';
import { DateHelper } from '../../../core/helpers/date.helper';
import { TextMaskConfig } from '../../../core/models/text-mask.model';
import { DOMHelper } from '../../../core/helpers';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../../core/classes';

@Component({
    selector: 'cui-time-input',
    templateUrl: 'time-input.component.html',
    styleUrls: ['time-input.component.scss'],
    encapsulation: ViewEncapsulation.None,
    providers: [DateTimeService, {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => TimeInputComponent),
        multi: true
    }]
})
@UnSub()
export class TimeInputComponent implements ControlValueAccessor, OnInit, OnChanges {
    @HostBinding('class.cui-date-component')
    @HostBinding('class.cui-time-input') addClass: boolean = true;
    @Input() disabled: boolean = false;
    @Input() title: string = 'Time';
    @Input() seconds: boolean = false;
    @Input() steps: number = 5;
    @Input() required;
    @Input() showPicker: boolean = true;
    @Input() fromDate: Date;
    @Input() toDate: Date;
    @Output() onChange: EventEmitter<string> = new EventEmitter<string>();
    @Output() onBlur: EventEmitter<string> = new EventEmitter<string>();

    id = 'time-' + UUID.create();
    placeholder: string = '';
    displayValue: string = '';
    textMask: TextMaskConfig = new TextMaskConfig({
        mask: [],
        keepCharPositions: true,
        guide: false,
        placeholderChar: '\u2007'
    });
    private _subscription: Subscription;

    @ViewChild('input') inputField: ElementRef;

    // The internal data model
    private _value: string = null;

    // Placeholders for the callbacks which are later provided
    // by the Control Value Accessor
    private _onTouchedCallback: () => void = () => {};
    private _onChangeCallback: (_: any) => void = () => {};

    constructor(public renderer: Renderer2, private _dateTimeService: DateTimeService,
                public elementRef: ElementRef) {

        this._subscription = _dateTimeService.time$.subscribe((time) => {
            this.value = time;
            this.setDisplayValue();
        });

    }

    // get/sets time
    get value(): string {
        return this._value;
    }

    @Input() set value(v: string) {
        if (v !== this._value) {
            this._value = v;
            this.onChange.emit(v);
            this._onChangeCallback(this.value);
        } else if (v && DOMHelper.closestParent(this.elementRef.nativeElement, 'cui-list-controller-component')) {
            // trigger onchange if we're inside a filter/list-controller-component
            Promise.resolve().then(() => {
                this.onChange.emit(v);
            });
        }
    }

    setDisplayValue(): void {
        this.displayValue = `${this.value ? this.value : ''}`;
    }

    ngOnInit(): void {
        this.placeholder = this.seconds ? 'HH:MM:SS' : 'HH:MM';
        this.textMask.mask = this.seconds ? [/[0-9]/, /[0-9]/, ':', /[0-9]/, /[0-9]/, ':', /[0-9]/, /[0-9]/] :
            [/[0-9]/, /[0-9]/, ':', /[0-9]/, /[0-9]/];
        this.setDisplayValue();
    }

    ngOnChanges(): void {
        this.setDisplayValue();
    }

    // Set touched on blur
    blur(): void {
        this._onTouchedCallback();
        this.onBlur.emit(this.value);

    }

    getPlaceholder(): string {
        return `<span>${this.displayValue.substring(0, this.displayValue.length)}</span>
            ${this.placeholder.substring(this.displayValue.length)}`;
    }

    // Triggers when user writes in input field
    setValueFromInput(): void {
        // check if value is proper time (HH:ii or HH:ii:ss)
        const inputValue = this.inputField.nativeElement.value;
        if (DateHelper.isValidTime(inputValue, this.seconds)) {
            this.value = inputValue;
            this._dateTimeService.time = inputValue;
        } else {
            // setting this.value to undefined if empty to trigger timeValidator (triggers when going from null to undefined)
            this.value = (inputValue === '' ? undefined : null);
        }
        // We call the DateTimeService and set time to null if we have emptied the input field,
        // that way the date-time-picker will use current Date() time when it opens
        if (inputValue === '') {
            this._dateTimeService.time = undefined;
        }
    }

    // From ControlValueAccessor interface
    writeValue(time: string): void {
        this._value = time;
        this._dateTimeService.time = time;
    }

    // From ControlValueAccessor interface
    registerOnChange(fn: any): void {
        this._onChangeCallback = fn;
    }

    // From ControlValueAccessor interface
    registerOnTouched(fn: any): void {
        this._onTouchedCallback = fn;
    }
}
