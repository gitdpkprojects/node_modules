/* tslint:disable:no-input-rename */
import {
    Component,
    ElementRef,
    EventEmitter,
    forwardRef,
    HostBinding,
    Input,
    OnChanges,
    OnInit,
    Output,
    Renderer2,
    ViewChild,
    ViewEncapsulation
} from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';
import { UUID } from '../../../core/helpers/uuid.class';
import * as moment from 'moment';
import 'moment/locale/en-gb';
import { DateTimeService } from './date-time.service';
import { DateHelper } from '../../../core/helpers/date.helper';
import { TextMaskConfig } from '../../../core/models/text-mask.model';
import * as _ from 'lodash';
import { DATE_FORMAT } from '../../../core/constants/date.constants';
import { DOMHelper } from '../../../core/helpers';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../../core/classes';
import { DateRange } from '../../../core/models/date-range.model';

const momentInstance = (typeof moment === 'object') ? (<any>moment).default : moment;

@Component({
    selector: 'cui-date-time-input',
    templateUrl: 'date-time-input.component.html',
    styleUrls: ['date-time-input.component.scss'],
    encapsulation: ViewEncapsulation.None,
    providers: [DateTimeService, {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => DateTimeInputComponent),
        multi: true
    }]
})
@UnSub()
export class DateTimeInputComponent implements ControlValueAccessor, OnInit, OnChanges {
    @HostBinding('class.cui-date-component')
    @HostBinding('class.cui-date-time-input') addClass: boolean = true;
    @Input('disabled') disabled: boolean = false;
    @Input('title') title: string = 'Date';
    @Input('seconds') seconds: boolean;
    @Input('required') required: boolean;
    @Input() fromDate: Date;
    @Input() toDate: Date;
    @Input() ranges: DateRange[] = [];
    @Input() showPicker: boolean = true;
    @Output() onChange: EventEmitter<Date> = new EventEmitter<Date>();
    @Output() onBlur: EventEmitter<Date> = new EventEmitter<Date>();

    id: string = 'date-time-' + UUID.create();
    displayValue: string = '';
    placeholder: string = '';
    textMask: TextMaskConfig = new TextMaskConfig({
        mask: [],
        keepCharPositions: true,
        guide: false,
        placeholderChar: '\u2007'
    });
    private _date: any;
    private _subscriptions: Array<Subscription> = [];

    @ViewChild('input') inputField: ElementRef;

    // The internal data model
    private _value: Date = null;

    // Placeholders for the callbacks which are later provided
    // by the Control Value Accessor
    private _onTouchedCallback: () => void = () => {};
    private _onChangeCallback: (_: any) => void = () => {};

    constructor(public renderer: Renderer2, private _dateTimeService: DateTimeService,
        public elementRef: ElementRef) {

        this._subscriptions.push(_dateTimeService.date$.subscribe((date) => {
            this._date = date;
        }));

        this._subscriptions.push(_dateTimeService.time$.subscribe((time) => {
            // add our time to the date
            const matches = time ? time.match(/\d+/g) : [];
            const newValue: Date = _.cloneDeep(this._date);
            let finalNewValue: Date = newValue;
            if (matches && matches[0]) { // Hour
                const hours = parseInt(matches[0], 0);
                if (hours && !isNaN(hours)) {
                    newValue.setHours(hours);
                }
                if (matches[1]) { // Minute
                    const minutes = parseInt(matches[1], 0);
                    if ( minutes && !isNaN(minutes)) {
                        newValue.setMinutes(minutes);
                    }
                    if (!this.seconds || (this.seconds && matches[2])) { // Second
                        if (matches[2]) {
                            const seconds = parseInt(matches[2], 0);
                            if ( seconds && !isNaN(seconds)) {
                                newValue.setSeconds(seconds);
                            }
                        }
                    }
                    finalNewValue = newValue;
                }
            }
            this.value = finalNewValue;
            this._date = finalNewValue;
            this.setDisplayValue();
        }));
    }

    getPlaceholder(): string {
        return `<span>${this.displayValue.substring(0, this.displayValue.length)}</span>
            ${this.placeholder.substring(this.displayValue.length)}`;
    }

    // get/sets date
    get value(): Date {
        return this._value;
    }

    @Input() set value(v: Date) {
        if (!_.isEqual(v, this._value)) {
            this._value = v;
            this.onChange.emit(v);
            this._onChangeCallback(this.value);
        } else if (v && DOMHelper.closestParent(this.elementRef.nativeElement, 'cui-list-controller-component')) {
            // trigger onchange if we're inside a filter/list-controller-component
            Promise.resolve().then(() => {
                this.onChange.emit(v);
            });
        }
    }

    ngOnInit(): void {
        this.placeholder = this.seconds ? 'YYYY-MM-DD HH:MM:SS' : 'YYYY-MM-DD HH:MM';
        // mask for YYYY-MM-DD HH:MM:SS
        this.textMask.mask = this.seconds ? [/[0-9]/, /[0-9]/, /[0-9]/, /[0-9]/, '-', /[0-9]/, /[0-9]/, '-', /[0-9]/, /[0-9]/, ' ',
            /[0-9]/, /[0-9]/, ':', /[0-9]/, /[0-9]/, ':', /[0-9]/, /[0-9]/] :
            [/[0-9]/, /[0-9]/, /[0-9]/, /[0-9]/, '-', /[0-9]/, /[0-9]/, '-', /[0-9]/, /[0-9]/, ' ',
                /[0-9]/, /[0-9]/, ':', /[0-9]/, /[0-9]/];
        this.setDisplayValue();
    }

    setDisplayValue(): void {
        this.displayValue = this.value ? (this.seconds ? DateHelper.getStringFromDate(this.value) :
            momentInstance(this.value).format(DATE_FORMAT.YEAR_MONTH_DAY_HOUR_MINUTE)) : '';
    }

    ngOnChanges(): void {
        this.setDisplayValue();
    }

    /**
     * Returns either HH:mm or HH:mm:ss depending on if this.seconds is used or not
     * @returns {string | null}
     */
    get time(): string | null {
        return this.value ? (this.seconds ? DateHelper.getTimeStringFromDate(this.value) :
            momentInstance(this.value).format('HH:mm')) : null;
    }

    // Set touched on blur
    blur(): void {
        this._onTouchedCallback();
        this.onBlur.emit(this.value);
    }

    // Triggers when user writes in input field
    setValueFromInput(): void {
        const inputValue = this.inputField.nativeElement.value;
        let newValue: Date | undefined;
        if (DateHelper.isValidDateTime(inputValue, this.seconds)) {
            newValue = momentInstance(inputValue).toDate();
            let timeString = '';
            this._dateTimeService.date = momentInstance(inputValue).startOf('day').toDate();
            if ( this.seconds) {
                timeString = momentInstance(inputValue).format(DATE_FORMAT.HOUR_MINUTE_SECOND);
            } else {
                timeString = momentInstance(inputValue).format(DATE_FORMAT.HOUR_MINUTE);
            }
            this._dateTimeService.time = timeString;
        }
        // We call the DateTimeService and set date to null if we have emptied the input field,
        // that way the date-time-picker will use current Date() when it opens
        // setting finalNewValue to undefined to trigger dateTimeValidator (triggers when going from null to undefined)
        if (inputValue === '') {
            this._dateTimeService.date = null;
            this._dateTimeService.time = null;
        }
        this._date = newValue;
        this.value = newValue;
        this._onChangeCallback(this.value);
    }

    // From ControlValueAccessor interface
    writeValue(date: Date): void {
        this._value = date;
        this._dateTimeService.date = date;
        this._dateTimeService.time = date ? DateHelper.getTimeStringFromDate(date, this.seconds) : null;
    }

    // From ControlValueAccessor interface
    registerOnChange(fn: any): void {
        this._onChangeCallback = fn;
    }

    // From ControlValueAccessor interface
    registerOnTouched(fn: any): void {
        this._onTouchedCallback = fn;
    }
}
