import {
    Component,
    ElementRef,
    EventEmitter,
    forwardRef,
    HostBinding,
    Input,
    OnChanges,
    OnInit,
    Output,
    Renderer2,
    ViewChild,
    ViewEncapsulation
} from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';
import { UUID } from '../../../core/helpers/uuid.class';
import { DateTimeService } from './date-time.service';
import { DateHelper } from '../../../core/helpers/date.helper';
import { TextMaskConfig } from '../../../core/models/text-mask.model';
import { DATE_FORMAT } from '../../../core/constants/date.constants';
import { DOMHelper } from '../../../core/helpers';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../../core/classes';
import { DateRange } from '../../../core/models/date-range.model';

import * as moment from 'moment';
import 'moment/locale/en-gb';

const momentInstance = (typeof moment === 'object') ? (<any>moment).default : moment;

@Component({
    selector: 'cui-date-input',
    templateUrl: 'date-input.component.html',
    styleUrls: ['date-input.component.scss'],
    encapsulation: ViewEncapsulation.None,
    providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => DateInputComponent),
        multi: true
    }, DateTimeService]
})
@UnSub()
export class DateInputComponent implements ControlValueAccessor, OnInit, OnChanges {
    @HostBinding('class.cui-date-component')
    @HostBinding('class.cui-date-input') addClass: boolean = true;
    @Input() disabled: boolean = false;
    @Input() title: string = 'Date';
    @Input() fromDate: Date;
    @Input() toDate: Date;
    @Input() ranges: DateRange[] = [];
    @Input() required: boolean;
    @Input() showPicker: boolean = true;
    @Output() onChange: EventEmitter<Date> = new EventEmitter<Date>();
    @Output() onBlur: EventEmitter<Date> = new EventEmitter<Date>();

    id = 'date-' + UUID.create();
    displayValue: string = '';
    placeholder: string = DATE_FORMAT.YEAR_MONTH_DAY;
    textMask: TextMaskConfig = new TextMaskConfig({
        mask: [],
        keepCharPositions: true,
        guide: false,
        placeholderChar: '\u2007'
    });
    private _subscription: Subscription;

    @ViewChild('input') inputField: ElementRef;

    // The internal data model
    private _value: any = null;
    private _hours: number;
    private _minutes: number;
    private _seconds: number;
    private _milliSeconds: number;


    // Placeholders for the callbacks which are later provided
    // by the Control Value Accessor
    private _onTouchedCallback: () => void = () => { };
    private _onChangeCallback: (_: any) => void = () => { };

    constructor(public renderer: Renderer2, private _dateTimeService: DateTimeService,
        public elementRef: ElementRef) {

        this._subscription = _dateTimeService.date$.subscribe((date) => {
            if (this._hours > -1 && DateHelper.isDateObj(date)) {
                date.setHours(this._hours);
                date.setMinutes(this._minutes);
                date.setSeconds(this._seconds);
                date.setMilliseconds(this._milliSeconds);
            }
            this.value = date;
            this.setDisplayValue();
        });

    }


    // get/sets date
    get value(): any {
        return this._value;
    }

    @Input() set value(_value: any) {
        if (_value !== this._value) {
            this._value = _value;

            if (DateHelper.isDateObj(_value)) {
                this._hours = _value.getHours();
                this._minutes = _value.getMinutes();
                this._seconds = _value.getSeconds();
                this._milliSeconds = _value.getMilliseconds();
            }
            this.onChange.emit(_value);
            this._onChangeCallback(this.value);
        } else if (_value && DOMHelper.closestParent(this.elementRef.nativeElement, 'cui-list-controller-component')) {
            // trigger onchange if we're inside a filter/list-controller-component
            Promise.resolve().then(() => {
                this.onChange.emit(_value);
            });
        }
    }

    ngOnInit(): void {
        this.textMask.mask = [/[0-9]/, /[0-9]/, /[0-9]/, /[0-9]/, '-', /[0-9]/, /[0-9]/, '-', /[0-9]/, /[0-9]/];
    }

    ngOnChanges(): void {
        this.setDisplayValue();
    }

    /**
     * Set the displayValue (the value that's shown in the input field) from value
     * If the value is null, don't change the displayValue
     */
    setDisplayValue(): void {
        this.displayValue = this.value ? DateHelper.getStringFromDate(this.value, false) : '';
    }

    // Set touched on blur
    blur(): void {
        this._onTouchedCallback();
        this.onBlur.emit(this.value);
    }

    getPlaceholder(): string {
        return `<span>${this.displayValue.substring(0, this.displayValue.length)}</span>
            ${this.placeholder.substring(this.displayValue.length)}`;
    }

    // Triggers when user writes in input field
    setValueFromInput(): void {
        const inputValue = this.inputField.nativeElement.value;
        let newValue: moment.Moment | undefined;
        if (DateHelper.isValidDate(inputValue)) {
            if (this.value) {
                newValue = momentInstance(this.value);
            } else {
                newValue = momentInstance(inputValue);
            }
            if (this._hours > -1) {
                newValue.hour(this._hours);
                newValue.minute(this._minutes);
                newValue.second(this._seconds);
                newValue.millisecond(this._milliSeconds);
            } else {
                newValue = momentInstance(inputValue);
            }
            this._dateTimeService.date = newValue.toDate();
        }
        // We call the DateTimeService and set date to null if we have emptied the input field,
        // that way the date-time-picker will use current Date() when it opens
        // setting finalNewValue to undefined to trigger dateValidator (triggers when going from null to undefined)
        if (inputValue === '') {
            this._dateTimeService.date = null;
            newValue = undefined;
        }
        this.value = (typeof newValue === 'undefined') ? newValue : newValue.toDate();
        this._onChangeCallback(this.value);
    }

    // From ControlValueAccessor interface
    writeValue(date: any): void {
        this._value = date;
        if (DateHelper.isDateObj(date)) {
            this._hours = date.getHours();
            this._minutes = date.getMinutes();
            this._seconds = date.getSeconds();
            this._milliSeconds = date.getMilliseconds();
        }
        this._dateTimeService.date = date;
    }

    // From ControlValueAccessor interface
    registerOnChange(fn: any): void {
        this._onChangeCallback = fn;
    }

    // From ControlValueAccessor interface
    registerOnTouched(fn: any): void {
        this._onTouchedCallback = fn;
    }
}
