/* tslint:disable:directive-selector-name */
import {
    AfterViewInit, Directive, DoCheck, ElementRef, EventEmitter, HostBinding, HostListener, Input, OnChanges, OnDestroy,
    Output,
    Renderer2, SimpleChanges
} from '@angular/core';
import { DOMHelper } from '../../../core/helpers/dom.helper';
import { OverlayService } from '../../overlay/overlay.service';
import { OVERLAY_CONTEXT } from '../../overlay/overlay.constants';
import { FORM } from './../../../core/constants/form.constants';

@Directive({
    selector: '[cui-input],[cui-search]'
})

export class InputDirective implements AfterViewInit, OnChanges, DoCheck, OnDestroy {
    private iconBlurTimeout: any;
    private iconElement: HTMLSpanElement;
    private _hasFocus: boolean = false;
    label: HTMLLabelElement;
    value: string;
    iconTooltipElement: HTMLElement;
    eventListeners: Array<any> = [];
    @Output() iconClicked: EventEmitter<Event> = new EventEmitter();
    @Input() icon?: string;
    @Input() iconColor?: string;
    @Input() iconTooltip?: string;
    @Input() iconAlwaysVisible?: boolean = true;
    @HostBinding('class.cui-input') addClass: boolean = true;
    @HostBinding('class.no-transition') noTransition: boolean = true;
    @HostBinding('class.icon-blur') iconBlur: boolean = false;
    @HostBinding('class.has-value') get hasValue(): boolean {
        return this._element && this._element.nativeElement && !!this._element.nativeElement.value;
    }

    constructor(
        private _element: ElementRef,
        private _renderer: Renderer2,
        private _overlayService: OverlayService) {}

    ngOnChanges(changes: SimpleChanges): void {
        if (changes['icon'] || changes['iconColor'] || changes['iconTooltip'] || changes['iconAlwaysVisible']) {
            this.removeIconTooltip();
            this.removeIcon();
            this.createIconElement();
        }
    }

    /**
     * Create a character counter after the <label> if needed.
     * Also resize label to fit into the form element (when it's pretending to be a placeholder)
     */
    ngAfterViewInit(): void {

        const id: string = this._element.nativeElement.id;
        if (id) {
            this.label = <HTMLLabelElement> document.querySelector(`label[for='${id}']`);
        }
        if (!this.label) {
            const closest_label = <HTMLLabelElement> this._element.nativeElement.parentNode.querySelector('label');
            if (closest_label) {
                this.label = closest_label;
            }
        }
        if (this.label) {
            this.label.setAttribute('undefinedMessage', FORM.NO_FORM_VALUE);
        }
        this.createIconElement();
        this.selectRadioElement(false);
        Promise.resolve().then(() => {
            this.noTransition = false;
        });
    }

    /**
     * Function to create optional inline icon element
     */
    private createIconElement(): void {
        if (this.icon && this.label && !this.iconElement) {
            this._renderer.addClass(this._element.nativeElement, 'has-icon');
            this.iconElement = this._renderer.createElement('span');
            this._renderer.addClass(this.iconElement, 'inline-icon');
            this._renderer.addClass(this.iconElement, 'cui-icon');
            this._renderer.addClass(this.iconElement, 'small');
            this._renderer.addClass(this.iconElement, `icon-${this.icon}`);
            this._renderer.addClass(this.iconElement, 'align-right');
            if (this.iconColor) {
                this._renderer.setStyle(this.iconElement, 'color', this.iconColor);
            }

            this._renderer.insertBefore(this._renderer.parentNode(this.label), this.iconElement, this.label.nextSibling);
            this.eventListeners.push(this._renderer.listen(this.iconElement, 'click', this.iconClickedCallback.bind(this)));
            this.eventListeners.push(this._renderer.listen(this.iconElement, 'mousemove', this.createIconTooltip.bind(this)));
            this.eventListeners.push(this._renderer.listen(this.iconElement, 'mouseout', this.removeIconTooltip.bind(this)));
            Promise.resolve().then(() => {
                this.iconBlur = (this._hasFocus) ? false : !this.iconAlwaysVisible;
            });
        }
    }

    /**
     * Emit event when icon is triggered
     * And cancel timeout to prevent icon from beeing removed when input-focus is lost
     * @param {Event} event
     */
    private iconClickedCallback(event: Event): void {
        clearTimeout(this.iconBlurTimeout);
        this.iconClicked.emit(event);
        this._element.nativeElement.focus();
    }

    /**
     * Create inline icon and attach event listeners
     * @param {MouseEvent} event
     */
    private createIconTooltip(event: MouseEvent): void {
        if (!this.iconTooltip) {
            return;
        }
        if (!this.iconTooltipElement) {
            const innerDiv = this._renderer.createElement('div');
            const text = this._renderer.createText(this.iconTooltip);
            this.iconTooltipElement = this._renderer.createElement('div');

            this._renderer.addClass(innerDiv, 'cui-tooltip-text');
            this._renderer.appendChild(innerDiv, text);
            this._renderer.addClass(this.iconTooltipElement, 'cui-tooltip');
            this._renderer.setStyle(this.iconTooltipElement, 'opacity', '1');
            this._renderer.appendChild(this.iconTooltipElement, innerDiv);
            this._renderer.appendChild(
                this._overlayService.getOverlay(OVERLAY_CONTEXT.ROOT).element.nativeElement,
                this.iconTooltipElement
            );
        }
        this._renderer.setStyle(this.iconTooltipElement, 'top', `${event.pageY - 40}px`);
        this._renderer.setStyle(this.iconTooltipElement, 'left', `${event.pageX - 50}px`);
    }

    /**
     * Clean up icon and event listeners
     */
    private removeIcon(): void {
        this.eventListeners.forEach(listener => listener());
        this.eventListeners = [];
        if (this.iconElement) {
            this.iconElement.remove();
        }
        this.iconElement = null;
        this._renderer.removeClass(this._element.nativeElement, 'has-icon');
    }

    /**
     * clean up the icon tooltip
     */
    private removeIconTooltip(): void {
        if (this.iconTooltipElement) {
            this.iconTooltipElement.remove();
            this.iconTooltipElement = null;
        }
    }

    ngDoCheck() {
        if (this.value !== this._element.nativeElement.value) {
            this.value = this._element.nativeElement.value;
            DOMHelper.updateChartCounterValue(this._element);
        }
    }

    /**
     * On focus set active class to the input field's label tag if we find it via [for] attribute.
     * Otherwise add active class to closest label tag.
     */
    @HostListener('focus')
    addActive(): void {
        this._hasFocus = true;
        // Add ng-touched
        this._renderer.addClass(this._element.nativeElement, 'ng-touched');
        this.selectRadioElement();
        if (this.label) {
            this._renderer.addClass(this.label, 'active');
        } else {
            const closest_label = <HTMLLabelElement> this._element.nativeElement.parentNode.querySelector('label');
            if (closest_label) {
                this._renderer.addClass(closest_label, 'active');
            }
        }
        this.iconBlur = false;
    }

    /**
     * Check if we're inside a radiobutton's label, if so then make the radio button active
     * Click it per default, otherwise we add some css classes (this happens one time, in afterviewinit)
     * @param {Boolean} click
     */
    selectRadioElement(click: Boolean = true): void {
        const radios_label = DOMHelper.closestParentTag(this._element.nativeElement, 'label');
        if (radios_label) {
            let radio = <HTMLInputElement> document.getElementById(radios_label.getAttribute('for'));
            // "click" the radio (setting checked = true won't update models)
            if (!radio) {
                // find radio by checking previous sibling in DOM tree
                const previousElement = radios_label.previousElementSibling;
                if (previousElement && previousElement.classList.contains('cui-radio')) {
                    radio = previousElement;
                }
            }
            if (radio && radio.classList.contains('cui-radio')) {
                if (click) {
                    radio.click();
                } else {
                    this._renderer.addClass(this._element.nativeElement, 'next-to-radio');
                    this._renderer.addClass(radios_label, 'next-to-input');
                }
            }
        }
    }

    /**
     * On blur remove active class to the input field's label tag if we find it via [for] attribute.
     * Otherwise remove it from closest label tag.
     * If the iconBlur timeout is not canceled we did loos focus
     * but if the icon was clicked the timeout will be removed
     */
    @HostListener('blur')
    removeActive(): void {
        const id: string = this._element.nativeElement.id;
        let label: HTMLLabelElement;
        this._hasFocus = false;
        if (id) {
            label = <HTMLLabelElement> document.querySelector(`label[for='${id}']`);
        }
        if (id && label) {
            this._renderer.removeClass(label, 'active');
        } else {
            const closest_label = this._element.nativeElement.parentNode.querySelector('label');
            if (closest_label) {
                this._renderer.removeClass(closest_label, 'active');
            }
        }
        // We need to set this to enable the icon click event to fire before removing the icon
        this.iconBlurTimeout = setTimeout(() => {
            this.iconBlur = !this.iconAlwaysVisible;
        }, 100);
    }

    /**
     * Clean up event listeners
     */
    ngOnDestroy(): void {
        if (this.iconTooltipElement) {
            this.removeIconTooltip();
        }
        if (this.iconElement) {
            this.removeIcon();
        }
        if (this.iconBlurTimeout) {
            clearTimeout(this.iconBlurTimeout);
        }
    }
}
