import { TranslateService } from '@ngx-translate/core';
import {
    Component,
    ElementRef,
    Input,
    HostBinding,
    ViewEncapsulation,
    OnChanges,
    AfterViewInit,
    SimpleChanges,
    Renderer2, OnInit
} from '@angular/core';
import { STATE, COLOR } from '../../core/constants';
import { WhitelabelService } from '../../core/services';
import { COLORWHITELABEL } from '../../core/constants/color.whitelabel';
import { Subscription } from 'rxjs/Subscription';
import { ColorHelper } from '../../core/helpers/color.helper';

@Component({
    selector: 'cui-state-badge',
    templateUrl: './state-badge.component.html',
    styleUrls: ['./state-badge.component.scss'],
    encapsulation: ViewEncapsulation.None
})

export class StateBadgeComponent implements OnChanges, AfterViewInit, OnInit {
    @Input() state: STATE;
    @Input() extra: number = 0;
    @Input() tooltip: string = '';
    @Input() label: string;
    @Input() color: COLOR;
    @Input() semiTransparent: boolean = false;
    @Input() outlined: boolean = false;
    @Input() compact: boolean = false;
    active: boolean = false;
    stateLabel: string = '';
    private _subscriptions: Subscription[] = [];
    private _draftLabel: string = 'ODEN.COMMON.STATES.DRAFT';
    private _publishedLabel: string = 'ODEN.COMMON.STATES.PUBLISHED';
    private _customLabel: string = 'ODEN.COMMON.STATES.CUSTOM';
    private _okLabel: string = 'ODEN.COMMON.STATES.OK';
    private _warningLabel: string = 'ODEN.COMMON.STATES.WARNING';
    private _minorLabel: string = 'ODEN.COMMON.STATES.MINOR';
    private _majorLabel: string = 'ODEN.COMMON.STATES.MAJOR';
    private _criticalLabel: string = 'ODEN.COMMON.STATES.CRITICAL';
    private _validatedLabel: string = 'ODEN.COMMON.STATES.VALIDATED';
    private _validationLabel: string = 'ODEN.COMMON.STATES.VALIDATION';
    private _pausedLabel: string = 'ODEN.COMMON.STATES.PAUSED';
    private _terminatedLabel: string = 'ODEN.COMMON.STATES.TERMINATED';

    @HostBinding('class') get _class(): string {
        const stateText = this.stateToClass();
        return `cui-state-badge ${stateText}`;
    }

    constructor(public elementRef: ElementRef, private _renderer: Renderer2,
        translate: TranslateService,
        private _whitelabelService: WhitelabelService) {
        translate.stream([
            'ODEN.COMMON.STATES.DRAFT',
            'ODEN.COMMON.STATES.PUBLISHED',
            'ODEN.COMMON.STATES.CUSTOM',
            'ODEN.COMMON.STATES.OK',
            'ODEN.COMMON.STATES.WARNING',
            'ODEN.COMMON.STATES.MINOR',
            'ODEN.COMMON.STATES.MAJOR',
            'ODEN.COMMON.STATES.CRITICAL',
            'ODEN.COMMON.STATES.VALIDATED',
            'ODEN.COMMON.STATES.VALIDATION',
            'ODEN.COMMON.STATES.PAUSED',
            'ODEN.COMMON.STATES.TERMINATED'
        ]).subscribe(res => {
            this._draftLabel = res['ODEN.COMMON.STATES.DRAFT'];
            this._publishedLabel = res['ODEN.COMMON.STATES.PUBLISHED'];
            this._customLabel = res['ODEN.COMMON.STATES.CUSTOM'];
            this._okLabel = res['ODEN.COMMON.STATES.OK'];
            this._warningLabel = res['ODEN.COMMON.STATES.WARNING'];
            this._minorLabel = res['ODEN.COMMON.STATES.MINOR'];
            this._majorLabel = res['ODEN.COMMON.STATES.MAJOR'];
            this._criticalLabel = res['ODEN.COMMON.STATES.CRITICAL'];
            this._validatedLabel = res['ODEN.COMMON.STATES.VALIDATED'];
            this._validationLabel = res['ODEN.COMMON.STATES.VALIDATION'];
            this._pausedLabel = res['ODEN.COMMON.STATES.PAUSED'];
            this._terminatedLabel = res['ODEN.COMMON.STATES.TERMINATED'];

            this.stateLabel = this.getStateText();
        });
        this._subscriptions.push(this._whitelabelService._whitelabelingLoaded.subscribe(() => {
            this.mapStateColor();
        }));
    }

    ngOnInit(): void {
        this.stateLabel = this.getStateText();
    }

    ngAfterViewInit(): void {
        this.mapStateColor();
    }

    ngOnChanges(changes: SimpleChanges): void {
        if (changes['state'] && !changes['state'].firstChange) {
            this.mapStateColor();
        }
        if ((changes['color'] && !changes['color'].firstChange)
            || (changes['outlined'] && !changes['outlined'].firstChange)
            || (changes['semiTransparent'] && !changes['semiTransparent'].firstChange)) {
            this.setColor(this.color);
        }
        if ((changes['state'] && !changes['state'].firstChange) ||
            (changes['label'] && !changes['label'].firstChange)) {
            this.stateLabel = this.getStateText();
        }
    }

    /**
     * Gets a string representation for state, unless it has this.label and is not Published
     * @returns {string}
     */
    getStateText(): string {
        if (this.state !== STATE.PUBLISHED && this.label && this.label.length) {
            return this.label;
        }
        return this.stateAsText();
    }

    /**
     * Returns state as text
     * @returns {string}
     */
    stateAsText(): string {
        switch (this.state) {
            case STATE.DRAFT:
                return this._draftLabel;
            case STATE.VALIDATED:
                return this._validatedLabel;
            case STATE.VALIDATION:
                return this._validationLabel;
            case STATE.PUBLISHED:
                return this._publishedLabel;
            case STATE.CUSTOM:
                return this._customLabel;
            case STATE.OK:
                return this._okLabel;
            case STATE.WARNING:
                return this._warningLabel;
            case STATE.MINOR:
                return this._minorLabel;
            case STATE.MAJOR:
                return this._majorLabel;
            case STATE.CRITICAL:
                return this._criticalLabel;
            case STATE.PAUSED:
                return this._pausedLabel;
            case STATE.TERMINATED:
                return this._terminatedLabel;
            default:
                return null;
        }
    }

    /**
     * Returns state as css class name
     * @returns {string}
     */
    stateToClass(): string {
        switch (this.state) {
            case STATE.DRAFT:
                return 'state-draft';
            case STATE.VALIDATED:
                return 'state-validated';
            case STATE.VALIDATION:
                return 'state-validation';
            case STATE.PUBLISHED:
                return 'state-published';
            case STATE.CUSTOM:
                return 'state-custom-pill';
            case STATE.PAUSED:
                return 'state-paused';
            case STATE.TERMINATED:
                return 'state-terminated';
            default:
                return '';
        }
    }

    /**
     * Sets correct color for all different state
     */
    mapStateColor(): void {
        switch (this.state) {
            case STATE.OK:
                this.setColor(this._whitelabelService.getPropertyValue(COLORWHITELABEL.SUCCESS));
                return;
            case STATE.WARNING:
                this.setColor(this._whitelabelService.getPropertyValue(COLORWHITELABEL.NOTICE));
                return;
            case STATE.MINOR:
                this.setColor(this._whitelabelService.getPropertyValue(COLORWHITELABEL.WARNING));
                return;
            case STATE.MAJOR:
                this.setColor(this._whitelabelService.getPropertyValue(COLORWHITELABEL.ERROR));
                return;
            case STATE.CRITICAL:
                this.setColor(this._whitelabelService.getPropertyValue(COLORWHITELABEL.CRITICAL));
                return;
            default:
                this.setColor(this.color);
                return;
        }
    }

    /**
     * Sets color for pill
     * @param color
     */
    setColor(color): void {
        if (this.state === STATE.DRAFT || this.state === STATE.PUBLISHED || this.state === STATE.VALIDATED
            || this.state === STATE.VALIDATION || this.state === STATE.PAUSED || this.state === STATE.TERMINATED) {
            return;
        }
        if ( this.state === STATE.CUSTOM) {
            [].forEach.call(this.elementRef.nativeElement.querySelectorAll('span'), (el) => {
                if (el) {
                    this._renderer.setStyle(el, 'border-color', color);

                    if (this.outlined && STATE.CUSTOM) {
                        this._renderer.removeStyle(el, 'background-color');
                        this._renderer.setStyle(el, 'color', color);
                    } else {
                        const setColor = this.semiTransparent ? ColorHelper.hexToRGB(color, 0.5) : color;
                        this._renderer.setStyle(el, 'border-color', 'transparent');
                        this._renderer.setStyle(el, 'background-color', setColor);
                        // @TODO color not defined yet
                        this._renderer.setStyle(el, 'color', color === COLOR.WHITE ? COLOR.BLACK : COLOR.WHITE);                    }
                }
            });
        }
    }

    /**
     * Converts rgb color to rgba with 0.5 alpha
     * @param rgb
     * @returns {string}
     */
    getRGBColorWithOpacity(rgb): string {
        return 'rgba(' + rgb.replace(/[rgb()\s]/g, '') + ',.5)';
    }
}
