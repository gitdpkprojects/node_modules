import { ComponentFactoryResolver, ComponentRef, Injectable } from '@angular/core';
import { OverlayService } from '../overlay/overlay.service';
import { SnackBarComponent } from './snack-bar.component';
import { ActionItem } from '../../core/models/action-item.model';
import { Subscription } from 'rxjs/Subscription';
import { UnSub } from '../../core/classes';

@Injectable()
@UnSub()
export class SnackBarService {
    private _snackBars: ComponentRef<SnackBarComponent>[] = [];
    private _subscriptions: Array<Subscription> = [];

    constructor(
        private componentFactoryResolver: ComponentFactoryResolver,
        private _overlayService: OverlayService) {
    }

    /**
     * Creates and displays a snack bar in a view.
     * @param message { string } - Message to be displayed in snack bar
     * @param actionItem { ActionItem } - ActionItem for dispatch custom event.
     * @param stickToElement { HTMLEelement } - HTML element that the snackbar should stick to (display just above and beneath)
     * @return snackBar.instance { SnackBarComponent } - Snack bar instance
     */
    open(message: string, actionItem?: ActionItem, stickToElement?: HTMLElement, autoClose: boolean = true): SnackBarComponent {
        const factory = this.componentFactoryResolver.resolveComponentFactory(SnackBarComponent);
        const snackBar = this._overlayService.containerRef.createComponent(factory);
        snackBar.instance.stickToElement = stickToElement ? stickToElement : null;
        snackBar.instance.autoClose = autoClose;
        snackBar.instance.open(message, actionItem);

        this._subscriptions.push(snackBar.instance.onClose.subscribe(() => {
            this._removeSnackBar(snackBar);
        }));

        const nmb_snackbars = this._snackBars.length;

        // Remove excessive snackbars (only one snackbar allowed at once)
        if (nmb_snackbars >= 1) {
            for (let i = 0; i <= (nmb_snackbars - 1); i++) {
                this._removeSnackBar(this._snackBars[i]);
            }
            // Let the old ones get removed before we show the new one
            setTimeout(() => {
                snackBar.instance.show();
            }, 500);
        }

        this._snackBars.push(snackBar);

        if (nmb_snackbars < 1) {
            // Timeout to make transition work
            setTimeout(() => {
                snackBar.instance.show();
            }, 0);
        }

        return snackBar.instance;
    }

    /**
     * Returns the index of a snack bar in overlay container ref
     * @param snackBar
     * @returns {number}
     * @private
     */
    private _getSnackBarIndex(snackBar: ComponentRef<SnackBarComponent>): number {
        return this._overlayService.containerRef.indexOf(snackBar.hostView);
    }

    /**
     * Removes internal snack bar ref as well as from the view.
     * @param snackBar
     * @private
     */
    private _removeSnackBar(snackBar): void {
        const _getSnackBarIndex = this._getSnackBarIndex(snackBar);
        if (_getSnackBarIndex > -1) {
            this._overlayService.containerRef.remove(_getSnackBarIndex);
            const index = this._snackBars.indexOf(snackBar);
            if (index > -1) {
                this._snackBars.splice(index, 1);
            }
        }
        this._subscriptions.forEach((sub: Subscription) => {
            sub.unsubscribe();
        });
    }
}
