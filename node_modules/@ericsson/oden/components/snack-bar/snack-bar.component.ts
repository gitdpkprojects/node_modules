import { AfterViewInit, Component, EventEmitter, HostBinding, OnDestroy, ViewEncapsulation, NgZone } from '@angular/core';
import { ActionItem } from '../../core/models/action-item.model';
import { SNACK_BAR } from './snack-bar.constants';
import { OverlayService } from '../overlay/overlay.service';
import { ACTIONS } from '../../core/constants/actions.constants';

@Component({
    selector: 'cui-snack-bar',
    templateUrl: 'snack-bar.component.html',
    styleUrls: ['snack-bar.component.scss'],
    encapsulation: ViewEncapsulation.None,
    animations: SNACK_BAR.SNACK_BAR_ANIMATION
})

export class SnackBarComponent implements AfterViewInit, OnDestroy {
    public onClose: EventEmitter<SnackBarComponent> = new EventEmitter<SnackBarComponent>();
    public onAction: EventEmitter<ActionItem> = new EventEmitter<ActionItem>();
    public buttonAction: ActionItem;
    public text: string;
    public autoClose: boolean = true; // If false, snackbar wont be auto closed
    public stickToElement?: HTMLElement;

    private _timer: any;
    private _interval: any;

    @HostBinding('class.cui-snack-bar') addClass: boolean = true;
    @HostBinding('style.z-index') zIndex: number = 0;
    @HostBinding('style.bottom') bottomPosition: string = '0px';
    @HostBinding('@visibility') visibility = 'hidden';

    constructor(private _overlayService: OverlayService, private _zone: NgZone) {
        this.onAction.subscribe((actionItem) => {
            if (actionItem.action === ACTIONS.CLOSE) {
                this.close();
            }
        });
    }

    /**
     * Starts close timer
     */
    ngAfterViewInit() {
        if (this.autoClose) {
            this._zone.runOutsideAngular(() => {
                this._timer = setTimeout(() => {
                    this._zone.run(() => {
                        this.close();
                    });
                }, 7000);
            });
        }
    }

    /**
     * Clear the timeout and closes this snack bar.
     */
    close(): void {
        clearInterval(this._interval);
        if (this._timer) {
            clearTimeout(this._timer);
        }
        this.visibility = 'hidden';
        this.onClose.emit(this);
    }

    ngOnDestroy(): void {
        this.close();
    }

    /**
     * Sets snack bar message
     * @param msg
     * @param actionItem
     */
    open(msg: string, actionItem: ActionItem): void {
        this.text = msg;
        this.buttonAction = actionItem;
    }

    /**
     * Shows the snackbar (and puts it above an element if provided)
     */
    show(): void {
        this.visibility = 'visible';
        this.zIndex = this._overlayService.highestZindex;
        // Align the snackbar to stickToElement if present
        if (this.stickToElement) {
            // if stickToElement, stick it just below the element zIndex wise!
            this.zIndex = parseInt(this.stickToElement.style.zIndex, 10) - 1;
            this._interval = setInterval(() => {
                if (this.stickToElement && this.visibility === 'visible') {
                    // get the transformY if there is one to apply to the
                    const style = window.getComputedStyle(this.stickToElement);
                    const matrix = new WebKitCSSMatrix(style.webkitTransform);
                    let translateY = 0;
                    if (matrix && matrix.f) {
                        translateY = matrix.f;
                    }
                    this.bottomPosition = (parseInt(window.getComputedStyle(this.stickToElement).height, 10) - translateY) + 'px';
                }
            }, 10);
        }
    }

    /**
     * Click callback from actionButton in view.
     */
    actionClicked(): void {
        this.onAction.emit(this.buttonAction);
    }

}
