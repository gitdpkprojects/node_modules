import {
    AfterViewInit,
    Component,
    ComponentFactoryResolver,
    ComponentRef,
    ElementRef,
    EventEmitter,
    HostBinding,
    Input,
    OnDestroy,
    Output,
    Renderer2,
    ViewContainerRef,
    ViewEncapsulation,
    TemplateRef,
    ViewChild,
    OnInit
} from '@angular/core';
import { ELEMENT_OVERLAY_STATE } from '../../../core/constants/element-overlay-state.constants';
import { ActionItem } from '../../../core/models/action-item.model';
import { DOMHelper } from '../../../core/helpers/dom.helper';
import { IElementOverlayConfig } from '../../../core/interfaces/element-overlay-config.interface';
import { LoaderComponent } from '../../loader/loader.component';
import { ResizeService } from '../../../core/services/resize.service';
import { Subscription } from 'rxjs';

@Component({
    selector: 'cui-element-error-overlay',
    templateUrl: './error-overlay.component.html',
    styleUrls: ['./error-overlay.component.scss'],
    encapsulation: ViewEncapsulation.None
})

export class ElementErrorOverlayComponent implements OnDestroy, AfterViewInit, OnInit {
    @ViewChild('defaultTemplate', {read: TemplateRef}) defaultTemplate;
    @HostBinding('class.cui-element-error-overlay') addClass: boolean = true;
    @HostBinding('class.hidden') get hidden(): boolean {
        return this.overlayConfig.state === ELEMENT_OVERLAY_STATE.NONE ||
            this.overlayConfig.state === ELEMENT_OVERLAY_STATE.LOADING;
    }
    @HostBinding('class.inline-overlay') get inlinePlaceholder(): boolean {
        return this.overlayConfig.inlinePlaceholder;
    }
    // tslint:disable-next-line:no-input-rename
    @Input('overlayConfig') overlayConfig: IElementOverlayConfig;
    @HostBinding('attr.data-state') get state(): ELEMENT_OVERLAY_STATE {
        if (this._lastState !== undefined && this._lastState !== this.overlayConfig.state) {
            this.stateChanged();
            this._lastState = this.overlayConfig.state;
        }
        return this.overlayConfig.state;
    }
    @Output() onActionClick: EventEmitter<ActionItem> = new EventEmitter<ActionItem>();
    private _parentElement: HTMLElement;
    private _parentElementOldHeight: string;
    private _lastState: number;
    private _componentRef: ComponentRef<any>;
    private _subscriptions: Array<Subscription> = [];

    constructor(public element: ElementRef, private _renderer: Renderer2,
                private _viewContainerRef: ViewContainerRef,
                private _componentFactoryResolver: ComponentFactoryResolver,
                private _resizeService: ResizeService) {
    }

    get template(): TemplateRef<any> {
        return this.overlayConfig.textTemplate || this.defaultTemplate;
    }

    ngOnInit(): void {
        this._subscriptions.push(
            this._resizeService.resize$.subscribe(() => this._onResize())
        );
    }

    ngAfterViewInit(): void {
        // check if parentElement happens to have a custom inline style height already
        this._parentElement = this.element.nativeElement.parentElement;
        if (this._parentElement && this._parentElement.style.height !== '') {
            this._parentElementOldHeight = this._parentElement.style.height;
        }
        this._lastState = this.overlayConfig.state;
        if (this.overlayConfig.state === ELEMENT_OVERLAY_STATE.LOADING) {
            Promise.resolve().then(() => {
                this.fixLoadingComp();
            });
        } else {
            if (this.overlayConfig.state !== ELEMENT_OVERLAY_STATE.NONE) {
                Promise.resolve().then(() => {
                    this.fixHeights();
                });
            }
        }
    }

    private _onResize() {
        this.fixHeights();
    }

    /**
     * Take care of stuff when the state changes.
     */
    stateChanged(): void {
        if (this._componentRef) {
            this._componentRef.destroy();
            this._componentRef = null;
        }
        switch (this.overlayConfig.state) {
            case ELEMENT_OVERLAY_STATE.LOADING:
                this.fixLoadingComp();
                break;
            case ELEMENT_OVERLAY_STATE.NONE:
                this.removeStyle();
                break;
            default:
                Promise.resolve().then(() => {
                    this.fixHeights();
                });
                break;
        }
    }

    /**
     * Create the loading component if state is LOADING
     */
    fixLoadingComp(): void {
        if (this._componentRef) {
            this._componentRef.destroy();
            this._componentRef = null;
        }
        Promise.resolve().then(() => {
            const factory = this._componentFactoryResolver.resolveComponentFactory(LoaderComponent);
            this._componentRef = this._viewContainerRef.createComponent(factory);
            this._componentRef.instance.visible = true;
            this._componentRef.instance.overlayConfig = this.overlayConfig;
        });
    }

    /**
     * Set proper heights on both the overlay element and the parent element (the wrapper)
     */
    fixHeights(): void {
        this._parentElement = this.element.nativeElement.parentElement;
        this._renderer.removeClass(this._parentElement, 'error-overlay-wrapper');
        this._renderer.removeClass(this._parentElement, 'display-block');

        // Apply position: relative and display: block to parent element
        // This is necessary to avoid having the overlay fill up more space than it should.
        if (!this.inlinePlaceholder) {
            this._renderer.addClass(this._parentElement, 'error-overlay-wrapper');
        }
        if (window.getComputedStyle(this._parentElement).getPropertyValue('display') === 'inline') {
            this._renderer.addClass(this._parentElement, 'display-block');
        }

        const parentElementHeight = DOMHelper.getOuterHeight(this._parentElement);
        const highestChild: number = DOMHelper.getHeighestChild(this._parentElement);

        const overlayHeight: number = Math.max(parentElementHeight, highestChild);

        if (overlayHeight > 0 && !this.inlinePlaceholder) {
            // Is the overlay larger than the parent (overflow)? Then grow the parent to same height.
            if (overlayHeight > parentElementHeight) {
                this._renderer.setStyle(this._parentElement, 'height', `${overlayHeight}px`);
            }
            this._renderer.setStyle(this.element.nativeElement, 'height', `${overlayHeight}px`);
        }
    }

    /**
     * Remove all styling created by this component.
     */
    removeStyle(): void {
        if (this._parentElement) {
            this._renderer.removeClass(this._parentElement, 'error-overlay-wrapper');
            this._renderer.removeClass(this._parentElement, 'display-block');
            this._renderer.removeStyle(this._parentElement, 'height');
            if (this._parentElementOldHeight) {
                this._renderer.setStyle(this._parentElement, 'height', this._parentElementOldHeight);
            }
        }
    }

    /**
     * Restore parent element on destroy.
     */
    ngOnDestroy(): void {
        this.removeStyle();
        if (this._componentRef) {
            this._componentRef.destroy();
            this._componentRef = null;
        }
        this._subscriptions.forEach(subscription => subscription.unsubscribe());
    }

    /**
     * True if actions are present.
     */
    hasActions(): boolean {
        return typeof (this.overlayConfig.actions) !== 'undefined' && this.overlayConfig.actions.length > 0;
    }

    /**
     * True if state is system error
     */
    isSystemError(): boolean {
        return this.overlayConfig.state === ELEMENT_OVERLAY_STATE.SYSTEM_ERROR;
    }

    /**
     * True if state is error
     */
    isError(): boolean {
        return this.overlayConfig.state === ELEMENT_OVERLAY_STATE.ERROR;
    }

    /**
     * True if state is system error or error
     */
    isAnyError(): boolean {
        return this.isSystemError() || this.isError();
    }

    /**
     * Emits the onActionClick EventEmitter
     * @param action
     */
    actionClick(action: ActionItem): void {
        this.onActionClick.emit(action);
    }
}
