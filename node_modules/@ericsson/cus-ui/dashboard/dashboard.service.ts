import { Injectable, Inject, InjectionToken } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Widget } from './widget/widget.model';
import { Observable } from 'rxjs';
import { WidgetConfigHelper } from './helpers/widget-config.helper';
import * as _ from 'lodash';

export const WIDGETSET_URL = new InjectionToken<string>('widgetset_url');

@Injectable()
export class DashboardService {
  private _configStore: Map<string, Array<Widget>> = new Map();
  public _dashboardDataCache: Widget[];
  constructor(private http: HttpClient,
    @Inject(WIDGETSET_URL) public widgetSetUrl: any) { }

  /**
   * Gets widget data from REST
   * @return {Observable<Widget[]>}
   */
  getWidgets(): Observable<Widget[]> {
    return new Observable<Widget[]>((observer) => {
      if (this._dashboardDataCache && this._dashboardDataCache.length > 0) {
        observer.next(this._dashboardDataCache);
      } else {
        this.http.get<Widget[]>(this.widgetSetUrl)
          .map((widgets) => this.extract(widgets))
          .subscribe((result: Widget[]) => {
            observer.next(result);
          })
      }
    });
  }

  get widgetConfigs() {
    return this._configStore;
  }

  /**
   * Groups the configs and stores in the config store cache.
   * @param data
   */
  private extract(data: Widget[]) {
    let widgetConfigs = this.groupConfigs(data);
    this._dashboardDataCache = widgetConfigs;
    return widgetConfigs;
  }

  /**
   * Function that groups the widget response based on name and widget type.
   * It converts the widget config into a map with key widget-name#widget-type.
   * If there are multiple widgets with same widget name and widget type, Only the datamapping.
   * with higher priroty is added to the configuration.
   * Merging of configurations happen in the widget component based on the chart type.
   */
  private groupConfigs(configs: Widget[]) {
    let mergedConfig: Widget[] = [];
    let groupedConfigs = _.groupBy(configs, (config) => [config.name.toLowerCase(), config.containers[0].sets[0].type.toLowerCase()]);
    Object.keys(groupedConfigs).forEach(key => {
      let groupKey = groupedConfigs[key][0].name.toLowerCase() + '#' + groupedConfigs[key][0].containers[0].sets[0].type.toLowerCase();
      groupedConfigs[key].forEach((widget) => {
        widget.groupKey = groupKey;
        widget.containers.forEach((container) => {
          container.sets.forEach((widgetSet) => {
            widgetSet.groupKey = groupKey;
          })
        });
      });
      this._configStore.set(
        groupKey,
        groupedConfigs[key].sort((a, b) => a.priority - b.priority))
    });

    // Merge the configs based on widget type and push the merged configs.
    this._configStore.forEach((item) => {
      if (item && item.length > 0) {
        if (item[0].containers[0].sets[0].type === 'table' || item[0].containers[0].sets[0].type === 'stackedbarchart'
          || item[0].containers[0].sets[0].type === 'bco') {
          mergedConfig.push(new Widget(WidgetConfigHelper.mergeConfigs(item)));
        } else {
          item.forEach(widget => {
            mergedConfig.push(widget);
          })
        }
      }
    });
    return mergedConfig;
  }
}
