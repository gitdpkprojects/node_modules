import { Component, OnInit, Injectable } from '@angular/core';
import { DashboardService } from './dashboard.service';
import { Widget } from './widget/widget.model';
import { Helpers } from './helpers/helpers';
import { TranslationService } from '../i18n';
import { BCOService, BCOConfigurationService } from './widget/bco';
import { UniversalTabView, TabViewService, TAB_VIEW } from '@ericsson/oden';
import { ActivatedRoute } from '@angular/router';

@Component({
  selector: 'cus-dashboard',
  styleUrls: ['dashboard.component.scss'],
  templateUrl: './dashboard.component.html',
  providers: [BCOService, BCOConfigurationService],
  animations: [TAB_VIEW.ANIMATION]
})

@Injectable()
export class DashboardComponent extends UniversalTabView implements OnInit {

  widgets: Widget[];
  private errorText: string;
  private errorType: string;

  constructor(private _dashboardService: DashboardService,
    private translate: TranslationService,
    tabViewService: TabViewService,
    activatedRoute: ActivatedRoute) {
    super(tabViewService, activatedRoute);
  }

  ngOnInit(): void {
    this.getWidgetData();
  }

  /**
   Method that subscribes for loading widgets in dashboard
   */
  getWidgetData() {
    this._dashboardService.getWidgets()
      .subscribe((data) => {
        if (data.length === 0) {
          this.errorType = 'noDataError';
        }
        let widgets = data.map((widget) => new Widget(widget));
        widgets.sort(this.sort);
        this.populateWidgetTypes(widgets);
        this.widgets = widgets;
      },
        (error) => {
          this.errorType = 'serverError';
          let errorText = Helpers.getErrorText(error);
          errorText = errorText.length > 0 ? `${errorText},` : '';
          this.errorText = this.translate.instant('com.ericsson.bss.rm.cus.dashboard.error_message', { errorText: errorText });
        });
  }
  /**
   * Sort Widgets By Priority
   * @param a
   * @param b
   */
  private sort(a, b) {
    if (a.priority === b.priority) {
      if (a.title < b.title) {
        return -1;
      }
      if (a.title > b.title) {
        return 1;
      }
      return 0;

    }
    return a.priority - b.priority;
  }
  /**
   * consolidate widget types in widget container
   * @param widget
   */
  populateWidgetTypes(widgets: Widget[]): void {
    widgets.forEach(widget => {
      widget.type = '';
      widget.containers.forEach(container => {
        container.sets.forEach(set => {
          widget.type += widget.type ? (' ' + set.type) : set.type;
        })
      })
    })
  }

}
