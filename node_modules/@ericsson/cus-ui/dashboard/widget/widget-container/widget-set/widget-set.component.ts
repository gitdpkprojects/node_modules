import {
  Component,
  ViewContainerRef,
  ComponentFactoryResolver,
  ComponentFactory,
  OnInit,
  OnDestroy,
  ComponentRef,
  ViewChild, ViewEncapsulation, HostBinding, AfterViewInit,
  EventEmitter
} from '@angular/core';
import {
  PieChartComponent,
  BarChartComponent,
  GaugeChartComponent,
  LineChartComponent,
  SimpleComponent,
  ProgressBarComponent,
  RainbowChartComponent,
  StackedBarChartComponent
} from '@ericsson/oden/modules';
import { WidgetSet } from './widget-set.model';
import { Input } from '@angular/core';
import { Subscription } from 'rxjs';
import { WidgetService } from '../../widget.service';
import { WidgetMapping } from '../../../helpers/widget-mapping.helper';
import { Helpers } from '../../../helpers/helpers';
import { ListComponent } from '../../list/list.component';
import { BCOComponent } from '../../bco';
import { EnhancedTableComponent } from '../../enhanced-table';

@Component({
  selector: 'cus-widget-set',
  styleUrls: ['widget-set.scss'],
  templateUrl: 'widget-set.component.html',
  encapsulation: ViewEncapsulation.None
})

export class WidgetSetComponent implements OnInit, AfterViewInit, OnDestroy {
  @HostBinding('class.cus-widget-set') addClass: boolean = true;
  @ViewChild('container', { read: ViewContainerRef }) container;
  @Input() set: WidgetSet;
  @Input() color: string = '#FF0000';
  private _component: ComponentRef<any>;
  private onSelectEvent: EventEmitter<any> = new EventEmitter<any>();
  private subscription: Subscription = new Subscription();
  private dataSubscription: any;
  constructor(private _widgetService: WidgetService, private _componentFactoryResolver: ComponentFactoryResolver) { }

  ngOnInit() {
    const factory = this.createWidgetFactory(this.set.type, this.set.groupKey);
    this._component = this.container.createComponent(factory);
    if (this.set.type !== 'bco' && this.set.type !== 'table') {
      this.addSelectorEventEmitter();
      this.loadData();
    }
  }

  private loadData() {
    // Get widget data from widgetService.
    this.dataSubscription = this._widgetService.data.subscribe((data) => {

      if (!data) {
        return;
      }
      // Get mapped data for specific component and sets data.
      let componentData = WidgetMapping.mapDataFor(this.set, data, this.color);
      Helpers.mergeObjects(this._component.instance, componentData);
      if (this._component.instance.reload && typeof this._component.instance.reload === 'function') {
        this._component.instance.reload();
      }
      this._component.changeDetectorRef.detectChanges();
    });
  }

  /**
   * Called everytime the selector value is changed
   * @param key
   */
  private onSelectorChange(key) {
    let dataSet = this.getDataSet(key, this.set);
    this._widgetService.widget.currentApi = Helpers.replaceTokens(dataSet.path, { key: key });
    this.set.currentData = dataSet.data;
    this._widgetService.setDataSource(this._widgetService.widget);
    this.dataSubscription.unsubscribe();
    this.loadData();
  }

  private getDataSet(key: string, set: WidgetSet): any {
    if (set && set.dataSet && set.dataSet.length > 0) {
      let dataSet;
      dataSet = set.dataSet.find(value => {
        return value.key === key;
      });
      if (dataSet) {
        return dataSet;
      } else if (!dataSet && set.dataSet.length > 0) {
        dataSet = set.dataSet[0];

      }
      return dataSet;
    }
  }

  /**
  * Adds an event listner for the set if selector addon is present
  * @param set
  */
  private addSelectorEventEmitter() {
    // add an event emitter for each selector addon
    if (this.set.addons) {
      this.set.addons.forEach(item => {
        if (item && item.type === 'selector') {
          item.emitEvent = this.onSelectEvent;
        }
      });
    }
    let sub = this.onSelectEvent.subscribe(value => {
      this.onSelectorChange(value.data.key);
    });
    this.subscription.add(sub);
  }

  /**
   *SVG charts tend to overflow, let's make sure they don't
   */
  ngAfterViewInit(): void {
    if (this.set.type === 'piechart' && this._component) {
      let height = this._component.location.nativeElement.offsetHeight;
      if (height > 290) {
        let matches = this._component.location.nativeElement.querySelectorAll('svg');
        for (let i = 0; i < matches.length; i++) {
          matches[i].style.maxHeight = '290px';
        }
      }
    }

    if (this.set.type === 'table') { // set the selected columns count for TableComponent
      this._component.instance.selectedColumns = this._component.instance.headers.filter(h => !h.hidden);
    }
  }

  /**
   * Creates and returns a component factory based on set type.
   * @param type: string
   * @return {ComponentFactory<any>}
   */
  createWidgetFactory(type: string, groupKey?: string): ComponentFactory<any> {
    const componentTypes = {
      'bco': BCOComponent,
      'piechart': PieChartComponent,
      'barchart': BarChartComponent,
      'gaugechart': GaugeChartComponent,
      'linechart': LineChartComponent,
      'table': EnhancedTableComponent,
      'simple': SimpleComponent,
      'progress': ProgressBarComponent,
      'list': ListComponent,
      'rainbowchart': RainbowChartComponent,
      'stackedbarchart': StackedBarChartComponent
    };

    let componentFactory = componentTypes[groupKey];
    if (!componentFactory) {
      componentFactory = componentTypes[type];
    }

    if (componentFactory === undefined) {
      throw new Error(`Type ${type} is not a known component type.`);
    } else {
      return this._componentFactoryResolver.resolveComponentFactory(componentFactory);
    }
  }

  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
}
