import { Injectable, EventEmitter } from '@angular/core';
import { Observable, Subject } from 'rxjs';
import { BCOModel, BCOChartData, BCOMainMenuRoute } from '../bco.model';
import { MainMenuService } from '../../../../common/services';
import { BCOConfigurationService } from './bco.configuration.service';
import { TYPE } from '../bco.constants';
import { Widget } from '../../widget.model';
import { HttpErrorResponse } from '@angular/common/http';
import * as _ from 'lodash';

@Injectable()
export class BCOService {
    private _activeArea: BCOChartData;
    private _activeApp: BCOChartData;
    private _activeEntity: BCOChartData;
    private _entitiesValueSet: Array<BCOModel>; // stores entityName and value response using getters and setters
    private _entitiesValueSetSubject: Subject<Array<BCOModel>>;
    private _entitiesChartData: Array<BCOChartData> = [];
    private _entitiesChartDataSubject: Subject<Array<BCOChartData>>;
    private _entitiesChartDataContainer: Array<BCOChartData>;
    private _appChartData: Array<BCOChartData> = [];
    private _appChartDataSubject: Subject<Array<BCOChartData>>;
    private _appChartDataContainer: Array<BCOChartData>;
    private _areaChartData: Array<BCOChartData> = [];
    private _areaChartDataSubject: Subject<Array<BCOChartData>>;
    private _areaChartDataContainer: Array<BCOChartData>;
    private _widgetConfig: Widget;

    allArea: Array<BCOMainMenuRoute>; // placeholder to store all groups
    allApplication: Array<BCOMainMenuRoute>; // place holder to store all applications
    allEntity: Array<BCOMainMenuRoute>; // placeholder to store all entities

    entitiesValueSet$: Observable<Array<BCOModel>>;
    entitiesChartData$: Observable<Array<BCOChartData>>;
    appChartData$: Observable<Array<BCOChartData>>;
    areaChartData$: Observable<Array<BCOChartData>>;
    onActiveAreaChange$: EventEmitter<BCOChartData> = new EventEmitter<BCOChartData>();
    onActiveAppChange$: EventEmitter<BCOChartData> = new EventEmitter<BCOChartData>();

    constructor(private _mainMenuService: MainMenuService,
        private _bcoConfigurationService: BCOConfigurationService) {

        this._entitiesValueSetSubject = new Subject<Array<BCOModel>>();
        this._entitiesChartDataSubject = new Subject<Array<BCOChartData>>();
        this._appChartDataSubject = new Subject<Array<BCOChartData>>();
        this._areaChartDataSubject = new Subject<Array<BCOChartData>>();
        this.entitiesValueSet$ = this._entitiesValueSetSubject.asObservable();
        this.entitiesChartData$ = this._entitiesChartDataSubject.asObservable();
        this.appChartData$ = this._appChartDataSubject.asObservable();
        this.areaChartData$ = this._areaChartDataSubject.asObservable();
    }
    /**
     * loads charts
     */
    public loadCharts(): void {
        // subcribes to mainmenu service and extracts areas/applications/entites from response
        this._mainMenuService.getRoutes().subscribe((routes: BCOMainMenuRoute[]) => {
            // sort the routes based on priority to maintain the same order in main menu and BCO Chart
            if (routes.length === 0) { // if routes is empty dont render BCO
                this.entitiesValueSet = [];
                return;
            }
            let sortedRoutes = this._mainMenuService.sort_routes(routes);
            this.allEntity = this.filterRoutes(sortedRoutes, TYPE.ENTITY);
            this.allApplication = this.filterRoutes(sortedRoutes, TYPE.APP);
            this.allArea = this.filterRoutes(sortedRoutes, TYPE.AREA);
            setTimeout(() => { // setting this delay to avoid deselection of default selection
                this.getBusinessConfigurationOverview();
            }, 1000)
        });
    }
    /**
     * subcribes to business configuration response
     * and populate charts
     */
    private getBusinessConfigurationOverview(): void {
        // subscribe to entities value
        this._bcoConfigurationService.getBusinessConfigurationOverview(this.widgetConfig)
            .subscribe(response => {
                this.entitiesValueSet = response;
                // dont change the order
                this.populateEntitesChartData();
                this.populateAppChartData();
                this.populateAreaChartData();
            }, (error) => {
                this.entitiesValueSet = error;
            });
    }
    /**
     * populate entitites chart data for all the entites
     * and map value by comparing with response's entites value
     */
    private populateEntitesChartData(): void {
        if (!this._entitiesChartDataContainer) { // make sure this loads once
            this._entitiesChartDataContainer = this.allEntity
                .filter(entity => { // show entities only if it has data mapping
                    return _.findIndex(this.entitiesValueSet, { 'configName': entity.configName }) > -1 ? true : false;
                })
                .map((entity) => {
                    return new BCOChartData({
                        label: entity.label,
                        value: this.mapValue(entity.configName, 'entity'),
                        key: entity,
                        link: entity.path,
                        externalApp: entity.externalApp
                    })
                });
        }
        // filter what data needs to be displayed
        this.entitiesChartDataStream = this._entitiesChartDataContainer.filter(entity => {
            if (this.activeApp) {
                return entity.key.parentApp === this.activeApp.key.applicationName;
            }
            // if active application is not available, then assume first entity's parent app as active app
            return entity.key.parentApp === this._entitiesChartDataContainer[0].key.parentApp
        });

    }
    /**
     * populate application chart data for all the application
     * and map value by comparing with entites parentapp name
     */
    private populateAppChartData(selectedApp?: any): void {
        if (!this._appChartDataContainer) { // make sure this loads once
            this._appChartDataContainer = this.allApplication
                .filter(application => { // show application if it has min 1 entites
                    return _.findIndex(this._entitiesChartDataContainer, (entities) => {
                        return entities.key.parentApp === application.applicationName
                    }) > -1 ? true : false;
                })
                .map(app => {
                    return new BCOChartData({
                        label: app.label,
                        value: this.mapValue(app.applicationName, 'app'),
                        key: app
                    })
                })
        }
        this.appChartDataStream = this._appChartDataContainer
            .filter((application) => { // filter based on activeArea
                if (this.activeArea) {
                    return application.key.parentGroup.toLowerCase() === this.activeArea.key.groupName.toLowerCase();
                }
                // if active area is not available, then assume first app's parent group as active group
                return application.key.parentGroup.toLowerCase() === this._appChartDataContainer[0].key.parentGroup.toLowerCase();
            }).map((application, index) => {
                application.selected = this.checkIfActive(selectedApp, application, index);
                return application;
            });
        // sets activeApp
        this.activeApp = this.appChartDataStream.find(appChart => {
            return appChart.selected;
        });
    }
    /**
     * populate area chart data for all the areas
     * and map value by comparing with app's parent group name
     */
    private populateAreaChartData(selectedArea?: any): void {
        if (!this._areaChartDataContainer) { // make sure this loads once
            this._areaChartDataContainer = this.allArea
                .filter(area => { // show area if it has min 1 application
                    return _.findIndex(this._appChartDataContainer, (app) => {
                        return app.key.parentGroup.toLowerCase() === area.groupName.toLowerCase()
                    }) > -1 ? true : false;
                }).map((area) => {
                    return new BCOChartData({
                        label: area.label,
                        value: this.mapValue(area.groupName, 'area'),
                        key: area
                    })
                })
        }
        this.areaChartDataStream = this._areaChartDataContainer.map((area, index) => {
            area.selected = this.checkIfActive(selectedArea, area, index);
            return area;
        })
        // sets active area
        this.activeArea = this.areaChartDataStream.find(area => {
            return area.selected;
        });
    }
    /**
     * Checks if Area or Application is active or not
     * @param selectedData
     * @param compareData
     * @param index
     */
    private checkIfActive(selectedData, compareData, index): boolean {
        if (!selectedData) {
            return index === 0 ? true : false;
        }
        return selectedData.id === compareData.id ? true : false
    }
    /**
     * maps value for entity/app/area charts
     * @param name
     * @param mapWith
     */
    private mapValue(name: string, mapWith?: string): number {
        switch (mapWith) {
            case 'entity':
                // maps value for entities based on entityName
                let extractedEntity = this.entitiesValueSet.find(entity => {
                    return entity.configName === name
                })
                return extractedEntity ? extractedEntity.value : 0;
            case 'app':
                // maps value for applications by comparing app with entites parentApp
                let extractedApps = this._entitiesChartDataContainer.filter(entity => {
                    return entity.key.parentApp === name;
                })
                if (extractedApps && extractedApps.length > 0) {
                    return this.sumValues(extractedApps);
                }
                return 0;
            case 'area':
                // maps value for areas by comparing group with applications parentgroup
                let extractedAreas = this._appChartDataContainer.filter(app => {
                    return app.key.parentGroup.toLowerCase() === name.toLowerCase();
                })
                if (extractedAreas && extractedAreas.length > 0) {
                    return this.sumValues(extractedAreas);
                }
                return 0;
            default:
                return 0;
        }
    }
    /**
     * Sums value in the array and returns final number
     * @param entities
     */
    private sumValues(entities: BCOChartData[]): number {
        let sum: number = 0;
        entities.forEach(entity => {
            sum += entity.value
        })
        return sum;
    }
    /**
     * Filters route.json based on category
     * @returns BCOMainMenuRoute[]
     */
    private filterRoutes(routes: BCOMainMenuRoute[], filterBy: number): BCOMainMenuRoute[] {
        switch (filterBy) {
            case TYPE.AREA:
                // filter group from routes
                let allGroups = _.filter(routes, (route) => {
                    return route.groupName ? true : false;
                });
                return allGroups;
            case TYPE.APP:
                // filter application from routes
                let allApps = _.filter(routes, (route) => {
                    return route.applicationName ? true : false;
                });
                return allApps;
            case TYPE.ENTITY:
                // filter entites from routes
                return _.filter(routes, (route) => { return route.configName && route.parentApp ? true : false });
            default:
                return [];
        }
    }
    /**
     * API used to set active area/app/entity
     */
    setActiveItem(activeItem: BCOChartData, type: number) {
        switch (type) {
            case TYPE.AREA:
                this.activeArea = activeItem;
                break;
            case TYPE.APP:
                this.activeApp = activeItem;
                break;
            case TYPE.ENTITY:
                this.activeEntity = activeItem;
                break;
            default:
                break;
        }
    }
    /**
     * sets entities chart dataset
     */
    set entitiesChartDataStream(entitesSet: Array<BCOChartData>) {
        this._entitiesChartData = entitesSet;
        this._entitiesChartDataSubject.next(entitesSet);
    }
    /**
     * gets entities chart dataset
     */
    get entitiesChartDataStream() {
        return this._entitiesChartData || [];
    }
    /**
     * sets applications chart dataset
     */
    set appChartDataStream(appSet: Array<BCOChartData>) {
        this._appChartData = appSet;
        this._appChartDataSubject.next(appSet)
    }
    /**
     * gets applications chart dataset
     */
    get appChartDataStream() {
        return this._appChartData || [];
    }
    /**
     * sets groups chart dataset
     */
    set areaChartDataStream(groupSet: Array<BCOChartData>) {
        this._areaChartData = groupSet;
        this._areaChartDataSubject.next(groupSet);
    }
    /**
     * gets groups chart dataset
     */
    get areaChartDataStream() {
        return this._areaChartData || [];
    }
    /**
     *  sets active area value
     */
    set activeArea(area: BCOChartData) {
        if (area !== this._activeArea) {
            this._activeArea = area;
            this.onActiveAreaChange$.emit(area); // emits active area
            this.populateAppChartData(); // when active area changes populate curresponding appChart data
        }
    }
    /**
     * gets active group value
     */
    get activeArea() {
        return this._activeArea || null;
    }
    /**
     * sets active app value
     */
    set activeApp(app: BCOChartData) {
        if (app !== this._activeApp) {
            this._activeApp = app;
            this.onActiveAppChange$.emit(app); // emits active app
            this.populateEntitesChartData(); // when active app changes populate curresponding entitiesChart data
        }
    }
    /**
     * gets active app value
     */
    get activeApp() {
        return this._activeApp || null;
    }
    /**
     * sets active entity value
     */
    set activeEntity(entity: BCOChartData) {
        this._activeEntity = entity;
    }
    /**
     * gets active entity value
     */
    get activeEntity() {
        return this._activeEntity || null;
    }
    /**
     * sets entites object
     */
    set entitiesValueSet(data: BCOModel[]) {
        this._entitiesValueSet = data;
        if (data instanceof HttpErrorResponse) {
            this._entitiesValueSetSubject.error(data);
        } else {
            this._entitiesValueSetSubject.next(data);
        }
    }
    /**
     * gets entity object
     */
    get entitiesValueSet() {
        return this._entitiesValueSet || [];
    }
    /**
     * sets widget configuration for BCO
     */
    set widgetConfig(widgetConfig: Widget) {
        this._widgetConfig = widgetConfig;
    }
    /**
     * gets widget configuration for BCO
     */
    get widgetConfig(): Widget {
        return this._widgetConfig;
    }
}
