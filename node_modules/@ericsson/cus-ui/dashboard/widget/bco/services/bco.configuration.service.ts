import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { DashboardService } from '../../../dashboard.service';
import { Widget } from '../../widget.model';
import { BCOModel } from '../bco.model';
import { Helper } from '../../../../common/utils';
import { LoggerService } from '../../../../logger';
import { ApplicationSettings } from '../../../../common';
import * as _ from 'lodash';
import { WidgetMapping } from '../../../helpers/widget-mapping.helper';

@Injectable()
export class BCOConfigurationService {
    private httpTimeoutSec: number;

    constructor(private http: HttpClient,
        private _dashboardService: DashboardService,
        private _logger: LoggerService,
        private _appSettingsService: ApplicationSettings) {

        this.httpTimeoutSec = this._appSettingsService.getIntValue('HTTP_TIMEOUT_SEC');
    }

    /**
     * Get consolidated business configuration Overview
     */
    getBusinessConfigurationOverview(currentConfig: Widget): Observable<Array<BCOModel>> {
        // get all widget configurations from dashboard service
        let dashboardWidgetConfigs = this._dashboardService.widgetConfigs;
        let bcWidgetConfig = dashboardWidgetConfigs.get(currentConfig.groupKey);
        if (bcWidgetConfig && bcWidgetConfig.length > 0) {
            return this.getOverview(bcWidgetConfig.filter(widget => widget.apiPath)) // filter out if API path is empty
        } else {
            return Observable.of([]);
        }
    }
    /**
     * Get response from widget apiPaths
     * @param bcWidgetConfig
     */
    private batchApiResponse(bcWidgetConfig: Widget[]): Observable<any> {
        let apiPaths = Helper.evaluate(bcWidgetConfig, `$[?(@.name=='${bcWidgetConfig[0].name}')]..apiPath`);
        let observableBatch = [];
        let errorCount: number = 0;
        apiPaths.forEach((apiPath) => {
            // If any of one api fails it should not block the flow. So return null incase of error.
            observableBatch.push(this.http.get(apiPath)
                // default timeout prevents widget from showing 'loader' when response takes longer than specified time
                .timeout(this.httpTimeoutSec)
                .catch((error) => {
                    errorCount = errorCount + 1;
                    this._logger.error(error);
                    if (errorCount === apiPaths.length) { // if all api fails then show error msg in widget
                        return Observable.throw(error);
                    }
                    return Observable.of(null);
                })
            );
        });
        if (observableBatch && observableBatch.length > 0) {
            return Observable.forkJoin(observableBatch);
        } else {
            return Observable.of([]);
        }

    }

    /**
     * Trigger API to get configuration data
     * @param bcWidgetConfig
     */
    private getOverview(bcWidgetConfig: Widget[]) {
        return this.batchApiResponse(bcWidgetConfig).map((apiResponse) => {
            return this.mapWidgetConfigAndResponse(bcWidgetConfig, apiResponse);
        })
            .catch(this.handleError);
    }

    /**
     * Maps each widget configuration with its response and queries to get configuration overview
     */
    private mapWidgetConfigAndResponse(bcWidgetConfig: Widget[], apiResponse: any[]) {
        let configData = [];
        if (bcWidgetConfig && apiResponse) {
            bcWidgetConfig.forEach((configObj, configIndex) => {
                let overview = this.getEachBusinessConfigurationOverview(configObj, apiResponse[configIndex]);
                configData.push(overview);
            });
        }
        return WidgetMapping.flattenArray(configData);
    }

    /**
     * Get each business configuration overview that can be consolidated later
     * @param config
     * @param result
     */
    private getEachBusinessConfigurationOverview(config, result: any): BCOModel[] {
        if (_.isEmpty(result) && !_.isNumber(result)) { // if response is empty/null return [] to avoid showing configNames in chart
            return [];
        }
        let dataConfiguration = Helper.evaluate(config, `$..data[*]`);
        let overview: Array<BCOModel> = [];
        dataConfiguration.forEach(element => {
            let value;
            if (element.dataMapping) {
                if (element.method) {
                    value = WidgetMapping.evaluate(result, element.dataMapping, element.method);
                } else {
                    value = WidgetMapping.evaluate(result, element.dataMapping);
                }
                let chartData = {
                    'configName': element.configName,
                    'value': value
                };
                overview.push(chartData);
            }
        });
        return overview;
    }

    /**
     * Handle errors
     * @param error
     */
    private handleError(error: Response) {
        return Observable.throw(error);
    }

}
