import { Component, OnInit, ViewEncapsulation, HostBinding, Input, OnChanges, SimpleChanges } from '@angular/core';
import { Addon, OptionItem } from '@ericsson/oden';
import { BCOService } from '../services';
import { BCOChartData } from '../bco.model';
import { TYPE } from '../bco.constants';
import * as _ from 'lodash';


@Component({
    selector: 'cus-appchart',
    templateUrl: './appchart.component.html',
    styleUrls: ['./appchart.component.scss'],
    encapsulation: ViewEncapsulation.None
})

export class AppchartComponent implements OnInit, OnChanges {

    @HostBinding('class.app-chart') addClass: boolean = true;
    @Input() appChartData: Array<BCOChartData> = [];
    @Input() appChartAddons: Array<Addon> = [];
    areaSelectorOptions: Array<OptionItem> = [];
    selectedArea: OptionItem;

    constructor(private _bcoService: BCOService) {

    }

    ngOnInit() {
        this.loadAreaSelector(); // adds area selector dropdown
        // when active area changed in areaChart then update the same in area selector dropdown
        this._bcoService.onActiveAreaChange$.subscribe(selectedArea => {
            this.selectedArea = this.areaSelectorOptions.find(config => {
                return config.id === selectedArea.id;
            })
        })
        // when active app changed using app selector dropdown then update the appchart data respectively
        // and make sure that if you select any slice in appchart it should not reload appchart again
        this._bcoService.onActiveAppChange$.subscribe(changedApp => {
            let activeApp = _.find(this.appChartData, { 'active': true });
            if (activeApp && activeApp.id !== changedApp.id) { // check if changed app and active app are different
                this.appChartData = this.appChartData.map(appChart => {
                    appChart.selected = appChart.id === changedApp.id;
                    return appChart;
                })
            }
        })
    }
    ngOnChanges(changes: SimpleChanges) {
        if (changes['appChartData'] && changes['appChartData'].previousValue !== changes['appChartData'].currentValue) {
            this.appChartData = changes['appChartData'].currentValue;
        }
        if (changes['appChartAddons'] && changes['appChartAddons'].previousValue !== changes['appChartAddons'].currentValue) {
            this.appChartAddons = changes['appChartAddons'].currentValue;
        }
    }
    /**
     * adds area selector option
     */
    loadAreaSelector(): void {
        this._bcoService.areaChartData$.subscribe((areaChart) => {
            this.areaSelectorOptions = areaChart.map(app => {
                return new OptionItem({
                    label: app.label,
                    id: app.id,
                    selected: app.selected
                })
            });
            this.selectedArea = this.areaSelectorOptions.find((group) => {
                return group.selected;
            });
        });
    }
    /**
     * triggers event when any section selected in chart
     * @param activeApp
     */
    onItemSelected(activeApp: BCOChartData) {
        if (activeApp) {
            // set active slice based on selection
            this.appChartData.forEach(chartData => {
                return chartData.active = chartData.id === activeApp.id;
            })
            // emits selected app, based on this appSelector configuration will be updated
            this._bcoService.setActiveItem(activeApp, TYPE.APP);
        }
    }
    /**
     * OnChange event of dropdown
     * @param data
     */
    onChange(area: OptionItem) {
        // update active area in service, it will reload appchart based on active area
        let activeArea = this._bcoService.areaChartDataStream.find(groupChart => {
            return groupChart.id === area.id;
        });
        this._bcoService.setActiveItem(activeArea, TYPE.AREA);
    }
}
