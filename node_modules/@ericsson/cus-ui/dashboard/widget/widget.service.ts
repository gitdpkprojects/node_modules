import { HttpClient, HttpResponse } from '@angular/common/http';
import { Injectable, Inject } from '@angular/core';
import { Observable } from 'rxjs';
import { Widget } from './widget.model';
import { DashboardService } from '../dashboard.service'
import { WidgetConfigHelper } from '../helpers/widget-config.helper';
import { BCOService } from './bco/services';
import { EnhancedTableService } from './enhanced-table/enhanced-table.service'

@Injectable()
export class WidgetService {
  private _widget: Widget;
  private _data: Observable<any>;

  constructor(private _http: HttpClient, @Inject(DashboardService) private dashboardService: DashboardService,
    private _dashboardBcService: BCOService,
    private enhancedTableService: EnhancedTableService) { }

  /**
   * Sets widget and initialize widget data.
   * @param widget
   */
  set widget(widget: Widget) {
    this._widget = widget;
    this.setDataSource(widget);
  }

  /**
   * Returns widget
   * @return {Widget}
   */
  get widget(): Widget {
    return this._widget;
  }

  /**
   * Sets widget data
   * @param data
   */
  set data(data: Observable<any>) {
    this._data = data;
  }

  /**
   * Returns observable of widget data
   * @return {Observable<any>}
   */
  get data(): Observable<any> {
    return this._data || new Observable<any>();
  }

  /**
   * Function to get the widget data
   * @param widget
   */
  setDataSource(widget: Widget) {
    let widgetType = this.widget.containers[0].sets[0].type.toLowerCase();
    let widgetConfig = this.dashboardService.widgetConfigs.get(this.getWidgetId(widget))
    if (widgetConfig) {
      // Lets check for name latestentity just to make sure nothing existing breaks.
      if ((widgetConfig.length > 1 &&
        widgetType === 'stackedbarchart') ||
        (widgetType === 'table' || widgetType === 'bco')) {
        if (widgetType === 'bco') {
          this._dashboardBcService.widgetConfig = this.widget; // set current widget configuration
          this.data = this._dashboardBcService.entitiesValueSet$;
        } else if (widgetType === 'table') {
          this.enhancedTableService.widgetConfig = this.widget;
          this.data = this.enhancedTableService.enhancedTabaleData$;
        } else {
          this.data = this.getBatchData(widgetConfig.filter(config => config.apiPath));
        }
      } else {
        this.data = this._http.get(widget.apiPath).delay(500).share();
      }
    }
  }

  getWidgetId(widget: Widget) {
    return widget.name.toLowerCase() + '#' + widget.containers[0].sets[0].type.toLowerCase();
  }

  getBatchData(configs: Widget[]): Observable<any> {
    return this.getBatchObservableData(configs).map(data => {
      return WidgetConfigHelper.mergeData(data, configs[0].containers[0].sets[0].type, configs, this.widget);
    });
  }

  /**
   * Returns an observable of data
   * Uses forkjoin to call multiple requests in parallel
   * @returns {Observable<any>}
   */
  private getBatchObservableData(data: Array<Widget>): Observable<any> {
    let observableBatch = [];
    // If latestEntities get the data from datashare service and loop through the urls and get the data
    data.forEach((widget: Widget) => {
      observableBatch.push(this._http.get<any>(new Widget(widget).apiPath,
        { observe: 'response' }).delay(500).map((response: HttpResponse<any>) => {
          let body = response.body ? response.body : '';
          if (body && body.length > 0) {
            return JSON.parse(body);
          } else {
            return [];
          }
        }
        ).share())
    });
    return Observable.forkJoin(observableBatch);
  }
}
