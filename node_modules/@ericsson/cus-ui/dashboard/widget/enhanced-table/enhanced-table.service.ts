import { Injectable } from '@angular/core';
import { HttpClient, HttpResponse } from '@angular/common/http';
import { Observable, Subject } from 'rxjs';
import { FIELD_TYPE, STATE } from '@ericsson/oden/constants';
import { FilterService } from '@ericsson/oden/core/services';
import { DashboardService } from '../../../dashboard/dashboard.service';
import { ArrayHelper } from '@ericsson/oden/core/helpers/array.helper';
import { Widget } from '../widget.model';
import { WidgetConfigHelper } from '../../helpers/widget-config.helper';
import { HttpErrorResponse } from '@angular/common/http';
import { EnhancedTableDataModel } from './enhanced-table-data.model';
import { ApplicationSettings } from '../../../common/services/application.settings.service';
import { WidgetMapping } from '../../helpers/widget-mapping.helper';
import { LoggerService } from '../../../logger/logger.service';
import { Helper } from '../../../common/utils/helper';

@Injectable()
export class EnhancedTableService {

    widgetConfig: Widget;
    enhancedTableDataSubject = new Subject();
    enhancedTabaleData$ = this.enhancedTableDataSubject.asObservable();
    httpTimeoutSec: number;

    private _enhancedTableData: EnhancedTableDataModel;

    constructor(private http: HttpClient,
        private filterService: FilterService, private _appSettingsService: ApplicationSettings,
        private _dashboardService: DashboardService,
        private _logger: LoggerService) {
        this.httpTimeoutSec = this._appSettingsService.getIntValue('HTTP_TIMEOUT_SEC');
    }

    /**
    * Filters the table data based on the selected state in category filter.
    */
    filterData(data, currentFilterString, headers): Array<any> {
        let items;
        let allItems = this.filterService.getItems(data, 'state');
        if (currentFilterString === undefined || currentFilterString === '') {
            items = allItems;
        } else {
            items = ArrayHelper.filterOnKeys(allItems, currentFilterString, this.getFieldsToFilter(headers));
        }
        return items;
    }

    /**
     * Function to loop over the headers and get the field name for category filters.
     */
    getCategoryFilterField(headers): string {
        let fieldToFilter = '';
        if (headers) {
            fieldToFilter = headers.find(item => item.fieldType === FIELD_TYPE.STATE).field;
        }
        return fieldToFilter;
    }

    /**
     * Function to loop over the headers and get the field names for filters.
     */
    getFieldsToFilter(headers): Array<any> {
        let fields = [];
        headers.forEach(item => {
            if (item.field !== this.getCategoryFilterField(headers)) {
                fields.push(item.field)
            }
        });
        return fields;
    }

    /**
     * Function to get unique state values for category filter.
     */
    populateCategoryFilters(data: Array<any>, headers): Array<any> {
        let set = new Set();
        let field = this.getCategoryFilterField(headers);
        data.forEach((item) => {
            if (item[field]) {
                set.add(item[field].state);
            }
        });
        let result = Array.from(set).map((item, index) => {
            return {
                label: this.getVersionDisplayText(item),
                field: this.getVersionDisplayText(item),
                selected: true,
                searchField: item,
                id: 'id' + index
            }
        });
        return result;
    }

    /**
     * Returns a presentable string
     * @param version
     * @returns {string}
     */
    getVersionDisplayText(version: number): string {
        let displayText = '';
        switch (version) {
            case STATE.DRAFT:
                displayText = 'Draft';
                break;
            case STATE.PUBLISHED:
                displayText = 'Published';
                break;
            case STATE.CUSTOM:
                displayText = 'custom';
                break;
            case STATE.OK:
                displayText = 'ok';
                break;
            case STATE.WARNING:
                displayText = 'warning';
                break;
            case STATE.MINOR:
                displayText = 'minor';
                break;
            case STATE.MAJOR:
                displayText = 'major';
                break;
            case STATE.CRITICAL:
                displayText = 'critical';
                break;
        }
        return displayText;
    }

    /**
     * Get consolidated enhanced table data
     */
    getTableData() {
        if (this.widgetConfig) {
            let dashboardWidgetConfigs = this._dashboardService.widgetConfigs;
            let enhancedTableConfigs = dashboardWidgetConfigs.get(this.widgetConfig.groupKey);
            enhancedTableConfigs = enhancedTableConfigs.filter(config => config.apiPath);
            if (enhancedTableConfigs && enhancedTableConfigs.length > 0) {
                this.getMergedData(enhancedTableConfigs, this.widgetConfig)
                    .subscribe((data) => {
                        this.enhancedTableData = WidgetMapping.mapDataFor(this.widgetConfig.containers[0].sets[0], data, '');
                    }, (error) => {
                        this.enhancedTableData = error;
                    })
            } else {
                this.enhancedTableData = null;
            }
        }
    }

    /**
     * Get response from widget apiPaths
     * @param enhancedTableData
     */
    private batchApiResponse(widgets: Array<Widget>): Observable<any> {
        let observableBatch = [];
        let errorCount = 0;
        widgets.forEach((widget: Widget) => {
            observableBatch.push(this.http.get<any>(new Widget(widget).apiPath,
                { observe: 'response' }).delay(500).map((response: HttpResponse<any>) => {
                    let body = response.body ? response.body : '';
                    if (body && widget.containers[0].sets[0].columnMapping) {
                        let data = Helper.evaluate(body, widget.containers[0].sets[0].columnMapping);
                        // Jsonpath returns an array of results always
                            // So access the 0th element which is our desired array.
                        let resultSet = data && data.length > 0 ? data[0] : null;
                        if (resultSet && Array.isArray(resultSet)) {
                            return resultSet;
                        } else if (Array.isArray(body)) {
                            return body;
                        } else {
                            return [];
                        }
                    } else if (body && Array.isArray(body)) {
                        return body;
                    } else {
                        return [];
                    }
                }).timeout(this.httpTimeoutSec).catch((error) => {
                    errorCount = errorCount + 1;
                    this._logger.error(error);
                    if (errorCount === widgets.length) {
                        return Observable.throw(error);
                    }
                    return Observable.of([]);
                }))
        });
        return Observable.forkJoin(observableBatch);
    }

    /**
     * Getters and setters for enhanced table data
     */
    set enhancedTableData(result: EnhancedTableDataModel) {
        this._enhancedTableData = result;
        if (result instanceof HttpErrorResponse) {
            this.enhancedTableDataSubject.error(result);
        } else {
            if (result && result.data && result.data.length > 0) {
                this.enhancedTableDataSubject.next(result);
                return;
            }
            this.enhancedTableDataSubject.next(null);
        }
    }

    get enhancedTableData() {
        return this._enhancedTableData || null;
    }

    /**
     * Trigger API to get configuration data
     * @param enhancedTableData
     */
    private getMergedData(enhancedTableData: Widget[], currentConfig) {
        return this.batchApiResponse(enhancedTableData).map((apiResponse) => {
            return WidgetConfigHelper.mergeData(apiResponse, 'table', enhancedTableData, currentConfig)
        })
    }
}
