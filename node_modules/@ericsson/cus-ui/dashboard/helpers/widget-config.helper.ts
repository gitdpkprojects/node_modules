import { WidgetSet } from '../widget/widget-container/widget-set/widget-set.model';
import { Widget } from '../widget/widget.model';
import { Helpers } from './helpers';
import { WidgetMapping } from './widget-mapping.helper';
import * as underscore from 'lodash';
let _ = (underscore as any).default || underscore;

export class WidgetConfigHelper {

    public static mergeData(data: Array<any>, type: string, configs: Array<Widget>, currentConfig: Widget) {
        let result = [];
        switch (type) {
            case 'table':
                result = WidgetConfigHelper.mergeTableData(data, configs, currentConfig);
                break;
            case 'stackedbarchart':
                result = WidgetConfigHelper.mergeStackedChartData(data, configs);
                break;
            default:
                result = [];
                break;
        }
        result = result && result.length > 0 ? result : [];
        return result;
    }

    /**
     * Maps the batch data to the corresponding configs and returns the final data to be displayed.
     * For stackbarcharts.
     * @param data
     * @param configs
     */
    private static mergeStackedChartData(data: Array<any>, configs: Array<Widget>): Array<any> {
        let stackedConfig = configs;
        let mergedData = [];
        if (data && data.length > 0) {
            data.forEach((item, index) => {
                let mapping = new WidgetSet(stackedConfig[index].containers[0].sets[0]).data;
                mergedData.push(...WidgetMapping._mapStackedData(mapping, item));
            });
            return WidgetConfigHelper.mergeChartData(mergedData);
        } else {
            return [];
        }
    }

    /**
     * Groups the data based on label and sums up other numering values in the object.
     * @param data
     */
    private static mergeChartData(data): Array<any> {
        return _(data)
            .groupBy('label')
            .map((g) => _.mergeWith({}, ...g, (objValue, srcValue) => _.isNumber(objValue) ? objValue + srcValue : undefined))
            .value()
    }

    /**
     * Used to merge batch data for table by mapping it to corresponding configs.
     * As well merged the configs and updated current config so that the table displays properly.
     * @param data
     * @param configs
     * @param currentConfig
     */
    public static mergeTableData(data: Array<any>, configs: Array<Widget>, currentConfig: Widget) {
        let index = 0;
        let result = [];
        let orderBy = '';
        // The result will be in the order of the rest calls
        data.forEach(item => {
            // Map the response with the corresponding latestEntity configuration
            result.push(...WidgetConfigHelper.mapTableData(item, configs[index]));
            index++;
        });
        // Get the field to sort
        currentConfig.containers[0].sets[0].data.forEach(configObject => {
            if (
                configObject.fieldType &&
                (configObject.fieldType === 'date' || configObject.fieldType === 'datetime') &&
                orderBy === ''
            ) {
                orderBy = configObject.fieldMapping ? configObject.fieldMapping : configObject.dataMapping;
            }
        });
        WidgetConfigHelper.orderByDate(result, orderBy, 'descending');
        return result;
    }

    /**
   * Maps the data with the config which maps fieldMapping of config with datamapping of the response
   * @param data
   * @param config
   */
    public static mapTableData(data: any, config: Widget): any {
        let Mergeddata = data.map((row) => {
            let mappedData = {};
            let trackedDataMaps: any = {};
            // map field mapping to the data mapping of the response
            config.containers.forEach(container => {
                container.sets.forEach(set => {
                    new WidgetSet(set).data.forEach(configObject => {
                        if (configObject.fieldMapping) {
                            mappedData[configObject.fieldMapping] = row[configObject.dataMapping];
                            trackedDataMaps[configObject.dataMapping] = row[configObject.dataMapping];
                        }
                    })
                })
            });
            // add path for navigation on click row
            mappedData = Object.assign(mappedData, WidgetConfigHelper.getObjectDifference(trackedDataMaps, row));
            WidgetConfigHelper.setTableRowPath(config, mappedData, row);
            return mappedData;
        });
        return Mergeddata;
    }

    /**
     * Function that merges the configuration.
     * @param configs
     */
    public static mergeConfigs(configs: Array<Widget>) {
        // Clone the configs so that we dont change the original configs
        let temp = _.cloneDeep(configs);
        let mergedConfig: Widget = temp[0];
        switch (mergedConfig.containers[0].sets[0].type) {
            case 'table':
                mergedConfig.containers[0].sets[0].data = WidgetConfigHelper.mergeMappings(temp);
                break;
            case 'stackedbarchart':
                mergedConfig.containers[0].sets[0].addons = WidgetConfigHelper.mergeAddons(temp);
                break;
            default:
                mergedConfig = configs[0];
                break;
        }
        return mergedConfig;
    }


    /**
     * Combines the array of configs into one by merging the mappings.
     * @param configs
     */
    static getCombinedConfig(configs: Widget[]): Widget {
        let temp = _.cloneDeep(configs);
        let widgetConfigs = [];
        if (temp && temp.length > 0) {
            temp.forEach((t) => {
                widgetConfigs.push(new Widget(t));
            })
        }
        widgetConfigs.sort((a, b) => { return b.priority - a.priority });
        let combinedWidgetConfig = widgetConfigs[widgetConfigs.length - 1];
        combinedWidgetConfig.containers[0].sets[0].data = WidgetConfigHelper.mergeMappings(widgetConfigs);
        combinedWidgetConfig.appName = combinedWidgetConfig.apiPath = combinedWidgetConfig.description = '';
        return combinedWidgetConfig;
    }

    /**
   * Compares data with the source object and returns the difference as an object
   * @param source
   * @param data
   */
    private static getObjectDifference(source: any, data: any): any {
        return _.omitBy(data, (value, key) => {
            return source[key] === value;
        });
    }

    /**
     * Merges the mappings of the widget configs
     * @param configs
     */
    private static mergeMappings(configs: Widget[]): Array<any> {
        let mergedConfig = [];
        if (configs.length > 0) {
            configs.forEach((widget) => {
                if (mergedConfig.length > 0) {
                    widget.containers.forEach(container => {
                        container.sets.forEach((set: WidgetSet) => {
                            new WidgetSet(set).data.forEach(data => {
                                WidgetConfigHelper.mergeConfigMappings(data, mergedConfig);
                            })
                        })
                    })
                } else {
                    mergedConfig = mergedConfig.concat(new WidgetSet(widget.containers[0].sets[0]).data)
                }
            })
        }
        return mergedConfig;
    }


    /**
     * Used to merge the mappings by considering field mapping and data mapping.
     * Use it for table component when the mapping merging is required
     * @param mappingConfig
     * @param mergedLatestEntitiesConfig
     */
    private static mergeConfigMappings(mappingConfig, mergedLatestEntitiesConfig) {
        if (mappingConfig.fieldMapping || mappingConfig.dataMapping) { // either fieldMapping or dataMapping should present
            let fieldMapIndex, dataMapIndex;
            // if fieldMapping is availble then match with mergedLatestEntitiesConfig and find respective index
            fieldMapIndex = mappingConfig.fieldMapping ?
                mergedLatestEntitiesConfig.findIndex(fieldMapData => {
                    return fieldMapData.fieldMapping === mappingConfig.fieldMapping;
                }) : -1;
            // if dataMapping is availble then match with mergedLatestEntitiesConfig and find respective index
            dataMapIndex = mappingConfig.dataMapping && !mappingConfig.fieldMapping ?
                mergedLatestEntitiesConfig.findIndex(dataMap => {
                    // while compare dataMapping make sure that replace shouldnot happen if mergedCOnfig already has fieldMapping
                    return !dataMap.fieldMapping && dataMap.dataMapping === mappingConfig.dataMapping;
                }) : -1;
            if (fieldMapIndex > -1) {
                // if fieldMapIndex exist then replace mergedLatestEntitiesConfig with current newDataConfig
                mergedLatestEntitiesConfig[fieldMapIndex] = mappingConfig;
            } else if (dataMapIndex > -1 && fieldMapIndex === -1) {
                // when fieldMapIndex is not exist and dataMapIndex exist then replace mergedCongfig with current newDataConfig
                mergedLatestEntitiesConfig[dataMapIndex] = mappingConfig;
            } else {
                // Both fieldMapIndex and dataMapIndex is not exist then directly push to mergedLatestEntitiesConfig
                mergedLatestEntitiesConfig.push(mappingConfig);
            }
        } else {
            mergedLatestEntitiesConfig.push(mappingConfig)
        }
    }

    /**
   * Extracts link from the config and sets the data with a path to handle row clicks
   * @param config
   * @param data
   */
    private static setTableRowPath(config, mappedData: any, data: any): void {
        config.containers.forEach(container => {
            container.sets.forEach(set => {
                // if row object contains link use that else use widget set's link property
                mappedData['path'] = data.link ? Helpers.replaceTokens(data.link, data) : Helpers.replaceTokens(set.link, data);
                if (set.externalApp || data.externalApp) {
                    // if row object contains externalApp use that else use widget set's externalApp property
                    mappedData['externalApp'] = data.externalApp ? data.externalApp : set.externalApp;
                }
            })
        });
    }

    /**
    * Sorts an array of objects by date based on the field key provied as input.
    * @param data
    * @param field
    * @param sortOrder
    */
    private static orderByDate(data: Array<any>, field: string, sortOrder: string): void {
        let order = sortOrder === 'ascending' ? 1 : -1;
        data.sort((a, b) => {
            let aDate = a[field];
            let bDate = b[field];
            if (typeof (aDate) === 'string') {
                aDate = new Date(aDate);
            }
            if (typeof (bDate) === 'string') {
                bDate = new Date(bDate);
            }
            if (aDate && bDate) {
                return (aDate.getTime() - bDate.getTime()) * order;
            } else {
                return -1;
            }
        });
    }

    /**
     * Merges the addons in the configuration and returns merged addons.
     */
    private static mergeAddons(configs: Widget[]): Array<any> {
        let mergedAddon = [];
        configs.forEach(item => {
            if (item.containers[0].sets[0].addons && item.containers[0].sets[0].addons.length > 0) {
                let addons = item.containers[0].sets[0].addons;
                let result = addons.filter(addon => {
                    return !mergedAddon.some((widgetAddon) => {
                        return widgetAddon.type === addon.type
                    })
                });
                mergedAddon.push(...result);
            }
        });
        return mergedAddon;
    }
}
