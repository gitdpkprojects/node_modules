import { CHART_ADDON, ORDER_TYPE, ALIGNMENT, ORDER, FIELD_TYPE, STATE } from '@ericsson/oden/constants';
import { ChartData, EntityVersion, OptionItem, SelectorAddon } from '@ericsson/oden/core';
import { Helpers } from './helpers';
import { TableHeaderItem } from '@ericsson/oden/core';
import { TableDataItem } from '../models/table.data.item';
import { WidgetSet } from '../widget/widget-container/widget-set/widget-set.model';
import { List } from '../widget/list/list.model';
import * as _ from 'lodash';
import { UUID } from '@ericsson/oden';
import { Helper } from '../../common/utils/helper';

export class WidgetMapping {
  /**
   * Maps data from mapping to be ready to be used for provided component type
   * @param set: WidgetSet
   * @param data
   * @param color - Chart color
   * @return {any}
   */
  static mapDataFor(set: WidgetSet, data, color: string): any {
    let result: any;
    switch (set.type) {
      case 'piechart':
        result = WidgetMapping._mapPieChartData(set, data, color);
        break;
      case 'barchart':
        result = WidgetMapping._mapBarChartChartData(set, data, color);
        break;
      case 'table':
        result = WidgetMapping._mapTableData(set, data);
        break;
      case 'simple':
        result = WidgetMapping._mapSummaryChartData(set, data, color);
        break;
      case 'gaugechart':
        result = WidgetMapping._mapGaugeChartData(set, data, color);
        break;
      case 'linechart':
        result = WidgetMapping._mapLineChartData(set, data, color);
        break;
      case 'progress':
        result = WidgetMapping._mapProgressbarData(set, data);
        break;
      case 'list':
        result = WidgetMapping._mapListViewData(set, data);
        break;
      case 'rainbowchart':
        result = WidgetMapping._mapRainbowChartData(set, data, color);
        break;
      case 'stackedbarchart':
        result = WidgetMapping._mapStackedBarChartData(set, data, color);
        break;
      default: {
        throw new Error(`Type ${set.type} is not a known set type.`);
      }
    }
    return result;
  }

  /**
   * Extends widget data with shared properties
   * @param set
   * @param data
   * @param color
   * @return {{title: (any|string|string|string|string), color: any, addons: any[]}}
   * @private
   */
  private static _extendBaseChartData(set, data, color) {
    return {
      title: set.title,
      color: color,
      addons: WidgetMapping.mapAddonData(set, data, color)
    };
  }

  /**
 * Maps data from mapping to be ready to be used in a chart components
 * @param mappings: WidgetSet
 * @param data
 * @return {{label: string, value: number}[]}
 */
  private static _mapRainbowChartData(set: WidgetSet, data, color) {
    return Object.assign(
      this._extendBaseChartData(set, data, color),
      {
        dataSet: WidgetMapping._mapChartData(set.data, data)
      }
    )
  }

  /**
   * Maps data from mapping to be ready to be used in a chart components
   * @param mappings: WidgetSet
   * @param data
   * @return {{label: string, value: number}[]}
   */
  private static _mapChartData(mappings, data) {
    return mappings.map((mapping) => new ChartData({
      label: mapping.label,
      color: mapping.color || null,
      value: WidgetMapping._getMappingValue(data, mapping),
      unit: mapping.unit || null
    }));
  }

  /**
   * Get Value
   * @param data
   * @param mapping
   */
  private static _getMappingValue(data, mapping) {
    if (mapping.method) {
      // if jsonpath expression
      return WidgetMapping.evaluate(data, mapping.dataMapping, mapping.method);
    }
    return Helpers.getObjectProperty(data, mapping.dataMapping);
  }

  /**
    * Evaluate data expression mapping
    * @param data
    * @param expression
    * @param method
    */
  public static evaluate(data: any, expression: any, method?: string) {
    let evaluatedResult = [];
    let regex = new RegExp('^.+;+');
    if (expression && regex.test(expression)) {

      let expArray = [];
      let expSplitData = expression.split(';');
      expSplitData.forEach(element => {
        element = `$..${element}`;
        let val = Helper.evaluate(data, element);
        expArray.push(val);
      });
      evaluatedResult = this.flattenArray(expArray);
    } else {
      expression = this.updateExpression(expression);

      evaluatedResult = Helper.evaluate(data, expression);
    }
    switch (method) {
      case 'count':
        return this.count(evaluatedResult);
      case 'sum':
        return this.sum(evaluatedResult);
      default:
        return this.getValue(WidgetMapping.flattenArray(evaluatedResult));
    }
  }
  /**
   * If input is an array returns first index else returns entire input
   * @returns number
   */
  private static getValue(input): number {
    return _.isEmpty(input) && !_.isNumber(input) ? 0 : input.length > 0 ? input[0] : input;
  }

  /**
     * Update expression for jsonpath feasibility
     * @param expression
     */
  private static updateExpression(expression: any) {
    let exp = expression;
    // if user's input not having $ in their expression, then append $
    if (expression && expression.indexOf('$') <= -1) {
      exp = `$.${expression}`;
    } else if (!expression) { // if dataMapping is empty add $
      exp = `$`;
    }
    return exp;
  }

  /**
   * Count of jsonpath data
   * @param result
   */
  private static count(result: any) {
    let count = 0;
    if (result) {
      count = result.length;
    }
    return count;
  }

  /**
   * Sum of jsonpath data
   * @param result
   */
  private static sum(result: any) {
    let sum = 0;
    if (result) {
      sum = result.reduce((a, b) => a + b, 0);
    }
    return sum;
  }

  /**
     * Flatten array of arrays to array
     * @param result
     */
  public static flattenArray(result: any) {
    let data = [];
    if (result && result.length > 0) {
      data = result.reduce((a, b) => {
        return a.concat(b);
      });
    }
    return data;
  }

  /**
   * Maps stacked bar chart data from mapping to be ready to be used in a chart components
   * @param mappings
   * @param data
   */
  static _mapStackedData(mappings, data): Array<any> {
    if (data instanceof Array) {
      return data;
    }
    let stackGroup = _.groupBy(mappings, 'fieldMapping'); // first lets group based on fieldMapping
    let dataSet = [];
    if (stackGroup) {
      dataSet = Object.keys(stackGroup).map((key) => {
        let stack = {};
        // Set id to make each stack unique.
        stack['id'] = 'id' + UUID.create();
        stackGroup[key].forEach((dataItem: any) => {
          stack['label'] = key;
          let value = Helpers.getObjectProperty(data, dataItem.dataMapping);
          // If the value is not a number, assign zero since the chart expects number values.
          value = !isNaN(value) ? value : 0;
          if (!stack[dataItem.label]) {
            stack[dataItem.label] = value;
          } else {
            // If the stack already has the label, add the value to previous value.
            stack[dataItem.label] = stack[dataItem.label] + value;
          }
        });
        return stack;
      });
    }
    return dataSet;
  }

  /**
   * Maps data from mapping to be ready to be used in list component
   * @param mappings
   * @param data
   */
  private static _mapListData(mappings, data) {
    return mappings
      .map((mapping) => {
        let items = mapping.items;
        let new_items = [];
        for (let i = 0; i < items.length; i++) {
          new_items[i] = new List({
            label: items[i].label,
            value: Helpers.getObjectProperty(data, items[i].dataMapping),
            labelIcon: items[i].labelIcon,
            fieldType: items[i].fieldType,
            link: Helpers.replaceTokens(items[i].link, data),
            buttonClass: items[i].buttonClass
          });
        }
        return new_items;
      });
  }

  /**
   * Maps data from mapping to be ready to be used in a LineChart component
   * @param mappings
   * @param data
   * @private
   */
  private static _mapLineChartDataSet(mappings, data) {
    return mappings.map(mapping => {
      let timeseries = Helpers.getObjectProperty(data, mapping.dataMapping);
      return new ChartData({
        label: mapping.label,
        data: timeseries.map(chartData => {
          return new ChartData({
            value: chartData.value,
            date: new Date(chartData.date)
          });
        })
      });
    });
  }

  /**
   * Maps data for pie chart
   * @param set
   * @param data
   * @param color
   * @return any{}
   * @private
   */
  private static _mapPieChartData(set, data, color) {
    return Object.assign(
      this._extendBaseChartData(set, data, color),
      {
        dataSet: WidgetMapping._mapChartData(set.data, data),
        percent: set.percent !== undefined ? set.percent : true
      }
    );
  }

  /**
   *
   * @param set
   * @param data
   * @param color
   * @returns {{title, subtitle: (string), progress: (number)}}
   * @private
   */
  private static _mapProgressbarData(set, data) {
    return {
      title: set.title,
      subtitle: set.subtitle,
      progress: data.progress
    };
  }

  /**
   * Maps data for list view
   * @param set
   * @param data
   * @private
   */
  private static _mapListViewData(set, data) {
    return {
      dataSet: WidgetMapping._mapListData(set.data, data),
      headline: set.headline,
      multiline: set.multiline,
      columnSize: set.columnSize
    };
  }

  /**
   * Maps data for bar chart
   * @param set
   * @param data
   * @param color
   * @private
   */
  private static _mapBarChartChartData(set: WidgetSet, data: any, color: string) {
    let barChartConfig: any = {
      dataSet: WidgetMapping._mapChartData(set.data, data),
      xTitle: set.xTitle || '',
      yTitle: set.yTitle || '',
      type: set.barChartType || 0
    };
    if (set.ticks) {
      barChartConfig.ticks = set.ticks;
    }
    if (set.rotatedLabels) {
      barChartConfig.rotatedLabels = set.rotatedLabels;
    }
    return Object.assign(
      this._extendBaseChartData(set, data, color),
      barChartConfig
    );
  }

  /**
   * Maps data for stacked barchart
   * @param mappings
   * @param data
   */
  private static _mapStackedBarChartData(set: WidgetSet, data, color) {
    let dataSet = WidgetMapping._mapStackedData(set.data, data);
    let stackedChartConfig: any = {
      dataSet: dataSet,
      stackedKeys: Helpers.getStackedKeys(dataSet),
      xTitle: set.xTitle || '',
      yTitle: set.yTitle || '',
      type: set.barChartType || 0
    };
    if (set.ticks) {
      stackedChartConfig.ticks = set.ticks;
    }
    if (set.rotatedLabels) {
      stackedChartConfig.rotatedLabels = set.rotatedLabels;
    }

    if (set.sorted) {
      stackedChartConfig.sorted = set.sorted;
    }
    return Object.assign(
      this._extendBaseChartData(set, data, color),
      stackedChartConfig
    );
  }



  /**
   * Maps data for gauge chart
   * @param set
   * @param data
   * @param color
   * @private
   */
  private static _mapGaugeChartData(set: WidgetSet, data: any, color: string) {
    return Object.assign(
      this._extendBaseChartData(set, data, color),
      {
        dataSet: WidgetMapping._mapChartData(set.data, data),
        min: set.min || null,
        max: set.max || null,
        currentValue: set.currentValue,
        subtitle: set.subtitle,
        unit: set.unit,
        color: set.color
      }
    );
  }

  /**
   * Maps data for line chart
   * @param set
   * @param data
   * @param color
   * @private
   */
  private static _mapLineChartData(set: WidgetSet, data: any, color: string) {
    return Object.assign(
      this._extendBaseChartData(set, data, color),
      {
        dataSet: WidgetMapping._mapLineChartDataSet(set.data, data),
        ticks: set.ticks || null,
        tickFormat: set.tickFormat,
        rotatedLabels: set.rotatedLabels,
        xTitle: set.xTitle || '',
        yTitle: set.yTitle || '',
        colorSet: set.colorSet
      }
    );
  }

  /**
   * Maps data for summary chart
   * @param set
   * @param data
   * @param color
   * @return any{}
   * @private
   */
  private static _mapSummaryChartData(set, data, color) {
    return Object.assign(
      this._extendBaseChartData(set, data, color),
      { dataSet: WidgetMapping._mapChartData(set.data, data) }
    );
  }

  /**
   * Maps data from mapping to be ready to be used in a TableComponent
   * @param set: WidgetSet
   * @param data
   * @return {{header: ITableHeaderItem[], data: any[]}}
   */
  private static _mapTableData(set, data) {
    let mapping = set.data;
    let headers = mapping.filter((item) => !item.hidden).map((item) => {
      let header = new TableHeaderItem({
        field: item.fieldMapping ? item.fieldMapping : item.dataMapping,
        label: item.label
      });
      let orderType: ORDER_TYPE = null;
      switch (item.orderType) {
        case 'date':
          orderType = ORDER_TYPE.DATE;
          break;
        case 'string':
          orderType = ORDER_TYPE.STRING;
          break;
        case 'number':
          orderType = ORDER_TYPE.NUMBER;
          break;
        default:
          orderType = null;
          break;
      }
      if (orderType !== null) {
        header.orderType = orderType;
      } else {
        header.sortOrders = null;
      }
      switch (item.order) {
        case 'asc':
          header.order = ORDER.ASCENDING;
          break;
        case 'desc':
          header.order = ORDER.DESCENDING;
          break;
        default:
          header.order = ORDER.NONE;
          break;
      }
      switch (item.align) {
        case 'right':
          header.align = ALIGNMENT.RIGHT;
          break;
        case 'center':
          header.align = ALIGNMENT.CENTER;
          break;
        default:
          header.align = ALIGNMENT.LEFT;
          break;
      }
      switch (item.fieldType) {
        case 'state':
          header.fieldType = FIELD_TYPE.STATE;
          break;
        case 'date':
          header.fieldType = FIELD_TYPE.DATE;
          break;
        case 'datetime':
          header.fieldType = FIELD_TYPE.DATETIME;
          break;
        case 'button':
          header.fieldType = FIELD_TYPE.BUTTON;
          break;
        case 'version':
          header.fieldType = FIELD_TYPE.VERSION;
          break;
      }
      if (item.orderField !== undefined && item.orderField !== null) {
        header.orderField = item.orderField;
      }
      if (item.width !== undefined && item.width !== null) {
        let width;
        if (typeof (item.width) === 'number') {
          width = `${item.width}px`;
        } else {
          width = item.width;
        }
        header.width = width;
      }
      return header;
    });
    return {
      headers: headers,
      data: Helpers.getObjectProperty(data, set.columnMapping).map((item) => {
        if (!item.hasOwnProperty('path')) {
          item.path = Helpers.replaceTokens(set.link, item);
        }
        for (let field in item) {
          if (item.hasOwnProperty(field)) {
            let aHeaders = headers.filter((header) => header.field === field && header.fieldType !== undefined);
            if (aHeaders.length > 0) {
              let header = aHeaders[0];
              switch (header.fieldType) {
                case FIELD_TYPE.STATE:
                  let state = (item[field] && item[field].toLowerCase() === 'published') ? STATE.PUBLISHED : STATE.DRAFT;
                  item[field] = new EntityVersion({ state: state });
                  break;
              }
            }
          }
        }
        return new TableDataItem(item);
      })
    };
  }

  /**
   * Map addons data. data property falls back on set data if not specified
   * @param set: WidgetSet
   * @param data - raw data from REST
   * @param color - Chart color
   * @return any[]
   */
  public static mapAddonData(set, data, color): any[] {
    if (!set.addons) {
      return [];
    }
    return set.addons.map((addon) => {
      let result: any;
      switch (addon.type) {
        case 'summary':
          result = WidgetMapping._mapSumAddonData(addon);
          break;
        case 'legends':
          result = WidgetMapping._mapLegendAddonData(set, addon, data, color);
          break;
        case 'link':
          result = WidgetMapping._mapLinkAddonData(addon);
          break;
        case 'trend':
          result = WidgetMapping._mapTrendAddonData(addon);
          break;
        case 'selector':
          result = WidgetMapping._mapSelectorAddonData(addon);
          break;
        default: {
          throw new Error(`Type ${addon.type} is not a known addon type.`);
        }
      }
      return result;
    });
  }

  /**
   * Extends addons data with shared properties
   * @param addon
   * @return {{type: any}}
   * @private
   */
  private static _extendBaseAddonData(_addon): {} {
    return {};
  };

  /**
   * Maps addons data for sum addon
   * @param addon
   * @return any{}
   * @private
   */
  private static _mapSumAddonData(addon): {} {
    return Object.assign(
      this._extendBaseAddonData(addon),
      {
        type: CHART_ADDON.SUMMARY,
        label: addon.label,
        unit: addon.unit || '',
        format: addon.format
      }
    );
  }

  /**
   * Maps addons data for Legend addon
   * @param set
   * @param addon
   * @param data
   * @param color
   * @return any{}
   * @private
   */
  private static _mapLegendAddonData(set, addon, data, color): {} {
    let addonData = [];
    if (set.type === 'stackedbarchart') {
      addonData = WidgetMapping._mapStackedData(set.data, data);
    } else {
      addonData = Helpers.getObjectProperty(data, addon.dataMapping) || WidgetMapping._mapChartData(set.data, data);
    }
    return Object.assign(
      this._extendBaseAddonData(addon),
      {
        type: CHART_ADDON.LEGEND,
        data: addonData,
        color: color
      }
    );
  }

  /**
   * Maps link addon with data.
   * @param addon
   * @return {{type: CHART_ADDON, path: (any|string), label: (any|string)}}
   * @private
   */
  private static _mapLinkAddonData(addon): {} {
    return {
      type: CHART_ADDON.LINK,
      path: addon.path,
      label: addon.label
    };
  }

  /**
   * Maps trend addon with data
   * @param addon
   * @returns {{type: CHART_ADDON, label, trend: (any|string|string)}}
   * @private
   */
  private static _mapTrendAddonData(addon): {} {
    return {
      type: CHART_ADDON.TREND,
      label: addon.label,
      trend: addon.trend
    };
  }

  private static _mapSelectorAddonData(addon): {} {
    return new SelectorAddon({
      onChange: event => addon.emitEvent.emit(event),
      options: addon.options.map((option, index) => {
        return new OptionItem({
          label: option.label,
          data: option,
          selected: index === 0
        })
      }),
      label: addon.label
    })
  }
}
