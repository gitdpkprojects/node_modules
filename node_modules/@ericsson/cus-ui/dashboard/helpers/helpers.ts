import { HttpResponse } from '@angular/common/http';
export class Helpers {
  static getObjectProperty(object: Object, property: string): any {
    // no object or property passed
    if (typeof object === 'undefined' || typeof property === 'undefined') {
      return undefined;
    }
    // index of next property split
    const index = property.indexOf('.');

    // property split found; recursive call
    if (index > -1) {
      // get object at property (before split), pass on remainder
      return Helpers.getObjectProperty(object[property.substring(0, index)], property.substr(index + 1));
    }

    // None given, return collection.
    if (property === '' || property === undefined || property === null) {
      return object;
    }
    // no split; get property
    return object[property];
  }

  static mergeObjects(obj1, obj2): void {
    for (let prop in obj2) {
      if (obj2.hasOwnProperty(prop)) {
        obj1[prop] = obj2[prop];
      }
    }
  }

  static getStackedKeys(dataSet: Array<any>): Array<string> {
    let stackedKeys = new Set();
    dataSet.forEach(data => {
      Object.getOwnPropertyNames(data).forEach(key => {
        if (key === 'label' || key === 'id' || key === 'value') {
          return;
        }
        stackedKeys.add(key);
      })
    });
    return Array.from(stackedKeys);
  }

  static replaceTokens(link: string, data: Object): string {
    if (link && data) {
      /* Loops through all found variables (defined :variableName) in link property of json and replaces them with mapped data.
           ie. /coba/navigateTo?id=:id&category=:category becomes /coba/navigateTo?id=8457&category=global_list */
      const regex = /:[^\/\?&]*/ig;
      let linkMatch = link.match(regex);
      if (linkMatch) {
        if (linkMatch.length === 1 && linkMatch.toString() === link) {
          let value = data[link.substr(1, link.length - 1)];
          if (value) {
            link = link.replace(linkMatch.toString(), value);
          }
        } else {
          linkMatch.forEach((match) => {
            let value = data[match.substr(1, match.length - 1)];
            if (value) {
              link = link.replace(match, encodeURIComponent(value));
            }
          });
        }
      }
    }
    return link;
  }

  /**
  * Set application error code and message.
  * @param error
  */

  static getErrorText(error: HttpResponse<any>): string {
    let errorMsg: string = '';
    let contentType = error.headers.get('content-type');
    let contentTypeAppJson = /(application\/json)/;
    if (contentTypeAppJson.test(contentType)) {
      let body = error.body ? JSON.parse(error.body) : null;
      if (body && (body.code && body.code.length > 0) &&
        (body.message && body.message.toString().length > 0)) {
        errorMsg = `${body.code} - ${body.message}`;
      }
    }
    return errorMsg;
  }
}
