import { Injectable, InjectionToken, Inject } from '@angular/core';
import { UserService, ProfileModel, AuthRequest, AuthResponse } from '@ericsson/oden/core';
import { Observable } from 'rxjs';
import { HttpClient } from '@angular/common/http';
import { Helper } from '../../../common/utils/helper';
import { UserProfileService } from '../../../common/services/user.profile.service';
export const RESOURCE_PERMISSIONS_URL = new InjectionToken<string>('resource_permissions_url');

@Injectable()
export class CUSUserService implements UserService {

    private dataCache: AuthResponse[] = [];
    constructor(private http: HttpClient,
        @Inject(RESOURCE_PERMISSIONS_URL) private resourcePermissionsUrl: string, private _userProfileService: UserProfileService) {

    }

    getProfile(): ProfileModel {
        return this._userProfileService._getUserProfile();
    }

    /**
     * Can API checks if resources are authorized
     * @param authRequest
     */
    can(authRequest: AuthRequest | AuthRequest[]): Observable<boolean | AuthResponse[]> {
        return new Observable<boolean | AuthResponse[]>(
            (observer) => {
                if (this.dataCache && authRequest) {
                    authRequest = Array.isArray(authRequest) ? authRequest : [authRequest];
                    let cachedData = this.getCache(authRequest);
                    let cachedResults: AuthResponse[] = cachedData.cachedResults;
                    let unCacheAuthResources: AuthRequest[] = cachedData.unCacheAuthResources;
                    if (unCacheAuthResources && unCacheAuthResources.length > 0) {
                        this.getPermissions(unCacheAuthResources).subscribe((response) => {
                            // check for duplicate entries and frame cache results to set as response
                            this.checkDuplicatesAndPush(cachedResults, response);
                            observer.next(this.getResponse(cachedResults, authRequest));
                        }, (error) => {
                            throw new Error(`Error in getting authorization resources status ${error}`);
                        });
                    } else {
                        observer.next(this.getResponse(cachedResults, authRequest));
                    }
                }
            }
        );
    }

    /**
     * Makes POST call with auth data
     */
    private getPermissions(requests) {
        let authRequests = this.getAuthRequests(requests);
        return this.http.post(this.resourcePermissionsUrl, authRequests)
            .map((res) => {
                let result = this.extractResponses(res);
                // check for duplicate entries and form dataCache
                this.checkDuplicatesAndPush(this.dataCache, result);
                return result;
            })
            .catch(this.handleError);
    }

    /**
     * Get response either as a boolean or authresponses
     * @param cache
     */
    private getResponse(cache, requests) {
        // if only one request get boolean
        if (cache && cache.length === 1 && requests && requests.length === 1) {
            return cache[0].allowed;
        } else if (cache.length === 0) {
            return false;
        } else {
            return cache;
        }
    }

    /**
     * Get result to suit AuthRequests
     * @param result
     */
    private getAuthRequests(result) {
        let authResources = {};
        if (result) {
            authResources['authresources'] = result;
        }
        return authResources;
    }

    /**
     * Extract given response into AuthResponses
     */
    private extractResponses(result) {
        let extractedResult = [];
        if (result && Array.isArray(result) && result.length > 0) {
            result.forEach((item) => {
                if (item
                    && item.hasOwnProperty('authresponse')
                    && item.hasOwnProperty('allowed')) {
                    let extractedObj = { ...item.authresponse, allowed: item.allowed };
                    extractedResult.push(extractedObj);
                }
            });
        }
        return extractedResult;
    }

    /**
     * Gets cache data
     * @param authRequest
     */
    private getCache(requests: AuthRequest[]) {
        let cachedResults: AuthResponse[] = [];
        let unCacheAuthResources: AuthRequest[] = [];
        if (requests && requests.length > 0 && this.dataCache && this.dataCache.length > 0) {
            requests.forEach((request: AuthRequest) => {
                let cachedRequest: AuthResponse[] = this.getCachedResponse(request);
                if (cachedRequest && cachedRequest.length > 0) {
                    if (!Helper.isExists(cachedResults, cachedRequest[0])) {
                        cachedResults.push(cachedRequest[0]);
                    }
                } else {
                    if (!Helper.isExists(unCacheAuthResources, request)) {
                        unCacheAuthResources.push(request);
                    }
                }
            });
        } else {
            unCacheAuthResources = requests;
        }
        return {
            cachedResults: cachedResults,
            unCacheAuthResources: unCacheAuthResources
        };
    }

    private getCachedResponse(request: AuthRequest): AuthResponse[] {
        return this.dataCache.filter(t =>
            t.tpgName === request.tpgName
            && t.resource === request.resource
            && t.operation === request.operation);
    }

    /**
     * Sets cache data to check if it can be pushed into cache
     * @param cache
     * @param data
     */
    private checkDuplicatesAndPush(cache, pushData) {
        pushData.forEach((item) => {
            if (!Helper.isExists(cache, item)) {
                cache.push(item);
            }
        });
    }

    /**
     * Handle errors from getPermissions() call
     */
    private handleError(error: Response) {
        return Observable.throw(error);
    }
}
