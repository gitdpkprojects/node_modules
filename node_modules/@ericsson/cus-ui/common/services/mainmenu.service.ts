import { Injectable, Inject, InjectionToken } from '@angular/core';
import { Observable } from 'rxjs';
import { MainMenuRoute } from '@ericsson/oden/modules';
import { HttpClient, HttpHeaders, HttpResponse } from '@angular/common/http';
import { Location } from '@angular/common';

export const MAIN_MENU_URL = new InjectionToken<string>('main_menu_url');

/**
 * This is a service on how to get routes for main menu.
 */
@Injectable()
export class MainMenuService {
    location: Location;
    private _mainMenuDataCache: Array<MainMenuRoute>;
    private shared$: any;
    constructor(private _http: HttpClient,
        @Inject(MAIN_MENU_URL) public mainMenuUrl: any) { }

    /**
     * A mock up of how to do a get-request for the rest
     * @returns {Observable<R>}
     */
    getRoutes(): Observable<Array<MainMenuRoute>> {
        if (this._mainMenuDataCache) {
            return Observable.of(this._mainMenuDataCache);
        } else {
            // Having a class variable, ensures only a single instance of the observable is present
            if (!this.shared$) {
                const httpOptions: any = {
                    headers: new HttpHeaders({
                        'X-CSRF-Token': 'Fetch'
                    }),
                    observe: 'response'
                };
                this.shared$ = this._http
                    .get<MainMenuRoute[]>(this.mainMenuUrl, httpOptions)
                    .map((response: HttpResponse<any>) => {
                        const csrfToken = response.headers.get('x-csrf-token');
                        if (csrfToken) {
                            localStorage.setItem('x-csrf-token', csrfToken);
                        }
                        return this._map_to_routes(response.body);
                    })
                    .share()
                    .catch(() => Observable.of([]))
            }
            return this.shared$;
        }
    }


    /**
     * Creates and return a MainMenuRoute array
     * @param response
     * @returns {Array<MainMenuRoute>}
     * @private
     */
    private _map_to_routes(routes: MainMenuRoute[]): Array<MainMenuRoute> {
        let filteredRoutes: Array<MainMenuRoute> = routes
            .filter(t => ((t.path && t.path.length > 0) || t.groupName || t.applicationName))
            .map(route => new MainMenuRoute(route));
        this._mainMenuDataCache = filteredRoutes;
        return filteredRoutes;
    }

    /**
      * Sort objects by priority
      * @param a
      * @param b
      */
    private sortByPriority(a, b) {
        a.priority = a.priority ? a.priority : 0;
        b.priority = b.priority ? b.priority : 0;

        if (a.priority === b.priority) {
            return this.sortByLabel(a.label, b.label)
        }
        return a.priority - b.priority;
    }

    /**
     * Sorts the routes based on priority or label
     * @param routes
     */
    sort_routes(routes: Array<any>): Array<any> {
        routes.sort(this.sortByPriority.bind(this));
        routes.forEach((toplevelRoute: any) => {
            if (toplevelRoute.children && toplevelRoute.children.length > 0) {
                toplevelRoute.children.sort(this.sortByPriority.bind(this));
                toplevelRoute.children.forEach((childRoute) => {
                    if (childRoute.children && childRoute.children.length > 0) {
                        childRoute.children.sort(this.sortByPriority.bind(this));
                    }
                })
            }
        })
        return routes;
    }

    /**
     *Sort objects by label
     * @param a
     * @param b
     */
    private sortByLabel(a, b) {
        if (a < b) {
            return -1;
        }
        if (a > b) {
            return 1;
        }
        return 0;
    }

}
