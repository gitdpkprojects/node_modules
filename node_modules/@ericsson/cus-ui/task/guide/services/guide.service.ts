import { Injectable, InjectionToken, Inject, EventEmitter } from '@angular/core';
import { Observable } from 'rxjs';
import { SummaryItem, TaskData, TaskInfo } from '../../models';
import { HttpClient } from '@angular/common/http';
import { Router, ActivatedRoute, NavigationEnd } from '@angular/router';
import { GuidedWorkflowService } from '@ericsson/oden/modules';
import { TaskService } from './task.service';
import { TaskConstants } from '../../task.constants';
import { DialogConfig, ModalHelperService, DIALOG_TYPE } from '@ericsson/oden/modules';
import { ModalActionItem, WorkflowGuide, WorkflowGuideStep, ELEMENT_OVERLAY_STATE, BreadcrumbItem } from '@ericsson/oden';
import { Response as ApiResponse, Common } from '../../../common/models';
import { GuideBaseService } from './guide-base.service';
import { LocalStorage } from '../../../core/storage/localstorage.strategy';
import { Helper } from '../../../common/utils/helper';
import { SummaryService } from './summary.service';
import { Subscription, BehaviorSubject } from 'rxjs';
import { ValueObserverSubject } from '../../../common/utils/value-observer.decorator';
import { WORKFLOW_NAME } from '../../workflow-name.observer';
import { TaskEnum } from '../../task.enum';
import { ErrorHandlerService } from '../../../common/services/error.handler.service';
import { TranslateService } from '@ngx-translate/core';

export const GUIDED_WORKFLOW_URL = new InjectionToken<string>('guided_workflow_url');
export const GUIDE_ROUTE_PATH = new InjectionToken<string>('guide_route_path');

/**
 * Guide Service
 */
@Injectable()
export class GuideService extends GuideBaseService {

    private _guideSteps: Array<WorkflowGuideStep> = [];
    private _currentGuideStep: WorkflowGuideStep = null;
    private _currentTaskId: any;
    private _currentInstanceId: any;
    private _currentTaskScreenUrl: any;
    private guide: WorkflowGuide = null;
    private _taskInfo: TaskInfo;
    subflowFinishOrDiscardClicked = false;
    summarySubject = new BehaviorSubject<any[]>([]);
    summary$ = this.summarySubject.asObservable();
    valueObserverSubscription: Subscription = new Subscription();
    subscription: Subscription;
    errorSubscription: Subscription = new Subscription();
    loaderStatus$: EventEmitter<number> = new EventEmitter<number>();

    constructor(private http: HttpClient,
        @Inject(GUIDED_WORKFLOW_URL) public guidedflowUrl: string,
        @Inject(GUIDE_ROUTE_PATH) public guideRoutePath: string,
        router: Router,
        activatedRoute: ActivatedRoute,
        guidedWorkflowService: GuidedWorkflowService,
        _taskService: TaskService,
        _modalHelperService: ModalHelperService,
        private _summaryService: SummaryService,
        _localStorage: LocalStorage,
        private _errorHandlerService: ErrorHandlerService,
        _translateService: TranslateService
    ) {
        super(_modalHelperService, _taskService, activatedRoute, router, guidedWorkflowService, _localStorage, _translateService);
        this._taskService.guideService = this;
        this.listenRouteChanges();
        this.initGuide();
        this.initFormStatus();
    }

    private initGuide() {
        this.guide = new WorkflowGuide({
            id: '',
            hideBack: true,
            steps: [],
            breadcrumb: [],
            finishTitle: TaskConstants.FINISH_TITLE,
            finishLocked: false,
            finishEvent: () => {
                this.openTaskDialog(TaskConstants.PUBLISH_TASK_MESSAGE, this.getPublishActions());
            },
            actionMenuActions: [],
            actionMenuEvent: (action: any) => {
                this.handleActionMenu(action);
            },
            goToEvent: () => {
                this.handleButtonAction(TaskConstants.NEXT_TASK_ACTION);
            },
            maximizeEvent: () => {
                return this.handleMaximizeEvent();
            }
        });

    }

    /**
     * Subscribe to route changes and preserve browser url for guide mode
     */
    private listenRouteChanges() {
        this.router.events.subscribe(event => {
            if (event && event instanceof NavigationEnd) {
                if (event.url && event.url.indexOf(`/${this.guideRoutePath}`) !== -1) {
                    // url that has to shown in browser url
                    Helper.updateBrowserUrl(event.url, '/', 4);
                }
            }
        });
    }

    private initFormStatus() {
        this._taskService.onFormStatusChange$.subscribe((status) => {
            const guide = this.guidedWorkflowService.getGuideById(this.guide.id);
            if (guide) {
                guide.finishLocked = !status;
            }
            if (this.currentGuideStep) {
                this.currentGuideStep.nextDisabled = !status;
            }
        });
    }

    private handleActionMenu(action: any) {
        if (action.action === TaskConstants.PAUSE_TASK_ACTION) {
            this.openTaskDialog(TaskConstants.PAUSE_TASK_MESSAGE, this.getPauseActions());
        } else if (action.action === TaskConstants.DISCARD_TASK_ACTION) {
            this._translateService.get('com.ericsson.bss.rm.cus.task_management.DISCARD_MESSAGE',
            { workflow_name: this._workflowName }).subscribe((message) => {
                this.openTaskDialog(message,
                    this.getDiscardActions());
            });
        } else if (action.action === TaskConstants.EDIT_TASK_ACTION) {
            this.openTaskDialog(TaskConstants.EDIT_TASK_MESSAGE, this.getEditActions());
        }
    }

    private handleMaximizeEvent() {
        return new Promise((resolve) => {
            this.guidedWorkflowService.getGuideById(this.guide.id).overviewSteps = this._guideSteps;
            resolve();
        });
    }

    /**
     * Display Guided Task Footer
     * @param data
     */
    loadGuidedModeTask(data: TaskInfo, createGuide?: boolean) {
        this._currentTaskId = data.taskId;
        this._workflowName = data.workflowName;
        // starts always with no steps
        this.subscription = this.loadWorkflowSteps(data).subscribe(() => {
            this._currentTaskScreenUrl = this.getActiveScreenUrl(data);
            if (this.currentGuideStep) {
                this.currentGuideStep.path = this._currentTaskScreenUrl;
                this.currentGuideStep.locked = false;
                this.guide.id = data.instanceId;
                const guide = this.guidedWorkflowService.getGuideById(this.guide.id);
                if (createGuide) {
                    this._currentInstanceId = data.instanceId;
                    if (guide) {
                        this.populateGuidedData(guide, data);
                    } else {
                        this.populateGuidedData(this.guide, data);
                    }
                    this.router.navigate([this.currentGuideStep.path])
                        .then(() => {
                            this.guidedWorkflowService.createGuide(this.guide);
                            this.showGuide();
                            this.loaderStatus$.emit(ELEMENT_OVERLAY_STATE.NONE);
                        });
                } else {
                    this.router.navigate([this.currentGuideStep.path]);
                    this.populateGuidedData(guide, data);
                }
            }
        });
    }

    /**
     * Populate guide footer data that can be updated
     */
    private populateGuidedData(guide: WorkflowGuide, data: TaskInfo) {
        guide.position = TaskConstants.GUIDE_POSITION;
        guide.steps = this._guideSteps;
        guide.breadcrumb = this.getBreadcrumbData(data);
        guide.actionMenuActions = this.getActionMenu(data);
    }

    /**
     * Check if guide needs to be created
     */
    private isCreateGuide(instanceId) {
        return this._currentInstanceId && this._currentInstanceId !== instanceId ? true : false;
    }

    /**
     * Get breadcrumb data for guided footer
     * @param data
     */
    private getBreadcrumbData(data: TaskInfo): BreadcrumbItem[] {
        let breadcrumbInfo: BreadcrumbItem[] = [];
        if (data.subProcessSequence && data.subProcessSequence.length > 0) {
            breadcrumbInfo = data.subProcessSequence.map((workflow, index) => {
                return new BreadcrumbItem({
                    id: index,
                    title: workflow,
                    clickable: true
                });
            });
        } else {
            this.valueObserverSubscription = ValueObserverSubject.subscribe((observer) => {
                if (observer.field === WORKFLOW_NAME) {
                    this._taskService.updateAdditionalContextData(TaskEnum.CONTEXT_WORKFLOW_NAME, observer.value);
                    if (this.guidedWorkflowService.getGuideById(this.guide.id)) {
                        let guideBreadcrumb = this.guidedWorkflowService.getGuideById(this.guide.id).breadcrumb;
                        if (guideBreadcrumb && guideBreadcrumb.length > 0) {
                            guideBreadcrumb[guideBreadcrumb.length - 1].title = observer.value || data.workflowName;
                        }
                    }
                }
            });
            breadcrumbInfo = [new BreadcrumbItem({ id: 0, title: data.workflowName, clickable: true })];
        }
        return breadcrumbInfo;
    }

    /**
     * Get Overview from rest api
     */
    private loadWorkflowSteps(data: TaskInfo) {
        return new Observable((observer) => {
            let workflowId;
            let instanceId;
            if (this.subflowFinishOrDiscardClicked) {
                workflowId = data.processDefinitionId;
                instanceId = data.instanceId;
            } else {
                workflowId = this._taskService.getWorkflowId();
                instanceId = data.instanceId;
            }
            let overviewUrl = `${this.guidedflowUrl}/${workflowId}/instance/${instanceId}`;
            this.http.get(overviewUrl)
                .catch(this.handleError)
                .subscribe((res) => {
                    if (res && res.length > 0) {
                        this.buildWorkflowSteps(res[0].tasks, data);
                    }
                    observer.next();
                }, (error) => {
                    this.loaderStatus$.emit(ELEMENT_OVERLAY_STATE.NONE);
                    this.handleTaskErrors(error, TaskConstants.OK_ACTION);
                });
        });
    }

    private buildWorkflowSteps(tasks, data: TaskInfo) {
        this._guideSteps = [];
        if (tasks && tasks.length > 0) {
            tasks.forEach((task, index) => {
                let locked: boolean = false;
                if (task.status === TaskConstants.TASK_NOT_STARTED) {
                    locked = true;
                }
                let step = new WorkflowGuideStep({
                    title: task.taskName,
                    number: index + 1,
                    description: task.description,
                    locked: locked
                });
                step.hideFutureSteps = data && !data.nextTask ? false : true;
                this._guideSteps.push(step);

                // update current task step
                if (task.taskId === this._currentTaskId) {
                    this.currentGuideStep = step;
                }
            });
        }
    }

    private set currentGuideStep(currentGuideStep) {
        this._currentGuideStep = currentGuideStep;
    }

    private get currentGuideStep() {
        return this._currentGuideStep;
    }

    /**
     * Display guide
     */
    private showGuide() {
        this.guidedWorkflowService.show(this.guide.id, this.currentGuideStep.number);
    }

    /**
     * Display guide
     */
    private updateStep() {
        this.guidedWorkflowService.changeStep(this.guidedWorkflowService.getGuideById(this.guide.id), this.currentGuideStep.number);
    }

    /**
     * Event to handle next task click
     */
    private handleButtonAction(action) {

        if (action === TaskConstants.NEXT_TASK_ACTION) {
            this.submitCurrentTaskInfo();
        }
    }

    private submitCurrentTaskInfo() {

        // hits application submit and gets some info
        this._taskService.submitTaskScreen().subscribe(
            (taskInfo) => {
                // Get the additionalContextData
                const additionalContextData = this._taskService.getAdditionalContextData();
                // Merge both taskInfo.context and additionalContextData arrays
                taskInfo.context = [...taskInfo.context, ...additionalContextData];
                const submitTaskParams = {
                    'action': 'next',
                    'taskId': this._currentTaskId
                };
                const submitTaskRequest = { ...taskInfo, ...submitTaskParams };
                this.submitTaskScreenData(submitTaskRequest);
            });
    }

    /**
     * Event when publish clicks
     */
    publishWorkflow() {
        let publishRequest = {
            'action': 'complete'
        };
        this.publish(publishRequest).subscribe(
            (result: any) => {
                this.showSnackbar(`${TaskConstants.PUBLISH_WORKFLOW}
                ${this._workflowName} ${TaskConstants.PUBLISH_WORKFLOW_FINISH}
                . ${TaskConstants.PUBLISH_WORKFLOW_COMPLETE}`);
                if (result
                    && result.hasOwnProperty('processDefinitionId')
                    && result.hasOwnProperty('instanceId')
                    && result.hasOwnProperty('taskId')
                    && result.hasOwnProperty('screenPath')
                    && result.hasOwnProperty('subProcessSequence')) {
                    this.subflowFinishOrDiscardClicked = true;
                    this.handleTaskActions(result);
                } else {
                    this.exitGuide();
                }
            },
            (error) => {
                this.handleTaskErrors(error, TaskConstants.PUBLISH_OK_ERROR_ACTION);
            }
        );
    }

    /**
     * submit task subscription
     * @param submitTaskRequest
     */
    private submitTaskScreenData(submitTaskRequest) {
        if (this.guidedWorkflowService.getGuideById(this.guide.id).steps
            && this.guidedWorkflowService.getGuideById(this.guide.id).steps.length > this.currentGuideStep.number) {
            this.guidedWorkflowService.getGuideById(this.guide.id).steps[this.currentGuideStep.number].locked = false;
        }
        // calls api to get next screen path
        this.postTaskScreenData(submitTaskRequest).subscribe(
            (result) => {
                let message = 'Details saved successfuly';
                this.showSnackbar(message);
                this.handleTaskActions(result);
            },
            (err) => {
                this.guidedWorkflowService.getGuideById(this.guide.id).steps[this.currentGuideStep.number].locked = true;
                this.updateStep();
                this.handleTaskErrors(err, TaskConstants.OK_ERROR_ACTION);
            }
        );
    }

    /**
     * Task Handler for actions - next, publish, discard, edit
     * @param result
     */
    private handleTaskActions(result) {
        // prevent unnecessary exit guide popup
        this.activatedRoute.snapshot.data = { exitGuidedView: true };
        // set taskinfo with next api result
        this.taskInfo = result;
        // set summary
        if (result && result.summary) {
            this._summaryService.summaryInfo = result.summary as SummaryItem[];
        }
        // load guide mode
        this.loadGuidedModeTask(result, this.isCreateGuide(result.instanceId));
    }

    /**
     * Set task info for TPG usage
     * @param taskInfo
     */
    set taskInfo(taskInfo: TaskInfo) {
        this._taskInfo = taskInfo;
    }

    /**
     * Get task info
     */
    get taskInfo() {
        return this._taskInfo;
    }

    /**
     * Get URL to be navigated based on result
     * @param url
     * @param result
     */
    private getActiveScreenUrl(result: TaskInfo) {
        let path: string = '';
        if (this.currentGuideStep) {
            this.currentGuideStep.hideFutureSteps = result && !result.nextTask ? false : true;
        }

        let workflowId;
        let instanceId;
        if (this.subflowFinishOrDiscardClicked) {
            workflowId = result.processDefinitionId;
            instanceId = result.instanceId;
        }

        if (result && result.summary && !result.nextTask) {
            if (result.screenPath) {
                path = `${this.getGuideTaskScreenPath(workflowId, instanceId)}${result.screenPath}`;
            } else {
                path = `${this.getGuideTaskScreenPath(workflowId, instanceId)}/${TaskConstants.SUMMARY_TASK_SCREEN_PATH}`;
            }
            this.currentGuideStep.hideFutureSteps = false;
        } else {
            path = `${this.getGuideTaskScreenPath(workflowId, instanceId)}${result.screenPath}`;
        }
        return path;

    }

    private getGuideTaskScreenPath(workflowId, instanceId) {
        return workflowId && instanceId
            ? `/${TaskConstants.GUIDE_ROUTE_PATH}/${workflowId}/${instanceId}`
            : this._taskService.getGuideTaskScreenPath();
    }

    /**
     * API to submit a task screen
     * @param submitTaskRequest
     */
    private postTaskScreenData(submitTaskRequest: TaskData): Observable<any> {
        let workflowdefinitionid: string = this._taskService.getWorkflowId();
        let instanceId: string = this._taskService.getInstanceId();
        let nextTaskUrl: string = `${this.guidedflowUrl}/${workflowdefinitionid}/instance/${instanceId}`;
        return this.http.post(nextTaskUrl, submitTaskRequest)
            .catch(this.handleError);
    }

    /**
     * API to publish instance
     * @param publishRequest
     */
    private publish(publishRequest): Observable<ApiResponse> {
        let workflowdefinitionid: string = this._taskService.getWorkflowId();
        let instanceId: string = this._taskService.getInstanceId();
        let publishUrl: string = `${this.guidedflowUrl}/${workflowdefinitionid}/instance/${instanceId}`;
        return this.http.post(publishUrl, publishRequest)
            .catch(this.handleError);
    }

    /**
     * Edits workflow from last screen
     */
    editWorkflow() {
        let workflowDefinitionId: string = this._taskService.getWorkflowId();
        let instanceId: string = this._taskService.getInstanceId();
        let workflowUrl = `${this.guidedflowUrl}/${workflowDefinitionId}/instance/${instanceId}`;
        let editWorkflowRequest = {
            'action': 'Edit'
        };
        this.http.post(workflowUrl, editWorkflowRequest)
            .catch(this.handleError)
            .subscribe((result) => {
                this.handleTaskActions(result);
            },
                (error) => {
                    this.handleTaskErrors(error, TaskConstants.OK_ERROR_ACTION);
                    let editContext = this._currentActionMenu.find(item => item.label === 'Edit Task');
                    editContext.disabled = true;
                });
    }

    /**
   * Discard running workflow
   */
    discardTask() {
        let instanceId: string = this._taskService.getInstanceId();
        this.http.delete(`${this.guidedflowUrl}/instance/${instanceId}`)
            .catch(this.handleError)
            .subscribe((result: any) => {
                this.showSnackbar(`${this._workflowName} task is deleted successfully!`);
                if (result
                    && result.hasOwnProperty('processDefinitionId')
                    && result.hasOwnProperty('instanceId')
                    && result.hasOwnProperty('taskId')
                    && result.hasOwnProperty('screenPath')
                    && result.hasOwnProperty('subProcessSequence')) {
                    this.subflowFinishOrDiscardClicked = true;
                    this.handleTaskActions(result);
                } else {
                    this.exitGuide();
                }
            }, (error) => {
                this.handleTaskErrors(error, TaskConstants.OK_ERROR_ACTION);
            });
    }

    /**
     * Handle errors dialog
     */
    private handleTaskErrors(error, action: string) {
        if (!error.error || (error.error && !error.error.status && !error.error.code)) {
            return;
        }
        this.errorSubscription = this._errorHandlerService.getErrorInfo(error.error)
            .subscribe((errorResult: Common.Error) => {
                this.errorDialog(errorResult, action);
            });
    }

    private errorDialog(error, action) {
        let config: DialogConfig = new DialogConfig({
            title: `${error.status} - ${error.message}`,
            message: `${error.details}.Please contact administrator(Error code: ${error.code})`,
            actions: [
                new ModalActionItem({
                    label: TaskConstants.OK_LABEL,
                    action: action,
                    cssClass: 'primary'
                })],
            type: DIALOG_TYPE.SYSTEM_ALERT
        });
        this.openDialog(config);
    }

}
