import { Component, Inject, OnDestroy } from '@angular/core';
import { Router, ActivatedRoute } from '@angular/router';
import { ActionItem, DIALOG_TYPE, DialogComponent, DialogConfig, ModalActionItem, ModalHelperService } from '@ericsson/oden';
import { ELEMENT_OVERLAY_STATE } from '@ericsson/oden/constants';
import { ElementOverlayConfig } from '@ericsson/oden/core';
import { TAB_VIEW } from '@ericsson/oden/modules';
import { Observable } from 'rxjs/Observable';

import { MetaDataService } from '../../../common';
import { Response } from '../../../common/models';
import { getAppRoutes } from '../../../common/utils/router';
import { TranslationService } from '../../../i18n';
import { TaskConstants } from '../../task.constants';
import { TaskEnum } from '../../task.enum';
import { GUIDE_ROUTE_PATH, GuideService, TaskService, TaskContextService } from '../services';
import { RoutingHistoryService } from '../../../common/services';
import { LocalStorage } from '../../../core/storage/localstorage.strategy';
import { Helper } from '../../../common/utils/helper';
import { Subscription } from 'rxjs/Subscription';
import { SummaryService } from '../services/summary.service';

@Component({
    selector: 'cus-guide-root',
    templateUrl: 'guide.component.html',
    styleUrls: ['guide.component.scss'],
    providers: [GuideService, TaskService, TaskContextService],
    animations: [TAB_VIEW.ANIMATION]
})

export class GuideComponent implements OnDestroy {
    showLoader: ElementOverlayConfig = new ElementOverlayConfig({
        state: ELEMENT_OVERLAY_STATE.LOADING
    });
    showError: boolean = false;
    actionType: string;
    errorConfiguration: ElementOverlayConfig = new ElementOverlayConfig();
    dialog: DialogComponent;

    private serviceSubscriptions: Subscription[] = [];
    private componentSubscriptions: Subscription[] = [];
    private browserBackClicked = false;

    constructor(
        private _guideService: GuideService,
        private _taskService: TaskService,
        private _translate: TranslationService,
        private _route: Router,
        private _modalHelperService: ModalHelperService,
        private metaDataService: MetaDataService,
        private _routingHistoryService: RoutingHistoryService,
        private _activatedRoute: ActivatedRoute,
        @Inject(GUIDE_ROUTE_PATH) public guideRoutePath: string,
        private _localStorage: LocalStorage,
        private _summaryService: SummaryService) {
        this.registerGuideApps();
        this.componentSubscriptions.push(this._activatedRoute.params.subscribe(() => {
            if (!this._guideService.subflowFinishOrDiscardClicked) {
                this.resetComponent();
                this.initGuide();
            }
            this._guideService.subflowFinishOrDiscardClicked = false;
        }));
    }

    private initGuide() {
        this.handleBrowserBackClick();
        this.serviceSubscriptions.push(this._taskService.loadTaskInfo().subscribe(
            (result) => {
                // set taskinfo when component is loaded
                this._guideService.taskInfo = result;
                if (result.summary) {
                    this._summaryService.summaryInfo = result.summary;
                }
                this._guideService.loadGuidedModeTask(result, true);
            },
            (error) => {
                this.handleError(error)
            }
        ));
        this.serviceSubscriptions.push(this._guideService.loaderStatus$.subscribe(value => {
            this.hideOverlay(value); // once task successfully loaded disable loader
        }));
    }

    /**
     * Resets the component to intial state by unsubscribing the subscriptions
     */
    private resetComponent() {
        this.showError = false;
        this.browserBackClicked = false;
        this._guideService.taskInfo = null;
        this._summaryService.summaryInfo = [];
        this.unsubscribe(this.serviceSubscriptions);
    }

    /**
     * Handle browser back button click
     * Navigate to screen which started guide mode
     * Once back is clicked, can not stay in guide mode
     */
    private handleBrowserBackClick() {
        let previousUrl = this._routingHistoryService.getPreviousUrl();
        if (!previousUrl) {
            previousUrl = '';
        }

        window.onpopstate = () => {
            history.replaceState(null, null, location.href);
            this.browserBackClicked = true;
            setTimeout(() => {
                this._route.navigateByUrl(previousUrl);
            });
        };
    }


    /**
     * Register applications using metadata
     */
    private registerGuideApps() {
        this.serviceSubscriptions.push(this.metaDataService.getApplicationMetaData().subscribe((bundles) => {
            if (bundles && bundles.length > 0) {
                let updatedRoutes = getAppRoutes(bundles);
                let guideRoute = this._route.config.find(t => t.path === this.guideRoutePath);
                if (guideRoute) {
                    let childRoutes = (guideRoute as any)._loadedConfig.routes[0].children;
                    childRoutes.splice.apply(childRoutes, [childRoutes.length - 1, 0].concat(updatedRoutes));
                }
            }
        }));
    }

    /**
     * @param error
     * shows error page with error details
     */
    private handleError(error: Response): void {
        this.hideOverlay(ELEMENT_OVERLAY_STATE.NONE);
        let actionItem = [new ActionItem({ label: 'Home', action: 'home' })];
        this.errorConfiguration = new ElementOverlayConfig({
            state: ELEMENT_OVERLAY_STATE.ERROR,
            label: this._translate.instant(`com.ericsson.bss.rm.common.http_errors.${error.status}.title`),
            text: this._translate.instant(`com.ericsson.bss.rm.common.http_errors.${error.status}.description`),
            actions: actionItem,
            inlinePlaceholder: true
        });
        this.showError = true;
    }
    /**
     * @param action
     */
    actionButtonClicked(action: ActionItem): void {
        if (this.actionType && action.action === 'home') {
            this._route.navigate(['']);
        }
    }
    /**
     * @param elementOverlayState
     */
    private hideOverlay(elementOverlayState: number): void {
        setTimeout(() => {
            this.showLoader.state = elementOverlayState;
        }, 1000 * 1);
    }
    /**
     * Route Guard to show exit warning popup
     * @return Observable<boolean>
     */
    canDeactivateRoute(): Observable<boolean> {
        let config: DialogConfig = new DialogConfig({
            message: `<p>${TaskConstants.EXIT_ALERT}</p>`,
            actions: [
                new ModalActionItem({
                    label: TaskConstants.CANCEL_LABEL,
                    action: TaskConstants.CANCEL_ACTION,
                    cssClass: 'discard'
                }),
                new ModalActionItem({
                    label: TaskConstants.OK_LABEL,
                    action: TaskConstants.OK_ACTION,
                    cssClass: 'primary'
                })
            ],
            type: DIALOG_TYPE.SYSTEM_ALERT
        });
        this.dialog = this._modalHelperService.createDialog(config);
        return this.listenDialogAction();
    }
    /**
     * Listens dialog box action and returns observable of boolean
     * @return Observable<boolean>
     */
    private listenDialogAction(): Observable<boolean> {
        return this.dialog.onAction.map(actionItem => {
            if (actionItem.action === TaskConstants.CANCEL_ACTION) {
                this.dialog.close();
                setTimeout(() => {
                    // work around function since canDeactivate guard has open issue when returns false
                    Helper.updateBrowserUrl(this._route.url, '/', 4);
                    if (this.browserBackClicked) {
                        window.location.reload(true);
                        this.browserBackClicked = false;
                    }
                });
                return false;
            } else if (actionItem.action === TaskConstants.OK_ACTION) {
                this.dialog.close();
                return true;
            }
            return true;
        });
    }

    /**
     * Unsubscribes the array of subscriptions
     * @param subscriptions
     */
    private unsubscribe(subscriptions: Subscription[]) {
        if (subscriptions && subscriptions.length > 0) {
            subscriptions.forEach((sub) => {
                if (sub) {
                    sub.unsubscribe();
                }
            });
        }
    }

    ngOnDestroy() {
        if (this._guideService.subscription) {
            this._guideService.subscription.unsubscribe();
        }
        // Unsubscribe the BehaviorSubject Subscription
        if (this._guideService.valueObserverSubscription) {
            this._guideService.valueObserverSubscription.unsubscribe();
        }
        if (this._guideService.errorSubscription) {
            this._guideService.errorSubscription.unsubscribe();
        }
        this._localStorage.remove(TaskEnum.REFERRAL_URL);
        this._taskService.taskSubscription.unsubscribe();
        this.unsubscribe(this.componentSubscriptions);
        this.resetComponent();
    }
}
