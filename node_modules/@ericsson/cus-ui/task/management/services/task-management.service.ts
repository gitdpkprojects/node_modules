import 'rxjs/add/observable/forkJoin';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/map';

import { HttpClient, HttpErrorResponse, HttpParams, HttpResponse } from '@angular/common/http';
import { Inject, Injectable, InjectionToken } from '@angular/core';
import { StateBatch } from '@ericsson/oden/core';
import { COLOR, STATE } from '@ericsson/oden/core/constants';
import { ButtonActionItem } from '@ericsson/oden/core/models';
import {
  DIALOG_TYPE, DialogComponent,
  DialogConfig, ModalHelperService,
  SnackBarService
} from '@ericsson/oden/modules';
import { BehaviorSubject, Observable, Subscription } from 'rxjs/Rx';
import { ActivatedRoute } from '@angular/router';
import { LoggerService } from '../../../logger';
import { TaskConstants } from '../../task.constants';
import { TaskEnum } from '../../task.enum';
import {
  AdditionalData,
  TaskAction,
  TaskList,
  TaskListItem,
  TaskOverview,
  TaskRegistrationModel,
  TaskURIModel
} from './../models';
import { Common } from '../../../common/models';
import { ErrorHandlerService } from '../../../common/services/error.handler.service';

export const TASK_REGISTRATION_URL = new InjectionToken('task_registration_url');
export const CUS_TASK_LIST_URL = new InjectionToken('cus_task_url');
export const TASK_OVERVIEW_URL = new InjectionToken('task_overview_url');

@Injectable()
export class TaskManagementService {
  taskRegistrationData: Array<TaskRegistrationModel> = [];
  private taskLengthSource = new BehaviorSubject<any>('#');
  public taskLength$ = this.taskLengthSource.asObservable();
  public subscription: Subscription = new Subscription();
  errorSubscription: Subscription = new Subscription();
  private dialog: DialogComponent;
  private dialogConfig: DialogConfig;
  private discardedDialogConfig: DialogConfig;
  discardedInstanceIds: Array<string> = [];

  constructor(
    private http: HttpClient,
    private _loggerService: LoggerService,
    private snackBarService: SnackBarService,
    private _modalHelperService: ModalHelperService,
    private _errorHandlerService: ErrorHandlerService,
    private activatedRoute: ActivatedRoute,
    @Inject(TASK_REGISTRATION_URL) public taskRegistrationUrl: string,
    @Inject(CUS_TASK_LIST_URL) public cusTaskListUrl: string,
    @Inject(TASK_OVERVIEW_URL) public overviewUrl: string
  ) {
    this.taskRegistrationData = [];
    let custaskRegistrationData = new TaskRegistrationModel(TaskConstants.CUS_REGISTRATION, '',
      new TaskURIModel(this.cusTaskListUrl, '', ''));
    this.taskRegistrationData.push(custaskRegistrationData);

    this.dialogConfig = new DialogConfig({
      actions: [
        new ButtonActionItem({
          label: TaskConstants.CANCEL_LABEL,
          action: TaskConstants.CANCEL_ACTION
        }),
        new ButtonActionItem({
          label: TaskConstants.OK_LABEL,
          action: TaskConstants.OK_ACTION,
          cssClass: 'primary'
        })
      ],
      type: DIALOG_TYPE.SYSTEM_ALERT
    });

    this.discardedDialogConfig = new DialogConfig({
      actions: [
        new ButtonActionItem({
          label: TaskConstants.OK_LABEL,
          action: TaskConstants.OK_ACTION,
          cssClass: 'primary'
        })
      ],
      type: DIALOG_TYPE.SYSTEM_ALERT
    });
  }

  /**
   * Executes http call to get all-tasks list from the api-endpoint
   * @return {Observable<Array<TaskListItem>>}
   */
  getAllTasks(): Observable<Array<TaskListItem>> {
    if (this.taskRegistrationData && this.taskRegistrationData.length > 0) {
      return this._getTaskData().map(allTasks => {
        this._notify(TaskEnum.ALL_TASKS_TAB_INDEX, allTasks.length.toString());
        return allTasks;
      });
    } else {
      this._loggerService.error(TaskConstants.TASK_REGISTRATION_ERROR);
      throw new Error(TaskConstants.TASK_REGISTRATION_ERROR);
    }
  }

  /**
   * Executes http call to get my-tasks list from the api-endpoint specific to the
   * logged in user
   * @param user
   * @returns { Observable<Array<TaskListItem>> }
   */
  getMyTasks(user: string): Observable<Array<TaskListItem>> {
    let requestOptions = { params: new HttpParams().set(TaskEnum.OWNER, user) };
    if (this.taskRegistrationData && this.taskRegistrationData.length > 0) {
      return this._getTaskData(requestOptions).map(myTasks => {
        this._notify(TaskEnum.MY_TASKS_TAB_INDEX, myTasks.length.toString());
        return myTasks;
      });
    } else {
      this._loggerService.error(TaskConstants.TASK_REGISTRATION_ERROR);
      throw new Error(TaskConstants.TASK_REGISTRATION_ERROR);
    }
  }

  /**
   * Sets TaskListItem registration data from the api end point
   */
  setTaskRegistrations(): void {
    const subscription = this._getTaskRegistrations().subscribe(
      (response: TaskRegistrationModel[]) => {
        this._prepareRegistrationData(response);
      },
      _error => {
        this._prepareRegistrationData();

      }
    )
    this.subscription.add(subscription);
  }

  /**
   * Fetches registration data from the api end point
   */
  _getTaskRegistrations(): Observable<Array<TaskRegistrationModel>> {
    return this.http.get<any>(this.taskRegistrationUrl)
      .catch(this._handleError);
  }

  /**
   * Fetches the task data from multiple end points and returns consolidated data
   * @param options
   */
  _getTaskData(options?: any): Observable<TaskListItem[]> {
    let taskData: TaskListItem[] = [];
    return this._getBatchObservableData(this.taskRegistrationData, options)
      .map((response: Array<TaskList>) => {
        if (response) {
          response.forEach((taskList: TaskList, index) => {
            if (taskList && taskList.tasks) {
              taskList.tasks.forEach((task: TaskListItem) => {
                this._mapParentTask(taskData, task, this.taskRegistrationData[index]);
              });
            }
          });
        }
        return taskData;
      }).catch(this._handleError);
  }

  /**
   * Map the task response for all parent tasks
   * @param {TaskListItem[]} taskData
   * @param {TaskListItem} task
   * @param {TaskRegistrationModel} registrationData
   */
  private _mapParentTask(taskData: TaskListItem[], parentTask: TaskListItem, registrationData: TaskRegistrationModel): void {
    // If task have child task
    if (parentTask.task) {
      parentTask.task = this._mapChildTasks(parentTask.task, registrationData);
    }
    taskData.push(this._mapTaskResponse(parentTask, registrationData));
  }

  /**
   * Map the task response for all child tasks
   * @param {TaskListItem[]} tasks
   * @param {TaskRegistrationModel} registrationData
   * @returns {TaskListItem[]}
   */
  private _mapChildTasks(childTasks: TaskListItem[], registrationData: TaskRegistrationModel): TaskListItem[] {
    const taskItems: TaskListItem[] = [];
    childTasks.forEach((currentTask) => {
      currentTask = this._mapTaskResponse(currentTask, registrationData);
      // If child task have sub child task
      if (currentTask.task) {
        currentTask.task = this._mapChildTasks(currentTask.task, registrationData);
      }
      taskItems.push(currentTask);
    });
    return taskItems;
  }

  /**
  * Returns an observable of data
  * Uses forkjoin to call multiple requests in parallel
  * @returns {Observable<any>}
  */
  private _getBatchObservableData(registrationConfig: Array<TaskRegistrationModel>, options?: any): Observable<Array<TaskList>> {
    let observableBatch = [];
    registrationConfig.forEach(registration => {
      if (options) {
        observableBatch.push(this.http.get<TaskList[]>(registration.uri.list, options)
          .catch(this._handleError));
      } else {
        observableBatch.push(this.http.get<TaskList[]>(registration.uri.list)
          .catch(this._handleError));
      }
    });
    return Observable.forkJoin(observableBatch).catch(this._handleError);
  }

  /**
   * Function that prepares the  registration data
   * @param response
   */
  private _prepareRegistrationData(response?: TaskRegistrationModel[]): void {
    this.taskRegistrationData = [];
    let custaskRegistrationData = new TaskRegistrationModel(TaskConstants.CUS_REGISTRATION, '',
      new TaskURIModel(this.cusTaskListUrl, '', ''));
    this.taskRegistrationData.push(custaskRegistrationData);
    if (response) {
      response.forEach((registration: TaskRegistrationModel) => {
        if (registration.uri && registration.uri.list && registration.tpg && registration.screenPath) {
          this.taskRegistrationData.push(new TaskRegistrationModel(
            registration.tpg,
            registration.screenPath,
            registration.uri
          ));
        } else {
          throw new Error(TaskConstants.REQUIRED_FIELD_MISSING);
        }
      });
    }
  }

  /**
   * Function to map the data from api endpoint to the Tasklist model
   * taking
   * @param response
   * @returns {TaskListItem}
   */
  private _mapTaskResponse(response: TaskListItem, registrationData: TaskRegistrationModel): TaskListItem {
    if (response && response.id && response.type && response.name && response.state && registrationData.tpg) {
      let taskData: TaskListItem = new TaskListItem(response);
      taskData.screenPath = this._getScreenPath(response.additionalData);
      taskData.state = this._getStateBadge(<any>response.state);
      taskData.taskDisplayName = response.name + ' - ' + response.instanceName;
      taskData.customerName = this._extractData(response.additionalData, TaskEnum.TYPE_RESOURCE);
      taskData.instanceId = this._extractData(response.additionalData, TaskEnum.INSTANCE_ID);
      taskData.workflowId = this._extractData(response.additionalData, TaskEnum.WORKFLOW_ID);
      taskData.assignUrl = this._replaceTokens(registrationData.uri.assign, response.id);
      taskData.revokeUrl = this._replaceTokens(registrationData.uri.revoke, response.id);
      taskData.listUrl = registrationData.uri.list;
      return taskData;
    } else {
      throw new Error(TaskConstants.REQUIRED_FIELD_MISSING);
    }
  }

  /**
   * Gets State Badge
   * @param state
   */
  private _getStateBadge(state: string): StateBatch {
    switch (state.toLowerCase()) {
      case TaskConstants.ASSIGNED_ACTION:
        return new StateBatch({ state: STATE.CUSTOM, label: state, color: COLOR.BRAND_COLOR_1, semiTransparent: true });
      case TaskConstants.NEW_ACTION:
        return new StateBatch({ state: STATE.CUSTOM, label: state, color: COLOR.BRAND_COLOR_1, outlined: true });
      case TaskConstants.PAUSED_ACTION:
        return new StateBatch({ state: STATE.DRAFT, color: COLOR.DRAFT, label: state });
      default:
        return new StateBatch({ state: STATE.CUSTOM, color: COLOR.BRAND_COLOR_1, label: state });
    }
  }

  /**
   * Error handler which throws error to the subscriber when some
   * error is encountered
   */
  private _handleError(error: HttpErrorResponse) {
    return Observable.throw(error);
  }

  /**
   * Extracts required data from the object and  returns it
   * @param Array<AdditionalData>,keyvalue:string
   * @returns {string}
   */
  private _extractData(additionalData: Array<AdditionalData>, key: string): string {
    let value = '';
    if (additionalData && additionalData.length > 0) {
      let data = additionalData.find(item => {
        return item.key === key;
      });
      value = data ? data.value : '';
    }
    return value;
  }

  /**
   * Construct screen path based on the task type ( CUS or other TPG task)
   * @param additionalData: Array<AdditionalData> taskId: string
   * @returns {string}
   */
  private _getScreenPath(additionalData: Array<AdditionalData>): string {
    let basePath = TaskConstants.GUIDE_ROUTE_PATH;
    let instaneId = this._extractData(additionalData, TaskEnum.INSTANCE_ID);
    let workflowId = this._extractData(additionalData, TaskEnum.WORKFLOW_ID);
    return `${basePath}/${workflowId}/${instaneId}`;
  }

  /**
   * Post the data
   * @param url: string, data: any
   * @returns any
   */
  _postData(url: string, data: TaskAction): Observable<any> {
    return this.http.post(url, data)
      .catch(this._handleError);
  }

  /**
   * Sets task length
   * @param length
   */
  private _notify(key: number, length: string): void {
    this.taskLengthSource.next({ tabIndex: key, length: length });
  }

  /**
   * API to get process/instance overview
   * @param workflowdefinitionId
   * @param instanceId
   */
  getProcessOverview(workflowdefinitionId: string, instanceId: string): Observable<Array<TaskOverview>> {
    return this.http.get<any>(`${this.overviewUrl}/${workflowdefinitionId}/instance/${instanceId}`)
      .map((value: HttpResponse<any>) => {
        return this._mapOverviewResponse(value[0].tasks);
      })
  }

  /**
   * Map Overview response
   * @param overview
   */
  private _mapOverviewResponse(overview: Array<TaskOverview>): Array<TaskOverview> {
    overview.forEach((value, index) => {
      value.serialNo = index + 1;
    });
    return overview;
  }

  /**
   * Replace Tokens
   * @param link
   * @param taskId
   */
  private _replaceTokens(link: string, taskId: string): string {
    let replacedLink = '';
    if (link && taskId) {
      const regex = link.match(/\[\%taskid\]/ig);
      replacedLink = link.replace(regex[0], taskId);
    }
    return replacedLink;
  }

  /**
   * API that discards any workflow instance
   * @param data
   */
  discardInstance(data: TaskListItem): Observable<any> {
    return this.http.delete(`${this.cusTaskListUrl}/${data.instanceId}`)
      .catch(this._handleError);
  }

  /**
   * Shows Dialog for discard instance
   */
  _discard(data: TaskListItem): Observable<boolean> {
    return new Observable((observer) => {
      (<any>this.dialogConfig).message =
        ` <p>${TaskConstants.DISCARD_MESSAGE_PART1} ${data.instanceName} ${TaskConstants.DISCARD_MESSAGE_PART2} </p>`;
      this.dialog = this._modalHelperService.createDialog(this.dialogConfig);
      this.dialog.onAction.subscribe((actionItem) => {
        if (actionItem.action === TaskConstants.OK_ACTION) {
          this.dialog.close();
          this.discardInstance(data).subscribe(() => {
            // Push the deleted task instance id into discardedTasksData array
            this.discardedInstanceIds.push(data.instanceId);
            this.snackBarService.open(`${data.instanceName} ${TaskConstants.DISCARD_SNACKBAR_SUCCESS_MESSAGE}`);
            observer.next(true);
          }, (error) => {
            this._handleTaskErrors(error, TaskConstants.OK_ERROR_ACTION);
            observer.next(false);
          });
        } else {
          this.dialog.close();
          observer.next(false);
        }
      });
    });
  }

  /**
   * Handle errors dialog
   */
  private _handleTaskErrors(error, action: string) {
    if (!error.error || (error.error && !error.error.status && !error.error.code)) {
      return;
    }
    this.errorSubscription = this._errorHandlerService.getErrorInfo(error.error)
      .subscribe((errorResult: Common.Error) => {
        this._errorDialog(errorResult, action);
      });
  }

  private _errorDialog(error, action) {
    let config: DialogConfig = new DialogConfig({
      title: `${error.status} - ${error.message}`,
      message: `${error.details}.Please contact administrator(Error code: ${error.code})`,
      actions: [
        new ButtonActionItem({
          label: TaskConstants.OK_LABEL,
          action: action,
          cssClass: 'primary'
        })],
      type: DIALOG_TYPE.SYSTEM_ALERT
    });
    let dialog = this._modalHelperService.createDialog(config);
    dialog.onAction.subscribe((actionItem) => {
      if (actionItem.action === TaskConstants.OK_ERROR_ACTION) {
        dialog.close();
      }
    });
  }

  /**
   * Close the opened task window while task was discarded
   */
  _closeCurrentTask(): Observable<boolean> {
    return new Observable((observer) => {
      (<any>this.discardedDialogConfig).message = `<p>${TaskConstants.DISCARDED_MESSAGE}</p>`;
      // Create the alert dialog box
      this.dialog = this._modalHelperService.createDialog(this.discardedDialogConfig);
      this.dialog.onAction.subscribe((actionItem) => {
        if (actionItem.action === TaskConstants.OK_ACTION) {
          // Prevent from Save changes dialog box
          this.activatedRoute.snapshot.data = { exitGuidedView: true };
          this.dialog.close();
          observer.next();
        }
      });
    });
  }

}
