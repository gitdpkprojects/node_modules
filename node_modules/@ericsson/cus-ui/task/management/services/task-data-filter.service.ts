import { Injectable } from '@angular/core';
import {
    ActionItem,
    OptionItem
} from '@ericsson/oden/core';
import * as _ from 'lodash';
import { Subject } from 'rxjs';
import { TaskEnum } from '../../task.enum';
import { GroupByFilterData, TaskListItem, CategoryOptionGroup } from '../models';

@Injectable()
export class TaskDataFilterService {

    private _rowClickEvent = new Subject();
    onRowClick$ = this._rowClickEvent.asObservable();

    constructor() { }

    /**
     * Function for match the filter text with task item
     * @param {TaskListItem} item
     * @param {string} filterText
     * @returns {boolean}
     */
    _isTextMatch(item: TaskListItem, filterText: string): boolean {
        const searchString = filterText ? filterText : '';
        const search = new RegExp(searchString, 'gi');

        if ((item.taskDisplayName && item.taskDisplayName.match(search))
            || (item.workflowName && item.workflowName.match(search))
            || (item.assignee && item.assignee.match(search))
            || (item.owner && item.owner.match(search))
            || (item.dueDate && item.dueDate.toString().match(search))) {
            return true;
        }
        return false;
    }

    /**
     * Function to filter the data which is matched to the category selection
     * @param {TaskListItem} task
     * @param {any} selections
     * @param {string} column
     * @returns {boolean}
     */
    _isCategoryMatch(task: TaskListItem, selections: any, column: string): boolean {
        if (!selections || !selections.items || !selections.field) {
            return true;
        }
        const items = selections.items.map((o) => o.data.field);
        return items.filter((item) => {
            if (task[column].indexOf(item) > -1) {
                return true;
            }
            return false;
        }).length > 0;
    }

    /**
     * Populates the category filters based on the response
     * @param {Array<TaskListItem} data
     * @param {Array<CategoryOptionGroup} categoryFilters
     * @returns {Array<CategoryOptionGroup>}
     */
    _getCategoryFilters(data: Array<TaskListItem>,
        categoryFilters: Array<CategoryOptionGroup>): Array<CategoryOptionGroup> {
        categoryFilters.forEach((categoryFilter) => {
            categoryFilter.items = this._populateCategoryFilters(data, categoryFilter.field);
        });
        return categoryFilters;
    }

    /**
     * Get group by data
     * @param {ActionItem} item
     * @param {Array<TaskListItem>} taskData
     * @param {any[]} taskListHeaders
     * @returns {Array<GroupByFilterData>}
     */
    _getGroupByData(item: ActionItem, taskData: Array<TaskListItem>, taskListHeaders: any[]): Array<GroupByFilterData> {
        let groupByData: GroupByFilterData[] = [];
        if (item && item.action && item.action !== TaskEnum.ALL_ACTION && taskData && taskData.length > 0) {
            taskData.forEach((data) => {
                // This has already been grouped.
                if (taskData.indexOf(data) === -1) {
                    return;
                }
                // Get all matching rows
                let matches = taskData.filter(
                    (row) => {
                        if (item.action === TaskEnum.STATE_FIELD) {
                            return data[item.action].label === row[item.action].label;
                        } else {
                            return data[item.action] === row[item.action];
                        }
                    }
                );
                groupByData.push({
                    data: matches,
                    header: _.cloneDeep(taskListHeaders),
                    name: data[item.action],
                    isPagination: matches.length > 1
                });
                if (matches.length > 0) {
                    taskData = taskData.filter(
                        (row) => {
                            if (item.action === TaskEnum.STATE_FIELD) {
                                return data === row ||
                                    data[item.action].label !== row[item.action].label;
                            } else {
                                return data === row ||
                                    data[item.action] !== row[item.action];
                            }
                        }
                    );
                }
            });
        } else {
            groupByData.push({
                data: taskData,
                header: _.cloneDeep(taskListHeaders),
                isPagination: taskData.length > 1
            });
        }
        return groupByData;
    }

    /**
     * Populate Category Filters
     * @param {Array<TaskListItem>} data
     * @param {string} field
     * @returns {Array<OptionItem>}
     */
    private _populateCategoryFilters(data: Array<TaskListItem>, field: string): Array<OptionItem> {
        let items: Array<OptionItem> = [];
        items = Array.from(new Set(data.map((item: TaskListItem) => item[field])))
            .map((item) => new OptionItem({ label: item, selected: true, data: { field: item } }))
        return items;
    }
}
