import { Router } from '@angular/router';
import { HttpErrorResponse } from '@angular/common/http';
import {
  Component, OnDestroy,
  OnInit, ViewChild, ViewEncapsulation
} from '@angular/core';
import {
  ELEMENT_OVERLAY_STATE,
  LIST_CONTROLLER_CONTEXT, ActionItem,
  ElementOverlayConfig,
  NavigationHelper,
  OptionItem,
  UniversalService,
  IRowClickEvent,
  HeaderComponent
} from '@ericsson/oden';
import * as _ from 'lodash';
import { Subscription } from 'rxjs/Subscription';
import { UserProfileService } from '../../../../common';
import { LocalStorage } from '../../../../core/storage/localstorage.strategy';
import { Helper } from '../../../../common/utils';
import { LoggerService } from '../../../../logger';
import { TaskConstants } from '../../../task.constants';
import { TaskEnum } from '../../../task.enum';
import { TaskAction, TaskData, TaskListItem, CategoryOptionGroup } from '../../models';
import { TaskDataFilterService } from '../../services/task-data-filter.service';
import { TaskManagementService } from '../../services/task-management.service';
import { TASK_LIST, TASK_TAB } from '../../task-animation.constants';
import { TaskDetailsComponent } from '../task-details/task-details.component';
import { TaskHelper, TaskParamModel } from '../../../task.helper';

@Component({
  selector: 'cus-task-list',
  templateUrl: './task-list.component.html',
  styleUrls: ['./task-list.component.scss'],
  encapsulation: ViewEncapsulation.None,
  animations: [TASK_TAB.ANIMATION, TASK_LIST.FADE]
})
export class TaskListComponent implements OnInit, OnDestroy {

  @ViewChild('taskDetails') taskDetailsComponent: TaskDetailsComponent;
  animationDirection: string = '';
  tableHeaders: Array<any> = [];
  tableFilterText: string = '';
  singleActionItems: Array<ActionItem> = [];
  tableCategoryFilters: Array<CategoryOptionGroup> = [];
  groupByFilter: ActionItem[] = [];
  tableData: any = [];
  overlayConfig: ElementOverlayConfig = new ElementOverlayConfig({
    state: ELEMENT_OVERLAY_STATE.NONE
  });
  errorType: string = '';
  errorText: string = '';
  displayLoader: boolean = false;
  showDetails: boolean = false;
  selectedGroupByFilter: ActionItem;
  taskEnums = TaskEnum;
  listControllerContext: LIST_CONTROLLER_CONTEXT = LIST_CONTROLLER_CONTEXT.TABLE;
  private _taskListData: Array<TaskListItem> = [];
  private _subscription: Subscription = new Subscription();
  private _activeTab: number = 0;
  private _selectedAssignees: any = {};
  private _selectedInstances: any = {};

  constructor(private _taskManagementService: TaskManagementService,
    private _taskDataFilterService: TaskDataFilterService,
    private _userProfileService: UserProfileService,
    private _loggerService: LoggerService,
    private router: Router,
    private universalService: UniversalService,
    private _localStorage: LocalStorage) { }

  ngOnInit() {
    this.tableHeaders = this._setTableHeaders();
    this.tableCategoryFilters = this._setCategoryFilters();
    this.singleActionItems = this._setSingleActionItems();
    this.groupByFilter = this._setGroupByFilterData();
    this.selectedGroupByFilter = this.groupByFilter[0];
    setTimeout(() => {
      this._setTableData();
    });

    // Subscribe the event while UniversalOverlay close
    let overlaySubscription = this.universalService.onCloseUniversalOverlay.subscribe(() => {
      this._handlerForDiscardedTask();
    });
    this._subscription.add(overlaySubscription);
  }

  /**
   * Handle the discarded task if currently opening in window
   * @returns {void}
   */
  private _handlerForDiscardedTask(): void {
    const discardedInstanceIds: Array<string> = this._taskManagementService.discardedInstanceIds;
    const taskParams: TaskParamModel = TaskHelper.getTaskParams();

    if (taskParams && discardedInstanceIds && discardedInstanceIds.length > 0) {
      // Check task instance id is exist or not in discardedTasksData
      const isCurrentTaskDiscarded: boolean = discardedInstanceIds.indexOf(taskParams.instanceId) > -1;

      if (isCurrentTaskDiscarded) {
        // Trigger the task closed modal
        let discardedTaskSubscription = this._taskManagementService._closeCurrentTask().subscribe(() => {
          let path = this._localStorage.get(TaskEnum.REFERRAL_URL);
          NavigationHelper.navigateToRoute(path.referralUrl, this.router);
          this._taskManagementService.discardedInstanceIds = [];
        });
        this._subscription.add(discardedTaskSubscription);
      }
    }
  }

  /**
  * Populates tasks for the logged in user
  * @returns {void}
  */
  loadMyTasks(): void {
    this._activeTab = TaskEnum.MY_TASKS_TAB_INDEX;
    this._reset();
    this._showLoading(true);
    this._userProfileService.getProfileData().subscribe((profile) => {
      let userName = profile.profile.userName;
      let myTasksSubscription = this._taskManagementService.getMyTasks(userName).subscribe(
        (response: TaskListItem[]) => {
          this.populateTable(response, TaskEnum.MY_TASKS_ACTION);
          this._showLoading(false);
        },
        (error) => {
          this._showLoading(false);
          this._displayError(error, TaskEnum.MY_TASKS_ACTION);
        }
      );
      this._subscription.add(myTasksSubscription);
    });
  }

  /**
   * Populates all tasks for the logged in user
   * @returns {void}
   */
  loadAllTasks(): void {
    this._activeTab = TaskEnum.ALL_TASKS_TAB_INDEX;
    this._reset();
    this._showLoading(true);
    let allTasksSubscription = this._taskManagementService.getAllTasks().subscribe((response: TaskListItem[]) => {
      this.populateTable(response, TaskEnum.ALL_TASKS_ACTION);
      this._showLoading(false);
    },
      (error) => {
        this._showLoading(false);
        this._displayError(error, TaskEnum.ALL_TASKS_ACTION);
      }
    );
    this._subscription.add(allTasksSubscription);
  }

  /**
   * Maps response to the table
   * @param response
   * @param type
   * @returns {void}
   */
  private populateTable(response, type): void {
    if (((response && response.length === 0) || (!response))) {
      let text = (type === TaskEnum.MY_TASKS_ACTION) ?
        TaskConstants.MYTASKS_NO_RECORDS_SUB_MESSAGE : TaskConstants.ALLTASKS_NO_RECORDS_SUB_MESSAGE;
      this._setOverlayConfig(ELEMENT_OVERLAY_STATE.NOTICE, TaskConstants.NO_RECORDS_MESSAGE, text, true, [])
    } else {
      this.overlayConfig.state = ELEMENT_OVERLAY_STATE.NONE;
      this._setAdditionalProperties(response);
      this._taskListData = _.cloneDeep(response);
      this._getCategoryFilters();
      this._setTableData();
    }
  }

  /**
   * Funcion to add specific properties for nested table
   * @param {TaskListItem[]} tasks
   */
  private _setAdditionalProperties(tasks: TaskListItem[]): void {
    tasks.forEach((task) => {
      task.searchMatch = true;
      task.isExpanded = false;
      // Add the properties if task has child tasks
      if (task.task) {
        this._setAdditionalProperties(task.task)
      }
    });
  }

  /**
   * Sets the display data for the table
   * @returns {void}
   */
  private _setTableData(): void {
    this.tableData = [];
    this.tableData.push({
      data: this._taskListData,
      header: this.tableHeaders,
    });
  }

  /**
   * Callback function that will filter the table data based on user input
   * in the table filter
   * @param {string} filter
   * @returns {void}
   */
  _onFilterTable(filter: string): void {
    this.tableFilterText = filter;
    this._setFilteredDisplayData();
  }

  /**
   * Initiated function to filter table data
   * @returns {void}
   */
  private _setFilteredDisplayData(): void {
    const taskData: TaskListItem[] = this._taskListData;
    taskData.forEach((item) => {
      this._filterChildData(item);
    });
    // Check the filtered result is empty or not
    const isNoData = taskData.find((t) => t.searchMatch);
    if (!isNoData) {
      this._setOverlayConfig(ELEMENT_OVERLAY_STATE.NOTICE, TaskConstants.NO_MATCHING_RESULTS_MESSAGE, '', true);
    } else {
      this.overlayConfig.state = ELEMENT_OVERLAY_STATE.NONE;
    }
    this.tableData.data = taskData;
  }

  /**
   * Nested table filter to check childrens
   * @param {TaskListItem} item
   * @returns {boolean}
   */
  private _filterChildData(item: TaskListItem): boolean {
    item.searchMatch = false;

    // Search recursive in child Tasks
    if (item.task) {
      const matches = [];
      item.task.forEach((elem) => {
        matches.push(this._filterChildData(elem));
      });
      item.searchMatch = matches.includes(true);
    }

    const isTextMatch = this._taskDataFilterService._isTextMatch(item, this.tableFilterText);
    const isAssigneeMatch = this._taskDataFilterService._isCategoryMatch(item, this._selectedAssignees, TaskEnum.ASSIGNEE_FIELD);
    const isInstanceMatch = this._taskDataFilterService._isCategoryMatch(item, this._selectedInstances, TaskEnum.INSTANCE_NAME_FIELD);

    // Check the all filters result
    if (isTextMatch && isAssigneeMatch && isInstanceMatch) {
      item.searchMatch = true;
    }

    item.isExpanded = item.searchMatch;
    return item.searchMatch;
  }

  /**
   * Sets the overlay with the properties passed. Usefull when the error messages are to be shown.
   * @param state
   * @param label
   * @param text
   * @param inlinePlaceholder
   * @param actions
   * @returns {void}
   */
  private _setOverlayConfig(state: ELEMENT_OVERLAY_STATE, label: string,
    text: string, inlinePlaceholder?: boolean, actions?: ActionItem[]): void {
    this.overlayConfig.state = state || ELEMENT_OVERLAY_STATE.NONE;
    this.overlayConfig.label = label || '';
    this.overlayConfig.text = text || '';
    this.overlayConfig.inlinePlaceholder = inlinePlaceholder || false;
    this.overlayConfig.actions = actions || [];
  }

  /**
   * Sets the grouped table data
   * @param {ActionItem} item
   * @returns {void}
   */
  _onTableGroupBy(item: ActionItem): void {
    this.selectedGroupByFilter = item;
    // Get the group by data from the helper function
    this.tableData = this._taskDataFilterService._getGroupByData(this.selectedGroupByFilter, this._taskListData, this.tableHeaders);
  }

  /**
   * Callbacks for customize option item
   * @param {Array<OptionItem>} array
   * @param {string} field
   * @returns {void}
   */
  _onCategoryFilter(items: Array<OptionItem>, field: string): void {
    if (field === TaskEnum.ASSIGNEE_FIELD) {
      this._selectedAssignees = { field: field, items: items };
    } else {
      this._selectedInstances = { field: field, items: items };
    }
    this._setFilteredDisplayData();
  }

  /**
   * Populates category filters based on the response
   * @returns {void}
   */
  private _getCategoryFilters(): void {
    this.tableCategoryFilters = this._setCategoryFilters();
    this.tableCategoryFilters = this._taskDataFilterService._getCategoryFilters(this._taskListData, this.tableCategoryFilters);
  }

  /**
   * Function that retries loading the data when the user clicks  on the
   * retry loading button
   * @param {ActionItem} retryAction
   * @returns {void}
   */
  _onRetryLoading(action: ActionItem): void {
    if (action.action === TaskEnum.MY_TASKS_ACTION) {
      this.loadMyTasks();
    } else if (action.action === TaskEnum.ALL_TASKS_ACTION) {
      this.loadAllTasks();
    }
  }

  /**
   * Function that call when user click the action button in row
   * @param {ActionItem} action
   * @param {TaskListItem} row
   * @returns {void}
   */
  _onSingleAction(action: ActionItem, task: TaskListItem): void {
    switch (action.action) {
      case TaskEnum.ASSIGN_TASK_ACTION: {
        this._assignTask(task);
        break;
      }
      case TaskEnum.RESUME_TASK_ACTION: {
        if (task) {
          this._navigateToScreenPath(task.screenPath, task.workflowId);
        }
        break;
      }
      case TaskEnum.DETAILS_TASK_ACTION: {
        if (task) {
          this._displayDetails(task);
        }
        break;
      }
      case TaskEnum.DISCARD_TASK_ACTION: {
        this._discardTask(task);
        break;
      }
      default: {

      }
    }
  }

  /**
   * Function that prepares the assign data and calls post method
   * @param {TaskListItem} item
   * @returns {void}
   */
  _assignTask(item: TaskListItem): void {
    let postData = new TaskAction();
    let url = '';
    if (item) {
      url = item.assignUrl;
      postData.action = TaskEnum.ASSIGN_TASK_ACTION;
      postData.tasks = [];
      postData.tasks.push(new TaskData(item.id));
      let postSubscription = this._taskManagementService._postData(url, postData).subscribe(
        () => { },
        error => {
          this._loggerService.error(error);
        }
      );
      this._subscription.add(postSubscription);
    }
  }

  ngOnDestroy(): void {
    // Unsubscribe every subscription
    this._subscription.unsubscribe();
  }

  /**
  * Displays error messsage when the table data loading fails
  * @param {HttpErrorResponse} error
  * @param {string} action
  * @returns {void}
  */
  private _displayError(error: HttpErrorResponse, action: string): void {
    let errorText = Helper.getErrorText(error);
    errorText = errorText.length > 0 ? `${errorText},` : '';
    if (errorText) {
      errorText += TaskConstants.TASKS_ERROR_TEXT_2;
    } else {
      errorText = `${TaskConstants.TASKS_ERROR_TEXT_1} ${TaskConstants.TASKS_ERROR_TEXT_2}`;
    }
    let retryActionItem = [new ActionItem({ label: TaskConstants.RETRY_LABEL, action: action })];
    this._setOverlayConfig(ELEMENT_OVERLAY_STATE.ERROR, TaskConstants.TASKS_ERROR_LABEL, errorText, true, retryActionItem);
  }

  /**
   * Shows the loader till the data is available from the api endpoint
   * @param {boolean} show
   * @returns {void}
   */
  private _showLoading(show: boolean): void {
    this.displayLoader = show;
  }

  /**
   * Navigates to the path specified if the path is already not active.
   * If path is already active. It just closes the UL.
   * @param {string} path
   * @param {string} workflowDefinitionId
   * @returns {void}
   */
  _navigateToScreenPath(path: string, workflowDefinitionId: string) {
    setTimeout(() => {
      this.showDetails = false;
    });
    TaskHelper.saveReferralUrl(this._localStorage, workflowDefinitionId, TaskEnum.HOME);
    if (path) {
      if (!this.router.isActive(path, false)) {
        NavigationHelper.navigateToPath(path, this.router);
      } else if (this.universalService.isOpen) {
        this.universalService.hideUniversalOverlay();
      }
    }
  }

  /**
   * Set Headers for tasks list table
   * @returns {any[]}
   */
  private _setTableHeaders(): any[] {
    return [{
      label: TaskConstants.TASK_LABEL,
      action: TaskEnum.TASK_DISPLAY_NAME_FIELD
    }, {
      label: TaskConstants.WORKFLOW_LABEL,
      action: TaskEnum.INSTANCE_NAME_FIELD
    }, {
      label: TaskConstants.ASSIGNED_TO,
      action: TaskEnum.ASSIGNEE_FIELD
    }, {
      label: TaskConstants.OWNER,
      action: TaskEnum.OWNER_FIELD
    }, {
      label: TaskConstants.DUE_DATE,
      action: TaskEnum.DUE_DATE_FIELD
    }, {
      label: TaskConstants.STATE_LABEL,
      action: TaskEnum.STATE_FIELD
    }];
  }

  /**
   * Set Action Items for TaskLists table
   * @returns {ActionItem[]}
   */
  private _setSingleActionItems(): ActionItem[] {
    return [
      new ActionItem({ label: TaskConstants.RESUME_LABEL, action: TaskEnum.RESUME_TASK_ACTION }),
      new ActionItem({ label: TaskConstants.DETAILS_LABEL, action: TaskEnum.DETAILS_TASK_ACTION }),
      new ActionItem({ label: TaskConstants.DISCARD_LABEL, action: TaskEnum.DISCARD_TASK_ACTION })
    ];
  }

  /**
   * Set Filters for Task Lists Table
   * @returns {ActionItem[]}
   */
  private _setGroupByFilterData(): ActionItem[] {
    let groupByActionItems: ActionItem[] = [new ActionItem({ label: TaskConstants.ALL_LABEL, action: TaskEnum.ALL_ACTION })];
    this.tableHeaders.forEach(item => {
      groupByActionItems.push(new ActionItem({ label: item.label, action: item.action }));
    })
    return groupByActionItems;
  }

  /**
   * Set Category Filters
   * @returns {CategoryOptionGroup[]}
   */
  private _setCategoryFilters(): CategoryOptionGroup[] {
    return [
      new CategoryOptionGroup({
        label: `${TaskConstants.ASSIGNED_TO}:`,
        field: `${TaskEnum.ASSIGNEE_FIELD}`,
        items: []
      }),
      new CategoryOptionGroup({
        label: `${TaskConstants.WORKFLOW_LABEL}:`,
        field: `${TaskEnum.INSTANCE_NAME_FIELD}`,
        items: []
      })
    ];
  }

  /**
   * Get the rowItem from the row component
   * @param {IRowClickEvent} rowItem
   * @returns {void}
   */
  _onRowClick(rowItem: IRowClickEvent): void {
    if (rowItem.row.data) {
      this._displayDetails(rowItem.row.data);
    }
  }

  /**
   * Hides the list component and displays the details component.
   * @param {TaskListItem} task
   * @returns {void}
   */
  _displayDetails(task: TaskListItem): void {
    if (!task) {
      return;
    }
    this._toggleDetails(true);
    setTimeout(() => {
      this.taskDetailsComponent.initComponent(task);
    });
  }

  /**
   * Toggles the details component.
   * @param {boolean} visible
   * @returns {void}
   */
  _toggleDetails(visible: boolean): void {
    this.showDetails = visible;
  }

  /**
   * Discards the task based on the task passed
   * @param {TaskListItem} task
   * @returns {void}
   */
  _discardTask(task: TaskListItem): void {
    this._taskManagementService._discard(task).subscribe((taskDiscarded) => {
      if (taskDiscarded) {
        this.showDetails = false;
        if (this._activeTab === TaskEnum.MY_TASKS_TAB_INDEX) {
          this.loadMyTasks();
        } else {
          this.loadAllTasks();
        }
      }
    });
  }

  /**
   * Reset to all the task data's
   * @returns {void}
   */
  private _reset(): void {
    this._taskListData = [];
    this.tableFilterText = '';
    this._setTableData();
    this.overlayConfig.state = ELEMENT_OVERLAY_STATE.NONE;
    this.errorType = '';
    this.errorText = '';
  }

  /**
   * Function to show the element overlay message when user
   * unhide all table columns
   * @param {HeaderComponent[]} columns
   */
  _columnVisibilityChanged(columns: Array<HeaderComponent>): void {
    if (columns.length >= 1) {
      this.overlayConfig.state = ELEMENT_OVERLAY_STATE.NONE;
    } else {
      this._setOverlayConfig(ELEMENT_OVERLAY_STATE.NOTICE, TaskConstants.NO_COLUMNS_SELECTED_MESSAGE,
        '', true);
    }
  }

}
