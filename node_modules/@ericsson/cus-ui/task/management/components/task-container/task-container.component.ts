import {
    AfterViewInit,
    Component,
    ComponentFactoryResolver,
    ComponentRef,
    ViewChild,
    ViewContainerRef,
    OnDestroy
} from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { TAB_VIEW, TabViewService, UniversalTabView, UniversalService } from '@ericsson/oden';

import { TaskConstants } from '../../../task.constants';
import { TaskEnum } from '../../../task.enum';
import { TabsItem } from '../../models/tabs-item.model';
import { TASK_TAB_ANIMATION_STATES } from '../../task-animation.constants';
import { TaskListComponent } from '../task-list/task-list.component';
import { TaskManagementService } from '../../services/task-management.service';
import { Subscription } from 'rxjs/Subscription';


@Component({
    selector: 'cus-task-container',
    templateUrl: 'task-container.component.html',
    styleUrls: ['task-container.component.scss'],
    animations: [TAB_VIEW.ANIMATION]
})

export class TaskContainerComponent extends UniversalTabView implements AfterViewInit, OnDestroy {

    @ViewChild('output', { read: ViewContainerRef }) output: ViewContainerRef;

    private component: TaskListComponent;
    private componentRef: ComponentRef<any>;
    private currentIndex = 0;
    tabs = [];
    subscription: Subscription = new Subscription();

    constructor(private componentFactoryResolver: ComponentFactoryResolver, tabViewService: TabViewService,
        activatedRoute: ActivatedRoute, private _universalService: UniversalService, private taskService: TaskManagementService) {
        super(tabViewService, activatedRoute);
        this.tabs = [
            new TabsItem(TaskEnum.MY_TASKS_TAB_INDEX, `${TaskConstants.MY_TASKS_LABEL} (#)`, null, true),
            new TabsItem(TaskEnum.ALL_TASKS_TAB_INDEX, `${TaskConstants.ALL_TASKS_LABEL} (#)`, null, false)
        ];

        this.subscription.add(
            this._universalService.onShowUniversalOverlay.subscribe(() => {
                this._loadTask(this.currentIndex);
            })
        );
    }

    ngAfterViewInit() {
        this.setContentComponent();
        this._loadTask(TaskEnum.MY_TASKS_TAB_INDEX);
    }

    /**
     * Function to set component that will be displayed inside the TaskContainerComponent
     */
    setContentComponent() {
        const factory = this.componentFactoryResolver.resolveComponentFactory(TaskListComponent);
        const componentRef = this.output.createComponent(factory);
        this.componentRef = componentRef;
        this.component = componentRef.instance;
    }

    /**
     * Callback for tabChange
     * @param action
     */
    onTabChange(action: TabsItem) {
        this._renderTab(action.id);
    }

    /**
     * Renders the tab based on the tab index.
     * If the index is more than 0, all tasks will be loaded else myTask.
     * @param index
     */
    private _renderTab(index: number) {
        if (index === this.currentIndex && this.component) {
            return;
        }
        // Have a backup of the component reference to destroy the component after the animation.
        let componentRef = this.componentRef;
        // Chose the animation direction
        let direction = index > this.currentIndex ? TASK_TAB_ANIMATION_STATES.MOVE_OUT_LEFT : TASK_TAB_ANIMATION_STATES.MOVE_OUT_RIGHT;
        this.component.animationDirection = direction;
        setTimeout(() => {
            // Animation over, destroy the component.
            componentRef.destroy();
        }, 200);

        setTimeout(() => {
            this.setContentComponent();
            this._loadTask(index);
            Promise.resolve().then(() => {
                // Now render the new component with opposite direction.
                this.component.animationDirection = direction === TASK_TAB_ANIMATION_STATES.MOVE_OUT_LEFT ?
                    TASK_TAB_ANIMATION_STATES.MOVE_IN_RIGHT : TASK_TAB_ANIMATION_STATES.MOVE_IN_LEFT;
            });
            this.currentIndex = index;
        });
    }

    /**
     * Loads the tasks based on the current index we are in.
     * @param index
     */
    private _loadTask(index: number) {
        if (index === TaskEnum.ALL_TASKS_TAB_INDEX) {
            this.component.loadAllTasks();
        } else {
            this.component.loadMyTasks();
        }
        this.updateTaskLength();
    }

    private updateTaskLength() {
        this.taskService.taskLength$.subscribe((taskDetail) => {
            setTimeout(() => {
                if (taskDetail && this.currentIndex === taskDetail.tabIndex) {
                    this.tabs[this.currentIndex].title = this.tabs[this.currentIndex].title.replace(/\(.+?\)/, `(${taskDetail.length})`);
                }
            });
        })
    }

    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
