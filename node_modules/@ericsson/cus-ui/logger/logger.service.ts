import {Injectable, Optional} from '@angular/core';
import {Level} from './models';
import {Options} from './models';
import {Error} from './models';

/*
* For browsers that don't implement the debug method, log will be used instead.
*/

const CONSOLE_DEBUG_METHOD = console['debug'] ? 'debug' : 'log';

const DEFAULT_OPTIONS: Options = {
    level: Level.TRACE,
    logtoconsole: false,
};

@Injectable()
export class LoggerService {
    private _level: Level;
    private _logStore: Array<Error>;
    public Level: any = Level;
    private _logtoconsole: boolean;

    constructor( @Optional() options?: Options) {

        let { level, logtoconsole } = Object.assign( {}, DEFAULT_OPTIONS, options );
        this._logtoconsole = logtoconsole;
        this._level = level;
        this._logStore = [];
    }

    /**
     * get error message
     */
    private getError(level: string, message?: any): Error {
        let error = new Error();
        error.level = level;
        let msg = '', stack = '';
        if (message) {
            if (message.toString() === '[object Object]') {
                msg = JSON.stringify(message);
            } else if (message.message || message.stack) {
                msg = message.message;
                stack = message.stack;
            } else {
                msg = message.toString();
            }
        }
        error.message = msg;
        error.stack = stack;
        error.url = this.getUrl();
        error.module = this.getModule(error.url);
        error.datetime = new Date();
        return error;
    }

    /**
     * add error message to logStore
     */
    error(message: any) {
        if (this.isErrorEnabled()) {
            let error = this.getError('ERROR', message);
            this.addLog(error);
            if (this._logtoconsole) {
                console.error.apply( console, arguments );
            }
        }
    }

     /**
      *  add info message to logStore
      */
    info(message: any) {
        if (this.isInfoEnabled()) {
            let error = this.getError('INFO', message);
            this.addLog(error);
            if (this._logtoconsole) {
                console.info.apply( console, arguments );
            }
        }
    }

    /**
     *  @deprecated Use trace instead
     *  add debug message to logStore
     */
    debug(message: any) {
        this.trace(message);
    }

    /**
     * add trace message to logStore
     */
    trace(message: any) {
        if (this.isTraceEnabled()) {
            let error = this.getError('TRACE', message);
            this.addLog(error);
            if (this._logtoconsole) {
                ( <any> console )[ CONSOLE_DEBUG_METHOD ].apply( console, arguments );
            }
        }
    }

    /**
     *  get log messages
     */
    _getLogs(): Array<Error> {
        return this._logStore;
    }

    /**
     *  get current url path
     */
    private getUrl() {
       let url = window.location.pathname;
       return url;
    }

    /**
     * get module name from path
     * @param {string} url
     */
    private getModule(url: string) {
        return url && url.split('/').length > 4 ? url.split('/')[4] : null;
    }

    /**
     *  add log message to logStore
     */
    private addLog(error: Error) {
      this._logStore.push(error);
    }

    /**
     *  clear log messages from logStore
     */
    _clearLogs() {
        this._logStore.splice(0, this._logStore.length);
    }

    /**
     *  print log store to console
     */
    _printLogs() {
        console.log(this._logStore);
    }

    isErrorEnabled = (): boolean => this.level >= Level.ERROR;
    isInfoEnabled = (): boolean => this.level >= Level.INFO;
    isTraceEnabled = (): boolean => this.level >= Level.TRACE;
    /**
     * @deprecated use isTraceEnabled instead
     */
    isDebugEnabled = (): boolean => this.isTraceEnabled();

    get level(): Level { return this._level; }

    _setLogToConsole(canLog: boolean) {
        this._logtoconsole = canLog;
    }

    _setLogLevel(level: Level) {
        this._level = level;
    }
}
